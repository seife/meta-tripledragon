diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/boot/simple/embed_config.c linux-2.6.12/arch/ppc/boot/simple/embed_config.c
--- linux-2.6.12.orig/arch/ppc/boot/simple/embed_config.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/boot/simple/embed_config.c	2005-06-27 22:56:02.000000000 +0200
@@ -781,14 +781,19 @@
 }
 #endif /* CONFIG_XILINX_ML300 */
 
-#ifdef CONFIG_IBM_OPENBIOS
+#if defined(CONFIG_IBM_OPENBIOS)
 /* This could possibly work for all treeboot roms.
 */
+// but not for me - sorry .... (I do not want to waste valuable flash from 0030 to 0b50)
+	#if defined(CONFIG_TRIPLEDRAGON) || defined(CONFIG_REDWOOD_5)
+		#define BOARD_INFO_VECTOR	0xFFFE0030
+	#else
 #if defined(CONFIG_ASH) || defined(CONFIG_BEECH) || defined(CONFIG_BUBINGA)
 #define BOARD_INFO_VECTOR       0xFFF80B50 /* openbios 1.19 moved this vector down  - armin */
 #else
 #define BOARD_INFO_VECTOR	0xFFFE0B50
 #endif
+	#endif
 
 #ifdef CONFIG_BEECH
 static void
@@ -814,8 +819,8 @@
 	bd_t	*bd, *treeboot_bd;
 	bd_t *(*get_board_info)(void) =
 	    (bd_t *(*)(void))(*(unsigned long *)BOARD_INFO_VECTOR);
-#if !defined(CONFIG_STB03xxx)
 
+#if !defined(CONFIG_STB03xxx) && !defined(CONFIG_TRIPLEDRAGON)
 	/* shut down the Ethernet controller that the boot rom
 	 * sometimes leaves running.
 	 */
@@ -855,7 +860,7 @@
 	 * different object in the structure.  Sincr Redwwood 5
 	 * and Redwood 6 use OpenBIOS, it requires a special value.
 	 */
-#if defined(CONFIG_REDWOOD_5) || defined (CONFIG_REDWOOD_6)
+#if defined(CONFIG_IBM_PALLAS) || defined(CONFIG_REDWOOD_6)
 	bd->bi_tbfreq = 27 * 1000 * 1000;
 #endif
 	timebase_period_ns = 1000000000 / bd->bi_tbfreq;
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/boot/simple/head.S linux-2.6.12/arch/ppc/boot/simple/head.S
--- linux-2.6.12.orig/arch/ppc/boot/simple/head.S	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/boot/simple/head.S	2005-06-27 23:04:16.000000000 +0200
@@ -35,7 +35,7 @@
 	.globl	start
 start:
 	bl	start_
-#ifdef CONFIG_IBM_OPENBIOS
+#if defined(CONFIG_IBM_OPENBIOS)
 	/* The IBM "Tree" bootrom knows that the address of the bootrom
 	 * read only structure is 4 bytes after _start.
 	 */
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/boot/simple/misc-embedded.c linux-2.6.12/arch/ppc/boot/simple/misc-embedded.c
--- linux-2.6.12.orig/arch/ppc/boot/simple/misc-embedded.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/boot/simple/misc-embedded.c	2005-06-27 23:05:19.000000000 +0200
@@ -82,17 +82,26 @@
 unsigned long
 load_kernel(unsigned long load_addr, int num_words, unsigned long cksum, bd_t *bp)
 {
-	char *cp, ch;
-	int timer = 0, zimage_size;
+#if !defined(CONFIG_TRIPLEDRAGON)
+	char ch;
+	int timer = 0;
+#endif
+	char *cp;
+	int zimage_size;
 	unsigned long initrd_size;
 
 	/* First, capture the embedded board information.  Then
 	 * initialize the serial console port.
 	 */
 	embed_config(&bp);
+
+#if defined(CONFIG_TRIPLEDRAGON)
+	com_port = serial_init(1, bp);
+#else
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE)
 	com_port = serial_init(0, bp);
 #endif
+#endif
 
 	/* Grab some space for the command line and board info.  Since
 	 * we no longer use the ELF header, but it was loaded, grab
@@ -177,6 +186,15 @@
 	 * If we weren't, see if we have a ramdisk.  If so, thats root.
 	 * When in doubt, give them the netroot (root=/dev/nfs rw) -- Tom
 	 */
+
+// thats much better for us. We simply pass a pointer to a comandline inside the "board-info-struct"
+// this cmdline is customizeable within our bootloader
+// we need it for example to customize mtd partitions or nfs mounts (especially for nft root)
+#if defined(CONFIG_TRIPLEDRAGON)
+	if( bp->bi_cmdline )
+		memcpy(cmd_line, bp->bi_cmdline, strlen(bp->bi_cmdline) + 1);
+#else
+
 #ifdef CONFIG_CMDLINE_BOOL
 	memcpy (cmd_line, compiled_string, sizeof(compiled_string));
 #else
@@ -185,8 +203,14 @@
 	else
 		memcpy (cmd_line, netroot_string, sizeof(netroot_string));
 #endif
+
+#endif
+
 	while ( *cp )
 		putc(*cp++);
+
+// time is money
+#if !defined(CONFIG_TRIPLEDRAGON)
 	while (timer++ < 5*1000) {
 		if (tstc()) {
 			while ((ch = getc()) != '\n' && ch != '\r') {
@@ -210,7 +234,10 @@
 		}
 		udelay(1000);  /* 1 msec */
 	}
+#endif
+
 	*cp = 0;
+
 	puts("\nUncompressing Linux...");
 
 	gunzip(0, 0x400000, zimage_start, &zimage_size);
@@ -266,7 +293,7 @@
 		rec->size = sizeof(struct bi_record);
 		rec = (struct bi_record *)((unsigned long)rec + rec->size);
 	}
-	puts("Now booting the kernel\n");
+	puts("Now booting the kernel (misc-embedded)\n");
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE)
 	serial_close(com_port);
 #endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/boot/simple/misc.c linux-2.6.12/arch/ppc/boot/simple/misc.c
--- linux-2.6.12.orig/arch/ppc/boot/simple/misc.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/boot/simple/misc.c	2005-06-27 13:17:39.000000000 +0200
@@ -99,9 +99,13 @@
 	struct bi_record *rec;
 	unsigned long initrd_loc = 0, TotalMemory = 0;
 
+#if defined(CONFIG_TRIPLEDRAGON)
+	com_port = serial_init(1, NULL);
+#else
 #if defined(CONFIG_SERIAL_8250_CONSOLE) || defined(CONFIG_SERIAL_MPSC_CONSOLE)
 	com_port = serial_init(0, NULL);
 #endif
+#endif
 
 #if defined(CONFIG_44x) && defined(PPC44x_EMAC0_MR0)
 	/* Reset MAL */
@@ -263,7 +267,7 @@
 
 		bootinfo_append(BI_INITRD, sizeof(initrd), &initrd);
 	}
-	puts("Now booting the kernel\n");
+	puts("Now booting the kernel (misc)\n");
 	serial_close(com_port);
 
 	return rec;
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/boot/utils/mktree.c linux-2.6.12/arch/ppc/boot/utils/mktree.c
--- linux-2.6.12.orig/arch/ppc/boot/utils/mktree.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/boot/utils/mktree.c	2005-06-24 21:41:46.000000000 +0200
@@ -113,7 +113,8 @@
 		exit(4);
 	}
 
-	nblks -= (64 * 1024) / IMGBLK;
+	nblks -= (64 * 1024 - sizeof (bt)) / IMGBLK;	// missed some data
+	bt.bb_num_512blocks = htonl(nblks + 1);			// better safe than sorry...
 
 	/* And away we go......
 	*/
@@ -122,7 +123,7 @@
 		exit(5);
 	}
 
-	while (nblks-- > 0) {
+	while (--nblks > 0) {
 		if (read(in_fd, tmpbuf, IMGBLK) < 0) {
 			perror("zImage read");
 			exit(5);
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/configs/tripledragon_defconfig linux-2.6.12/arch/ppc/configs/tripledragon_defconfig
--- linux-2.6.12.orig/arch/ppc/configs/tripledragon_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/arch/ppc/configs/tripledragon_defconfig	2005-06-28 00:30:18.000000000 +0200
@@ -0,0 +1,1057 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12
+# Tue Jun 28 00:30:00 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=4
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=4
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+# CONFIG_XILINX_ML300 is not set
+CONFIG_TRIPLEDRAGON=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+CONFIG_IBM_PALLAS=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_STBXXX_DMA=y
+CONFIG_PPC_GEN550=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+# CONFIG_SERIAL_SICC is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Advanced setup
+#
+CONFIG_ADVANCED_OPTIONS=y
+CONFIG_HIGHMEM_START=0xfe000000
+# CONFIG_LOWMEM_SIZE_BOOL is not set
+CONFIG_LOWMEM_SIZE=0x30000000
+# CONFIG_KERNEL_START_BOOL is not set
+CONFIG_KERNEL_START=0xc0000000
+# CONFIG_TASK_SIZE_BOOL is not set
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_CONSISTENT_START_BOOL is not set
+CONFIG_CONSISTENT_START=0xff100000
+# CONFIG_CONSISTENT_SIZE_BOOL is not set
+CONFIG_CONSISTENT_SIZE=0x00200000
+# CONFIG_BOOT_LOAD_BOOL is not set
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0xff800000
+CONFIG_MTD_PHYSMAP_LEN=0x00800000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_STB04xxx=m
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_OAKNET is not set
+CONFIG_SMC91X=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=720
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=576
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=0
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+CONFIG_FUSION_DEVICE=y
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_M41T00 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_S3TRIO is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_PPC_SOC=y
+CONFIG_USB_OHCI_BIG_ENDIAN=y
+# CONFIG_USB_OHCI_LITTLE_ENDIAN is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_ZD1201 is not set
+CONFIG_USB_MON=m
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=m
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+CONFIG_XFS_FS=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_NAND=y
+CONFIG_JFFS2_FS_NOR_ECC=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_JFFS2_RUBIN=y
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+CONFIG_NLS_ISO8859_9=y
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/kernel/dma-mapping.c linux-2.6.12/arch/ppc/kernel/dma-mapping.c
--- linux-2.6.12.orig/arch/ppc/kernel/dma-mapping.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/kernel/dma-mapping.c	2005-06-24 21:58:23.000000000 +0200
@@ -367,8 +367,7 @@
 /*
  * make an area consistent.
  */
-void __dma_sync(void *vaddr, size_t size, int direction)
-{
+void __dma_sync(void *vaddr, size_t size, int direction) {
 	unsigned long start = (unsigned long)vaddr;
 	unsigned long end   = start + size;
 
@@ -375,9 +374,27 @@
 	switch (direction) {
 	case DMA_NONE:
 		BUG();
+
 	case DMA_FROM_DEVICE:	/* invalidate only */
+#if defined(CONFIG_40x)
+			/* Handle cases where the buffer start and/or end
+			 * are not L1 cache line aligned.
+			 * Some drivers/subsystems (e.g. USB, SCSI) do DMA
+			 * from stack allocated buffers. To prevent
+			 * corruption of other stack variables located
+			 * near the buffer, we flush (instead of invalidate)
+			 * these "dangerous" areas.
+			 * patch from Eugene Surovegin <ebs@ebshome.net>
+			 */
+			if( unlikely(start & (L1_CACHE_LINE_SIZE - 1)) )
+				__asm__ __volatile__("dcbf 0,%0" : : "r" (start));
+
+			if( unlikely(end & (L1_CACHE_LINE_SIZE - 1)) )
+				__asm__ __volatile__("dcbf 0,%0" : : "r" (end));
+#endif
 		invalidate_dcache_range(start, end);
 		break;
+
 	case DMA_TO_DEVICE:		/* writeback only */
 		clean_dcache_range(start, end);
 		break;
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/platforms/4xx/Kconfig linux-2.6.12/arch/ppc/platforms/4xx/Kconfig
--- linux-2.6.12.orig/arch/ppc/platforms/4xx/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/platforms/4xx/Kconfig	2005-06-27 22:01:12.000000000 +0200
@@ -61,6 +61,11 @@
 	help
 	  This option enables support for the Xilinx ML300 evaluation board.
 
+config TRIPLEDRAGON
+	bool "Triple-Dragon"
+	help
+	  This option enables support for the TripleDragon STB.
+
 endchoice
 
 choice
@@ -142,7 +147,7 @@
 
 config IBM_OCP
 	bool
-	depends on ASH || BUBINGA || CPCI405 || EBONY || EP405 || LUAN || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ASH || BUBINGA || CPCI405 || EBONY || EP405 || LUAN || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT || TRIPLEDRAGON
 	default y
 
 config XILINX_OCP
@@ -187,7 +192,12 @@
 
 config STB03xxx
 	bool
-	depends on REDWOOD_5 || REDWOOD_6
+	depends on REDWOOD_5 || REDWOOD_6 || TRIPLEDRAGON
+	default y
+
+config IBM_PALLAS
+	bool
+	depends on REDWOOD_5 || TRIPLEDRAGON
 	default y
 
 config EMBEDDEDBOOT
@@ -197,7 +207,7 @@
 
 config IBM_OPENBIOS
 	bool
-	depends on ASH || BUBINGA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ASH || BUBINGA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT || TRIPLEDRAGON
 	default y
 
 config PPC4xx_DMA
@@ -205,10 +215,15 @@
 	depends on 4xx
 
 config PPC4xx_EDMA
-	bool
+	bool "PPC4xx EDMA (SG) Controller Support"
 	depends on !STB03xxx && PPC4xx_DMA
 	default y
 
+config STBXXX_DMA
+	bool "STB04 DMA controller support (TD)"
+	depends on PPC4xx_DMA
+	default y
+
 config PPC_GEN550
 	bool
 	depends on 4xx
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/platforms/4xx/Makefile linux-2.6.12/arch/ppc/platforms/4xx/Makefile
--- linux-2.6.12.orig/arch/ppc/platforms/4xx/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/platforms/4xx/Makefile	2005-06-27 22:34:35.000000000 +0200
@@ -9,14 +9,14 @@
 obj-$(CONFIG_LUAN)		+= luan.o
 obj-$(CONFIG_OAK)		+= oak.o
 obj-$(CONFIG_OCOTEA)		+= ocotea.o
-obj-$(CONFIG_REDWOOD_5)		+= redwood5.o
+obj-$(CONFIG_IBM_PALLAS)	+= redwood5.o
 obj-$(CONFIG_REDWOOD_6)		+= redwood6.o
 obj-$(CONFIG_SYCAMORE)		+= sycamore.o
 obj-$(CONFIG_WALNUT)		+= walnut.o
 obj-$(CONFIG_XILINX_ML300)	+= xilinx_ml300.o
 
 obj-$(CONFIG_405GP)		+= ibm405gp.o
-obj-$(CONFIG_REDWOOD_5)		+= ibmstb4.o
+obj-$(CONFIG_IBM_PALLAS)	+= ibmstb4.o
 obj-$(CONFIG_NP405H)		+= ibmnp405h.o
 obj-$(CONFIG_REDWOOD_6)		+= ibmstbx25.o
 obj-$(CONFIG_440GP)		+= ibm440gp.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/platforms/4xx/ibmstb4.c linux-2.6.12/arch/ppc/platforms/4xx/ibmstb4.c
--- linux-2.6.12.orig/arch/ppc/platforms/4xx/ibmstb4.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/platforms/4xx/ibmstb4.c	2005-06-26 21:48:33.000000000 +0200
@@ -11,6 +11,7 @@
 
 #include <linux/init.h>
 #include <asm/ocp.h>
+#include <asm/usb.h>
 #include <platforms/4xx/ibmstb4.h>
 
 static struct ocp_func_iic_data ibmstb4_iic0_def = {
@@ -22,7 +23,7 @@
 };
 OCP_SYSFS_IIC_DATA()
 
-struct ocp_def core_ocp[] __initdata = {
+struct ocp_def core_ocp[] = {
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_16550,
 	  .index	= 0,
@@ -46,6 +47,7 @@
 	},
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_IIC,
+	  .index    = 0,
 	  .paddr	= IIC0_BASE,
 	  .irq		= IIC0_IRQ,
 	  .pm		= IBM_CPM_IIC0,
@@ -54,6 +56,7 @@
 	},
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_IIC,
+	  .index    = 1,
 	  .paddr	= IIC1_BASE,
 	  .irq		= IIC1_IRQ,
 	  .pm		= IBM_CPM_IIC1,
@@ -79,5 +82,76 @@
 	  .pm		= OCP_CPM_NA,
 	},
 	{ .vendor	= OCP_VENDOR_INVALID,
+	},
+};
+
+
+
+
+// Power up the USB subsection
+static int enable_usb(struct platform_device *pdev) {
+	u32 mask;
+
+	mask = 1 << (31 - USB0_IRQ);
+	mtdcr(DCRN_UIC_PR(UIC0), mfdcr(DCRN_UIC_PR(UIC0)) | mask);
+	mtdcr(DCRN_UIC_TR(UIC0), mfdcr(DCRN_UIC_TR(UIC0)) & ~mask);
+	return(0);
 	}
+
+// Power down the USB subsection
+static void disable_usb(struct platform_device *pdev) {
+	u32 mask;
+
+	mask = 1 << (31 - USB0_IRQ);
+	mtdcr(DCRN_UIC_PR(UIC0), mfdcr(DCRN_UIC_PR(UIC0)) & ~mask);
+	mtdcr(DCRN_UIC_TR(UIC0), mfdcr(DCRN_UIC_TR(UIC0)) | mask);
+}
+
+static struct usb_hcd_platform_data pd = {
+	.start = enable_usb,
+	.stop = disable_usb,
+};
+
+
+static struct resource ohci_usb_resources[] = {
+	[0] = {
+		.start  = USB0_BASE,
+		.end    = USB0_BASE + USB0_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+		[1] = {
+		.start  = USB0_IRQ,
+		.end    = USB0_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static u64 dma_mask = 0xffffffffULL;
+
+
+
+static struct platform_device ohci_usb_device = {
+	.name       = "ppc-soc-ohci",
+	.id     = 0,
+	.num_resources  = ARRAY_SIZE(ohci_usb_resources),
+					  .resource   = ohci_usb_resources,
+	.dev        = {
+		.dma_mask = &dma_mask,
+		.coherent_dma_mask = 0xffffffffULL,
+		.platform_data = &pd,
+	},
+};
+
+
+static struct platform_device *ibmstb4_devs[] __initdata = {
+	&ohci_usb_device,
 };
+
+
+//--------------------------------------------------------------------------
+static int __init ibmstb4_platform_add_devices(void) {
+	return(platform_add_devices(ibmstb4_devs, ARRAY_SIZE(ibmstb4_devs)));
+}
+
+arch_initcall(ibmstb4_platform_add_devices);
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/platforms/4xx/ibmstb4.h linux-2.6.12/arch/ppc/platforms/4xx/ibmstb4.h
--- linux-2.6.12.orig/arch/ppc/platforms/4xx/ibmstb4.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/platforms/4xx/ibmstb4.h	2005-06-27 11:29:35.000000000 +0200
@@ -73,9 +73,9 @@
 #define OPB0_BASE	0x40000000
 #define GPIO0_BASE	0x40060000
 
+#define USB0_BASE	0x40010000
+#define USB0_SIZE	0xA0
 #define USB0_IRQ	18
-#define USB0_BASE	STB04xxx_MAP_IO_ADDR(0x40010000)
-#define USB0_EXTENT 4096
 
 #define IIC_NUMS 2
 #define UART_NUMS	3
@@ -160,20 +160,21 @@
 #define IBM_CPM_SC1	0x00008000	/* Smart Card 1 */
 #define IBM_CPM_USBSDRA	0x00004000	/* SDRAM 0 memory controller */
 #define IBM_CPM_XPT0	0x00002000	/* Transport - 54 Mhz */
-#define IBM_CPM_CBS	0x00001000	/* Cross Bar Switch */
+#define IBM_CPM_DDI12	(1 << (31-19))	/* Descrambler 1, 2 */
 #define IBM_CPM_GPT	0x00000800	/* GPTPWM */
 #define IBM_CPM_GPIO0	0x00000400	/* General Purpose IO 0 */
 #define IBM_CPM_DENC	0x00000200	/* Digital video Encoder */
 #define IBM_CPM_TMRCLK	0x00000100	/* CPU timers */
 #define IBM_CPM_XPT27	0x00000080	/* Transport - 27 Mhz */
 #define IBM_CPM_UIC	0x00000040	/* Universal Interrupt Controller */
-#define IBM_CPM_SSP	0x00000010	/* Modem Serial Interface (SSP) */
+#define IBM_CPM_GFX	(1 << (31-26))	/* Graphics Control */
+#define IBM_CPM_SSP	(1 << (31-27))	/* Modem Serial Interface (SSP) */
 #define IBM_CPM_UART2	0x00000008	/* Serial Control Port */
 #define IBM_CPM_DDIO	0x00000004	/* Descrambler */
 #define IBM_CPM_VID2	0x00000002	/* Video Decoder clock domain 2 */
 
 #define DFLT_IBM4xx_PM	~(IBM_CPM_CPU | IBM_CPM_EBIU | IBM_CPM_SDRAM1 \
-			| IBM_CPM_DMA | IBM_CPM_DMA1 | IBM_CPM_CBS \
+			| IBM_CPM_DMA | IBM_CPM_DMA1 | IBM_CPM_DDI12 \
 			| IBM_CPM_USBSDRA | IBM_CPM_XPT0 | IBM_CPM_TMRCLK \
 			| IBM_CPM_XPT27 | IBM_CPM_UIC )
 
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/platforms/4xx/redwood5.c linux-2.6.12/arch/ppc/platforms/4xx/redwood5.c
--- linux-2.6.12.orig/arch/ppc/platforms/4xx/redwood5.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/platforms/4xx/redwood5.c	2005-06-27 23:19:21.000000000 +0200
@@ -18,6 +18,8 @@
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <asm/machdep.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/map.h>
 
 static struct resource smc91x_resources[] = {
 	[0] = {
@@ -49,9 +53,14 @@
 	return platform_add_devices(redwood5_devs, ARRAY_SIZE(redwood5_devs));
 }
 
-void __init
-redwood5_setup_arch(void)
-{
+
+#define CONFIG_DEBUG_BRINGUP 1
+
+void __init redwood5_setup_arch(void) {
+#if defined(CONFIG_DEBUG_BRINGUP) || defined(CONFIG_TRIPLEDRAGON)
+	const bd_t * const bip = &__res;
+#endif
+
 	ppc4xx_setup_arch();
 
 #ifdef CONFIG_DEBUG_BRINGUP
@@ -55,48 +64,58 @@
 	ppc4xx_setup_arch();
 
 #ifdef CONFIG_DEBUG_BRINGUP
+
 	printk("\n");
-	printk("machine\t: %s\n", PPC4xx_MACHINE_NAME);
+	printk("machine: %s\n", PPC4xx_MACHINE_NAME);
+	printk("bi_s_version (bd_t struct's version)  : %s\n", bip->bi_s_version);
+	printk("bi_r_version (bios/bootloader version): %s\n", bip->bi_r_version);
 	printk("\n");
-	printk("bi_s_version\t %s\n",      bip->bi_s_version);
-	printk("bi_r_version\t %s\n",      bip->bi_r_version);
-	printk("bi_memsize\t 0x%8.8x\t %dMBytes\n", bip->bi_memsize,bip->bi_memsize/(1024*1000));
-	printk("bi_enetaddr %d\t %2.2x%2.2x%2.2x-%2.2x%2.2x%2.2x\n", 0,
-	bip->bi_enetaddr[0], bip->bi_enetaddr[1],
-	bip->bi_enetaddr[2], bip->bi_enetaddr[3],
-	bip->bi_enetaddr[4], bip->bi_enetaddr[5]);
+	printk("bi_memsize : 0x%.8x (%.2d)MBytes\n", bip->bi_memsize, bip->bi_memsize/(1024*1000));
+	printk("bi_memsize1: 0x%.8x (%.2d)MBytes\n", bip->bi_memsize1, bip->bi_memsize1/(1024*1000));
+	printk("bi_enetaddr: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+		   bip->bi_enetaddr[0], bip->bi_enetaddr[1], bip->bi_enetaddr[2],
+		   bip->bi_enetaddr[3], bip->bi_enetaddr[4], bip->bi_enetaddr[5]);
 
-	printk("bi_intfreq\t 0x%8.8x\t clock:\t %dMhz\n",
+	printk("bi_intfreq (CPU speed) : 0x%.8x (%d)Mhz\n",
 	       bip->bi_intfreq, bip->bi_intfreq/ 1000000);
 
-	printk("bi_busfreq\t 0x%8.8x\t plb bus clock:\t %dMHz\n",
+	printk("bi_busfreq (PLB clock) :  0x%.8x (%d)MHz\n",
 		bip->bi_busfreq, bip->bi_busfreq / 1000000 );
-	printk("bi_tbfreq\t 0x%8.8x\t TB freq:\t %dMHz\n",
+	printk("bi_tbfreq (SW timebase): 0x%.8x (%d)MHz\n",
 	       bip->bi_tbfreq, bip->bi_tbfreq/1000000);
 
+	printk("bi_opb_busfreq         : 0x%.8x (%d)MHz\n",
+		   bip->bi_opb_busfreq, bip->bi_opb_busfreq / 1000000);
+	printk("bi_iic_fast enable     : [0] %.1x, [1] %.1x\n",
+		   bip->bi_iic_fast[0], bip->bi_iic_fast[1]);
+	printk("flash_base             : 0x%.8x\n", bip->flash_base);
+
 	printk("\n");
+
 #endif
+	{
 	device_initcall(redwood5_platform_add_devices);
 }
 
-void __init
-redwood5_map_io(void)
-{
-	int i;
+#if defined(CONFIG_TRIPLEDRAGON)
+	physmap_configure(bip->flash_base, -bip->flash_base, 2, NULL);
+#endif
+
+	/* Identify the system */
+	printk(KERN_INFO "MNC Ltd. DBx3000\n");
+	printk(KERN_INFO "http://www.mncltd.com\n");
+}
+
+void __init redwood5_map_io(void) {
+	unsigned int i, v, p;
 
 	ppc4xx_map_io();
 	for (i = 0; i < 16; i++) {
-	 unsigned long v, p;
-
 	/* 0x400x0000 -> 0xe00x0000 */
 	p = 0x40000000 | (i << 16);
 	v = STB04xxx_IO_BASE | (i << 16);
-
-	io_block_mapping(v, p, PAGE_SIZE,
-		 _PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+		io_block_mapping(v, p, PAGE_SIZE, _PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
 	}
-
-
 }
 
 void __init
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/platforms/4xx/redwood5.h linux-2.6.12/arch/ppc/platforms/4xx/redwood5.h
--- linux-2.6.12.orig/arch/ppc/platforms/4xx/redwood5.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/platforms/4xx/redwood5.h	2005-06-27 23:18:33.000000000 +0200
@@ -21,6 +21,23 @@
 
 #ifndef __ASSEMBLY__
 typedef struct board_info {
+
+#if defined(CONFIG_TRIPLEDRAGON)
+
+	unsigned char   bi_s_version[4];	/* Version of this structure */
+	unsigned char   bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int    bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int    bi_memsize1;		/* field shouldn't exist */
+	unsigned char   bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int    bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int    bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int    bi_tbfreq;		/* Software timebase freq */
+	unsigned int    bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int     bi_iic_fast[2];		/* Use fast i2c mode */
+	unsigned char   *bi_cmdline;		/* bios kernel commandline */
+	unsigned int    flash_base;		/* flash base address */
+
+#else
 	unsigned char	bi_s_version[4];	/* Version of this structure */
 	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
 	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
@@ -29,7 +46,10 @@
 	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
 	unsigned int	bi_tbfreq;		/* Software timebase freq */
+#endif
+
 } bd_t;
+
 #endif /* !__ASSEMBLY__ */
 
 
@@ -48,7 +68,11 @@
 
 #define BASE_BAUD		(378000000 / 18 / 16)
 
+#if defined(CONFIG_TRIPLEDRAGON)
+#define PPC4xx_MACHINE_NAME	"TRIPLEDRAGON STB"
+#else
 #define PPC4xx_MACHINE_NAME	"IBM Redwood5"
+#endif
 
 #endif /* __ASM_REDWOOD5_H__ */
 #endif /* __KERNEL__ */
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/syslib/Makefile linux-2.6.12/arch/ppc/syslib/Makefile
--- linux-2.6.12.orig/arch/ppc/syslib/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/syslib/Makefile	2005-06-25 17:25:29.000000000 +0200
@@ -29,6 +29,7 @@
 obj-$(CONFIG_GEN_RTC)		+= todc_time.o
 obj-$(CONFIG_PPC4xx_DMA)	+= ppc4xx_dma.o
 obj-$(CONFIG_PPC4xx_EDMA)	+= ppc4xx_sgdma.o
+obj-$(CONFIG_STBXXX_DMA)	+= ppc4xx_stbdma.o
 ifeq ($(CONFIG_40x),y)
 obj-$(CONFIG_PCI)		+= indirect_pci.o pci_auto.o ppc405_pci.o
 endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/syslib/ppc4xx_dma.c linux-2.6.12/arch/ppc/syslib/ppc4xx_dma.c
--- linux-2.6.12.orig/arch/ppc/syslib/ppc4xx_dma.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/syslib/ppc4xx_dma.c	2005-06-25 21:37:58.000000000 +0200
@@ -606,20 +606,26 @@
 	return (GET_DMA_PW(control));
 }
 
-/*
- * Clears the channel status bits
- */
-int
-ppc4xx_clr_dma_status(unsigned int dmanr)
-{
+
+
+int ppc4xx_clr_dma_status(unsigned int dmanr) {
 	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
 		printk(KERN_ERR "ppc4xx_clr_dma_status: bad channel: %d\n", dmanr);
-		return DMA_STATUS_BAD_CHANNEL;
+		return(DMA_STATUS_BAD_CHANNEL);
 	}
 	mtdcr(DCRN_DMASR, ((u32)DMA_CH0_ERR | (u32)DMA_CS0 | (u32)DMA_TS0) >> dmanr);
-	return DMA_STATUS_GOOD;
+	return(DMA_STATUS_GOOD);
 }
 
+
+//--------------------------------------------------------------------------
+// our DMAs do not have a burstenable-bit here
+//--------------------------------------------------------------------------
+#if !defined(CONFIG_STBXXX_DMA)
+/*
+ * Clears the channel status bits
+ */
+
 /*
  * Enables the burst on the channel (BTEN bit in the control/count register)
  * Note:
@@ -685,6 +691,13 @@
 	return DMA_STATUS_GOOD;
 }
 
+EXPORT_SYMBOL(ppc4xx_enable_burst);
+EXPORT_SYMBOL(ppc4xx_disable_burst);
+EXPORT_SYMBOL(ppc4xx_set_burst_size);
+
+#endif	// CONFIG_STBXXX_DMA
+
+
 EXPORT_SYMBOL(ppc4xx_init_dma_channel);
 EXPORT_SYMBOL(ppc4xx_get_channel_config);
 EXPORT_SYMBOL(ppc4xx_set_channel_priority);
@@ -703,6 +716,3 @@
 EXPORT_SYMBOL(ppc4xx_disable_dma_interrupt);
 EXPORT_SYMBOL(ppc4xx_get_dma_status);
 EXPORT_SYMBOL(ppc4xx_clr_dma_status);
-EXPORT_SYMBOL(ppc4xx_enable_burst);
-EXPORT_SYMBOL(ppc4xx_disable_burst);
-EXPORT_SYMBOL(ppc4xx_set_burst_size);
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/syslib/ppc4xx_pm.c linux-2.6.12/arch/ppc/syslib/ppc4xx_pm.c
--- linux-2.6.12.orig/arch/ppc/syslib/ppc4xx_pm.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/arch/ppc/syslib/ppc4xx_pm.c	2005-06-25 23:35:01.000000000 +0200
@@ -32,7 +32,7 @@
 
 #if !defined(CONFIG_PPC405_I2C_ADAP)
 	value |= CPM_IIC0;
-#ifdef CONFIG_STB03xxx
+#if defined(CONFIG_STB03xxx) || defined(CONFIG_TRIPLEDRAGON)
 	value |= CPM_IIC1;
 #endif
 #endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/arch/ppc/syslib/ppc4xx_stbdma.c linux-2.6.12/arch/ppc/syslib/ppc4xx_stbdma.c
--- linux-2.6.12.orig/arch/ppc/syslib/ppc4xx_stbdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/arch/ppc/syslib/ppc4xx_stbdma.c	2004-10-11 18:14:05.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ * arch/ppc/syslib/ppc4xx_stbdma.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	IBM PPC4xx STBxxxx DMA Controller Functions
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         Armin Kuster <akuster@mvista.com>
+ *
+ * Based on ppc4xx_dma.c by
+ *         ppopov@mvista.com or source@mvista.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/ppc4xx_dma.h>
+
+int clr_dma_status(unsigned int dmanr) {
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	p_dma_ch->int_enable = 1;
+
+	control = mfdcr(DCRN_DMASR);
+	switch (dmanr) {
+	case 0:
+		control |= DMA_CS0 & DMA_CH0_ERR & DMA_CT0;
+		break;
+	case 1:
+		control |= DMA_CS1 & DMA_CH1_ERR & DMA_CT1;
+		break;
+	case 2:
+		control |= DMA_CS2 & DMA_CH2_ERR & DMA_CT2;
+		break;
+	case 3:
+		control |= DMA_CS3 & DMA_CH3_ERR & DMA_CT3;
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("clr_dma_status: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	mtdcr(DCRN_DMASR, control);
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Maps a given port to a one of the dma
+ * channels
+ */
+int map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan) {
+	unsigned int map;
+	int connect_port_to_chan, select;
+
+	connect_port_to_chan = ((ocp_dma & 0x7)*4);
+
+	select = ocp_dma >> 3;
+	switch (select) {
+	case 0:
+		map = mfdcr(DCRN_DMAS1);
+		map |= (connect_port_to_chan << dma_chan);	/* */
+		mtdcr(DCRN_DMAS1, map);
+		break;
+	case 1:
+		map = mfdcr(DCRN_DMAS2);
+		map |= (connect_port_to_chan << dma_chan);
+		mtdcr(DCRN_DMAS2, map);
+		break;
+
+	default:
+		printk("map_dma_port: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
+
+int disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan) {
+	unsigned int map;
+	int connect_port_to_chan, select;
+
+	connect_port_to_chan = ((ocp_dma & 0x7)*4);
+	select = ocp_dma >> 3;
+	switch (select) {
+	case 0:
+		map = mfdcr(DCRN_DMAS1);
+		map &= ~(connect_port_to_chan << dma_chan);	/* */
+		mtdcr(DCRN_DMAS1, map);
+		break;
+	case 1:
+		map = mfdcr(DCRN_DMAS2);
+		map &= ~(connect_port_to_chan << dma_chan);
+		mtdcr(DCRN_DMAS2, map);
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("disable_dma_port: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
+
+EXPORT_SYMBOL(disable_dma_port);
+EXPORT_SYMBOL(map_dma_port);
+EXPORT_SYMBOL(clr_dma_status);
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/Kconfig linux-2.6.12/drivers/char/Kconfig
--- linux-2.6.12.orig/drivers/char/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/Kconfig	2005-06-26 00:17:16.000000000 +0200
@@ -998,5 +998,10 @@
 
 source "drivers/char/tpm/Kconfig"
 
-endmenu
+config FUSION_DEVICE
+	tristate "Fusion Kernel Device (for DirectFB)"
+	help
+	  The Fusion Kernel Device is needed to use DirectFB's multi
+	  application core.
 
+endmenu
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/Makefile linux-2.6.12/drivers/char/Makefile
--- linux-2.6.12.orig/drivers/char/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/Makefile	2005-06-26 00:17:16.000000000 +0200
@@ -89,6 +89,8 @@
 obj-$(CONFIG_PCMCIA) += pcmcia/
 obj-$(CONFIG_IPMI_HANDLER) += ipmi/
 
+obj-$(CONFIG_FUSION_DEVICE) += fusion/
+
 obj-$(CONFIG_HANGCHECK_TIMER) += hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM) += tpm/
 # Files generated that shall be removed upon make clean
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/.cvsignore linux-2.6.12/drivers/char/_fusion_/.cvsignore
--- linux-2.6.12.orig/drivers/char/_fusion_/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/.cvsignore	2003-12-15 19:11:48.000000000 +0100
@@ -0,0 +1,5 @@
+*.o.flags
+*.cmd
+Makefile
+fusion.ko
+fusion.mod.c
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/Makefile linux-2.6.12/drivers/char/_fusion_/Makefile
--- linux-2.6.12.orig/drivers/char/_fusion_/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/Makefile	2005-06-24 19:25:05.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSION_DEVICE) += fusion.o
+
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.4 linux-2.6.12/drivers/char/_fusion_/Makefile-2.4
--- linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.4	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/Makefile-2.4	2005-06-25 14:56:25.000000000 +0200
@@ -0,0 +1,6 @@
+O_TARGET := fusion.o
+
+obj-y   := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
+obj-$(CONFIG_FUSION_DEVICE)   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.6 linux-2.6.12/drivers/char/_fusion_/Makefile-2.6
--- linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.6	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/Makefile-2.6	2005-06-25 14:56:11.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSION_DEVICE) += fusion.o
+
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/call.c linux-2.6.12/drivers/char/_fusion_/call.c
--- linux-2.6.12.orig/drivers/char/_fusion_/call.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/call.c	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,468 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "call.h"
+
+typedef struct {
+     FusionLink        link;
+
+     int               caller;
+
+     int               ret_val;
+
+     bool              executed;
+
+     wait_queue_head_t wait;
+} FusionCallExecution;
+
+typedef struct {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;        /* call id */
+
+     int                pid;       /* owner pid */
+     int                fusion_id; /* owner fusion id */
+
+     void              *handler;
+     void              *ctx;
+
+     FusionLink          *executions;      /* prepending! */
+     FusionLink          *last;            /* points to the last item of executions */
+
+     int                count;    /* number of calls ever made */
+} FusionCall;
+
+/******************************************************************************/
+
+static int  lookup_call (FusionDev *dev, int id, FusionCall **ret_call);
+static int  lock_call   (FusionDev *dev, int id, FusionCall **ret_call);
+static void unlock_call (FusionCall *call);
+
+static FusionCallExecution *add_execution       (FusionCall          *call,
+                                                 int                  fusion_id,
+                                                 FusionCallExecute   *execute);
+static void                 remove_execution    (FusionCall          *call,
+                                                 FusionCallExecution *execution);
+static void                 free_all_executions (FusionCall          *call);
+
+/******************************************************************************/
+
+static int
+fusion_call_read_proc (char *buf, char **start, off_t offset,
+                       int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          bool        idle = true;
+          FusionCall *call = (FusionCall*) l;
+
+          if (call->executions)
+               idle = ((FusionCallExecution*) call->executions)->executed;
+
+          written += sprintf(buf+written,
+                             "(%5d) 0x%08x (%d calls) %s\n",
+                             call->pid, call->id, call->count,
+                             idle ? "idle" : "executing");
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->call.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_call_init (FusionDev *dev)
+{
+     create_proc_read_entry("calls", 0, dev->proc_dir,
+                            fusion_call_read_proc, dev);
+
+     init_MUTEX(&dev->call.lock);
+
+     return 0;
+}
+
+void
+fusion_call_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     remove_proc_entry ("calls", dev->proc_dir);
+
+     l = dev->call.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          free_all_executions (call);
+
+          kfree (call);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
+{
+     FusionCall *call;
+
+     call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+     if (!call)
+          return -ENOMEM;
+
+     memset (call, 0, sizeof(FusionCall));
+
+     if (down_interruptible (&dev->call.lock)) {
+          kfree (call);
+          return -EINTR;
+     }
+
+     call->id        = dev->call.ids++;
+     call->pid       = current->pid;
+     call->fusion_id = fusion_id;
+     call->handler   = call_new->handler;
+     call->ctx       = call_new->ctx;
+
+     init_MUTEX (&call->lock);
+
+     fusion_list_prepend (&dev->call.list, &call->link);
+
+     up (&dev->call.lock);
+
+     call_new->call_id = call->id;
+
+     return 0;
+}
+
+int
+fusion_call_execute (FusionDev *dev, int fusion_id, FusionCallExecute *execute)
+{
+     int                  ret;
+     FusionCall          *call;
+     FusionCallExecution *execution;
+     FusionCallMessage    message;
+
+     ret = lock_call (dev, execute->call_id, &call);
+     if (ret)
+          return ret;
+
+     execution = add_execution (call, fusion_id, execute);
+     if (!execution) {
+          unlock_call (call);
+          return -ENOMEM;
+     }
+
+     /* Send call message. */
+     message.handler  = call->handler;
+     message.ctx      = call->ctx;
+
+     message.caller   = fusion_id;
+
+     message.call_arg = execute->call_arg;
+     message.call_ptr = execute->call_ptr;
+
+     ret = fusionee_send_message (dev, fusion_id, call->fusion_id, FMT_CALL,
+                                  call->id, sizeof(message), &message);
+     if (ret) {
+          remove_execution (call, execution);
+          kfree (execution);
+          unlock_call (call);
+          return ret;
+     }
+
+     call->count++;
+
+     if (fusion_id) {
+          /* TODO: implement timeout */
+          fusion_sleep_on (&execution->wait, &call->lock, 0);
+
+          ret = lock_call (dev, execute->call_id, &call);
+          if (ret)
+               return ret == -EINVAL ? -EIDRM : ret;
+
+          if (signal_pending(current)) {
+               execution->caller = 0;
+               unlock_call (call);
+               return -EINTR;
+          }
+
+          execute->ret_val = execution->ret_val;
+
+          remove_execution (call, execution);
+
+          kfree (execution);
+     }
+
+     unlock_call (call);
+
+     return 0;
+}
+
+int
+fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
+{
+     int         ret;
+     FusionLink *l;
+     FusionCall *call;
+
+     ret = lock_call (dev, call_ret->call_id, &call);
+     if (ret)
+          return ret;
+
+     l = call->last;
+     while (l) {
+          FusionCallExecution *execution = (FusionCallExecution*) l;
+
+          if (execution->executed) {
+               l = l->prev;
+               continue;
+          }
+
+          if (execution->caller) {
+               execution->ret_val  = call_ret->val;
+               execution->executed = true;
+
+               wake_up_interruptible_all (&execution->wait);
+          }
+          else {
+               remove_execution (call, execution);
+
+               kfree (execution);
+          }
+
+          unlock_call (call);
+
+          return 0;
+     }
+
+     unlock_call (call);
+
+     return -EIO;
+}
+
+int
+fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, call_id, &call);
+     if (ret)
+          return ret;
+
+     if (call->fusion_id != fusion_id) {
+          up (&dev->call.lock);
+          return -EIO;
+     }
+
+     if (down_interruptible (&call->lock)) {
+          up (&dev->call.lock);
+          return -EINTR;
+     }
+
+     fusion_list_remove (&dev->call.list, &call->link);
+
+     free_all_executions (call);
+
+     up (&dev->call.lock);
+
+     up (&call->lock);
+
+     kfree (call);
+
+     return 0;
+}
+
+void
+fusion_call_destroy_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     l = dev->call.list;
+
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          down (&call->lock);
+
+          if (call->fusion_id == fusion_id) {
+               free_all_executions (call);
+
+               fusion_list_remove (&dev->call.list, &call->link);
+
+               up (&call->lock);
+
+               kfree (call);
+          }
+          else
+               up (&call->lock);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          FusionCall *call = (FusionCall *) l;
+
+          if (call->id == id) {
+               *ret_call = call;
+               return 0;
+          }
+     }
+
+     up (&dev->call.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, id, &call);
+     if (ret)
+          return ret;
+
+     if (call) {
+          fusion_list_move_to_front (&dev->call.list, &call->link);
+
+          if (down_interruptible (&call->lock)) {
+               up (&dev->call.lock);
+               return -EINTR;
+          }
+
+          up (&dev->call.lock);
+     }
+
+     *ret_call = call;
+
+     return 0;
+}
+
+static void
+unlock_call (FusionCall *call)
+{
+     up (&call->lock);
+}
+
+static FusionCallExecution *
+add_execution (FusionCall        *call,
+               int                fusion_id,
+               FusionCallExecute *execute)
+{
+     FusionCallExecution *execution;
+
+     /* Allocate execution. */
+     execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+     if (!execution)
+          return NULL;
+
+     /* Initialize execution. */
+     memset (execution, 0, sizeof(FusionCallExecution));
+
+     execution->caller = fusion_id;
+
+     init_waitqueue_head (&execution->wait);
+
+     /* Add execution. */
+     fusion_list_prepend (&call->executions, &execution->link);
+
+     if (!call->last)
+          call->last = &execution->link;
+
+     return execution;
+}
+
+static void
+remove_execution (FusionCall          *call,
+                  FusionCallExecution *execution)
+{
+     if (call->last == &execution->link)
+          call->last = execution->link.prev;
+
+     fusion_list_remove (&call->executions, &execution->link);
+}
+
+static void
+free_all_executions (FusionCall *call)
+{
+     while (call->last) {
+          FusionCallExecution *execution = (FusionCallExecution *) call->last;
+
+          remove_execution (call, execution);
+
+          wake_up_interruptible_all (&execution->wait);
+
+          kfree (execution);
+     }
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/call.h linux-2.6.12/drivers/char/_fusion_/call.h
--- linux-2.6.12.orig/drivers/char/_fusion_/call.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/call.h	2003-07-10 01:31:28.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__CALL_H__
+#define __FUSION__CALL_H__
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+
+/* module init/cleanup */
+
+int  fusion_call_init   (FusionDev *dev);
+void fusion_call_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_call_new     (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallNew     *call);
+
+int fusion_call_execute (FusionDev         *dev,
+                         int                fusion_id, /* zero if call is
+                                                          from Fusion */
+                         FusionCallExecute *execute);
+
+int fusion_call_return  (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallReturn  *call_ret);
+
+int fusion_call_destroy (FusionDev         *dev,
+                         int                fusion_id,
+                         int                call_id);
+
+
+/* internal functions */
+
+void fusion_call_destroy_all (FusionDev *dev,
+                              int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/entries.c linux-2.6.12/drivers/char/_fusion_/entries.c
--- linux-2.6.12.orig/drivers/char/_fusion_/entries.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/entries.c	2004-12-12 15:09:40.000000000 +0100
@@ -0,0 +1,417 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/version.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "entries.h"
+
+
+void
+fusion_entries_init( FusionEntries    *entries,
+                     FusionEntryClass *class,
+                     void             *ctx )
+{
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( class != NULL );
+     FUSION_ASSERT( class->object_size >= sizeof(FusionEntry) );
+
+     memset( entries, 0, sizeof(FusionEntries) );
+
+     entries->class = class;
+     entries->ctx   = ctx;
+
+     init_MUTEX( &entries->lock );
+}
+
+void
+fusion_entries_deinit( FusionEntries *entries )
+{
+     FusionLink       *tmp;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     down( &entries->lock );
+
+     fusion_list_foreach_safe (entry, tmp, entries->list) {
+          if (class->Destroy)
+               class->Destroy( entry, entries->ctx );
+
+          kfree( entry );
+     }
+
+     up( &entries->lock );
+}
+
+int
+fusion_entries_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+     FusionEntries    *entries = private;
+     int               written = 0;
+     struct timeval    now;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     if (!class->Print)
+          return -ENOTSUPP;
+
+     if (down_interruptible (&entries->lock))
+          return -EINTR;
+
+     do_gettimeofday( &now );
+
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->last_lock.tv_sec) {
+               int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
+                           (now.tv_usec - entry->last_lock.tv_usec) / 1000);
+
+               if (diff < 1000) {
+                    written += sprintf( buf + written, "%3d  ms  ", diff );
+               }
+               else if (diff < 1000000) {
+                    written += sprintf( buf + written, "%3d.%d s  ",
+                                        diff / 1000, (diff % 1000) / 100 );
+               }
+               else {
+                    diff = ( now.tv_sec  - entry->last_lock.tv_sec +
+                            (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
+
+                    written += sprintf( buf + written, "%3d.%d h  ",
+                                        diff / 3600, (diff % 3600) / 360 );
+               }
+          }
+          else
+               written += sprintf( buf + written, "  -.-    " );
+
+
+          written += sprintf( buf + written, "(%5d) 0x%08x  ", entry->pid, entry->id );
+
+          written += sprintf( buf + written, "%-24s  ", entry->name[0] ? entry->name : "" );
+
+          written += class->Print( entry, entries->ctx, buf + written );
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&entries->lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+
+     return (written<0) ? 0 : written;
+}
+
+int
+fusion_entry_create( FusionEntries *entries,
+                     int           *ret_id )
+{
+     int               ret;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+     FUSION_ASSERT( ret_id != NULL );
+
+     class = entries->class;
+
+     entry = kmalloc( class->object_size, GFP_KERNEL );
+     if (!entry)
+          return -ENOMEM;
+
+     memset( entry, 0, class->object_size );
+
+     if (down_interruptible( &entries->lock )) {
+          kfree( entry );
+          return -EINTR;
+     }
+
+     entry->entries = entries;
+     entry->id      = entries->ids++;
+     entry->pid     = current->pid;
+
+     init_MUTEX( &entry->lock );
+
+     init_waitqueue_head( &entry->wait );
+
+     if (class->Init) {
+          ret = class->Init( entry, entries->ctx );
+          if (ret) {
+               kfree( entry );
+               return ret;
+          }
+     }
+
+     fusion_list_prepend( &entries->list, &entry->link );
+
+     up( &entries->lock );
+
+     *ret_id = entry->id;
+
+     return 0;
+}
+
+int
+fusion_entry_destroy( FusionEntries  *entries,
+                      int             id )
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Remove the entry from the list. */
+     fusion_list_remove( &entries->list, &entry->link );
+
+     /* Wake up any waiting process. */
+     wake_up_interruptible_all( &entry->wait );
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+
+     /* Call the destroy function. */
+     if (class->Destroy)
+          class->Destroy( entry, entries->ctx );
+
+     /* Deallocate the entry. */
+     kfree( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_set_info( FusionEntries         *entries,
+                       const FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( entry->name, FUSION_ENTRY_INFO_NAME_LENGTH, info->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_get_info( FusionEntries   *entries,
+                       FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( info->name, FUSION_ENTRY_INFO_NAME_LENGTH, entry->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_lock( FusionEntries  *entries,
+                   int             id,
+                   FusionEntry   **ret_entry )
+{
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( ret_entry != NULL );
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     FUSION_ASSUME( entry->lock_pid != current->pid );
+
+     /* Move the entry to the front of all entries. */
+     fusion_list_move_to_front( &entries->list, &entry->link );
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Mark as locked. */
+     entry->lock_pid = current->pid;
+
+     /* Keep timestamp, but use the slightly
+        inexact version to avoid performance impacts. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) && defined _STRUCT_TIMESPEC
+     entry->last_lock.tv_sec = xtime.tv_sec;
+     entry->last_lock.tv_usec = xtime.tv_nsec / 1000;
+#else
+     entry->last_lock = xtime;
+#endif
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+     /* Return the locked entry. */
+     *ret_entry = entry;
+
+     return 0;
+}
+
+void
+fusion_entry_unlock( FusionEntry *entry )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     entry->lock_pid = 0;
+
+     /* Unlock the entry. */
+     up( &entry->lock );
+}
+
+int
+fusion_entry_wait( FusionEntry *entry, long *timeout )
+{
+     int            ret;
+     int            id;
+     FusionEntries *entries;
+     FusionEntry   *entry2;
+
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->entries != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     id      = entry->id;
+     entries = entry->entries;
+
+     entry->waiters++;
+
+     fusion_sleep_on( &entry->wait, &entry->lock, timeout );
+
+     entry->waiters--;
+
+     if (timeout && !*timeout)
+          return -ETIMEDOUT;
+
+     if (signal_pending(current))
+          return -EINTR;
+
+     ret = fusion_entry_lock( entries, id, &entry2 );
+     switch (ret) {
+          case -EINVAL:
+               return -EIDRM;
+
+          case 0:
+               if (entry != entry2)
+                    BUG();
+     }
+
+     return ret;
+}
+
+void
+fusion_entry_notify( FusionEntry *entry, bool all )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     if (!entry->waiters)
+          return;
+
+     if (all)
+          wake_up_interruptible_all( &entry->wait );
+     else
+          wake_up_interruptible( &entry->wait );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/entries.h linux-2.6.12/drivers/char/_fusion_/entries.h
--- linux-2.6.12.orig/drivers/char/_fusion_/entries.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/entries.h	2004-12-12 15:09:40.000000000 +0100
@@ -0,0 +1,174 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__ENTRIES_H__
+#define __FUSION__ENTRIES_H__
+
+#include "types.h"
+#include "list.h"
+
+
+typedef struct __FD_FusionEntry FusionEntry;
+
+
+typedef const struct {
+     int object_size;
+
+     int  (*Init)   ( FusionEntry *entry, void *ctx );
+     void (*Destroy)( FusionEntry *entry, void *ctx );
+     int  (*Print)  ( FusionEntry *entry, void *ctx, char *buf );
+} FusionEntryClass;
+
+
+typedef struct {
+     FusionEntryClass  *class;
+     void              *ctx;
+
+     FusionLink        *list;
+     int                ids;
+     struct semaphore   lock;
+} FusionEntries;
+
+
+struct __FD_FusionEntry {
+     FusionLink         link;
+
+     FusionEntries     *entries;
+
+     int                id;
+     pid_t              pid;
+
+     pid_t              lock_pid;
+
+     struct semaphore   lock;
+     wait_queue_head_t  wait;
+     int                waiters;
+
+     struct timeval     last_lock;
+
+     char               name[FUSION_ENTRY_INFO_NAME_LENGTH];
+};
+
+
+/* Entries Init & DeInit */
+
+void fusion_entries_init  ( FusionEntries    *entries,
+                            FusionEntryClass *class,
+                            void             *ctx );
+
+void fusion_entries_deinit( FusionEntries    *entries );
+
+
+/* '/proc' support */
+
+int  fusion_entries_read_proc( char *buf, char **start, off_t offset,
+                               int len, int *eof, void *private );
+
+
+/* Create & Destroy */
+
+int  fusion_entry_create  ( FusionEntries    *entries,
+                            int              *ret_id );
+
+int  fusion_entry_destroy ( FusionEntries    *entries,
+                            int               id );
+
+
+/* Information */
+
+int  fusion_entry_set_info( FusionEntries          *entries,
+                            const FusionEntryInfo  *info );
+
+int  fusion_entry_get_info( FusionEntries          *entries,
+                            FusionEntryInfo        *info );
+
+
+/* Lock & Unlock */
+
+int  fusion_entry_lock    ( FusionEntries    *entries,
+                            int               id,
+                            FusionEntry     **ret_entry );
+
+void fusion_entry_unlock  ( FusionEntry      *entry );
+
+
+/** Wait & Notify **/
+
+/*
+ * Wait for the entry to be notified with an optional timeout.
+ *
+ * The entry
+ *   (1) has to be locked prior to calling this function.
+ *   (2) is temporarily unlocked while being waited for.
+ *
+ * If this function returns an error, the entry is not locked again!
+ *
+ * Possible errors are:
+ *   -EIDRM      Entry has been removed while being waited for.
+ *   -ETIMEDOUT  Timeout occured.
+ *   -EINTR      A signal has been received.
+ */
+int  fusion_entry_wait    ( FusionEntry      *entry,
+                            long             *timeout );
+
+/*
+ * Wake up one or all processes waiting for the entry to be notified.
+ *
+ * The entry has to be locked prior to calling this function.
+ */
+void fusion_entry_notify  ( FusionEntry      *entry,
+                            bool              all );
+
+
+#define FUSION_ENTRY_CLASS( Type, name, init_func, destroy_func, print_func )   \
+                                                                                \
+     static FusionEntryClass name##_class = {                                   \
+          .object_size = sizeof(Type),                                          \
+          .Init        = init_func,                                             \
+          .Destroy     = destroy_func,                                          \
+          .Print       = print_func                                             \
+     };                                                                         \
+                                                                                \
+     static inline int fusion_##name##_lock( FusionEntries  *entries,           \
+                                             int             id,                \
+                                             Type          **ret_##name )       \
+     {                                                                          \
+          int          ret;                                                     \
+          FusionEntry *entry;                                                   \
+                                                                                \
+          ret = fusion_entry_lock( entries, id, &entry );                       \
+                                                                                \
+          if (!ret)                                                             \
+               *ret_##name = (Type *) entry;                                    \
+                                                                                \
+          return ret;                                                           \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_unlock( Type *name )                    \
+     {                                                                          \
+          fusion_entry_unlock( (FusionEntry*) name );                           \
+     }                                                                          \
+                                                                                \
+     static inline int fusion_##name##_wait( Type *name, long *timeout )        \
+     {                                                                          \
+          return fusion_entry_wait( (FusionEntry*) name, timeout );             \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_notify( Type *name, bool all )          \
+     {                                                                          \
+          fusion_entry_notify( (FusionEntry*) name, all );                      \
+     }
+
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fifo.c linux-2.6.12/drivers/char/_fusion_/fifo.c
--- linux-2.6.12.orig/drivers/char/_fusion_/fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fifo.c	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "fifo.h"
+
+void
+fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
+{
+     link->prev = fifo->last;
+     link->next = NULL;
+
+     if (fifo->last)
+          fifo->last->next = link;
+     else
+          fifo->first = link;
+
+     fifo->last = link;
+
+     fifo->count++;
+}
+
+FusionLink *
+fusion_fifo_get (FusionFifo *fifo)
+{
+     FusionLink *first = fifo->first;
+
+     if (!first)
+          return NULL;
+
+     fifo->first = first->next;
+
+     if (fifo->last == first)
+          fifo->last = NULL;
+     else
+          fifo->first->prev = NULL;
+
+     fifo->count--;
+
+     return first;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fifo.h linux-2.6.12/drivers/char/_fusion_/fifo.h
--- linux-2.6.12.orig/drivers/char/_fusion_/fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fifo.h	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__FIFO_H__
+#define __FUSION__FIFO_H__
+
+#include "types.h"
+#include "list.h"
+
+typedef struct {
+     FusionLink *first;
+     FusionLink *last;
+
+     int         count;
+} FusionFifo;
+
+void        fusion_fifo_put   (FusionFifo *fifo,
+                               FusionLink *link);
+
+FusionLink *fusion_fifo_get   (FusionFifo *fifo);
+
+int         fusion_fifo_count (FusionFifo *fifo);
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.c linux-2.6.12/drivers/char/_fusion_/fusiondev.c
--- linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusiondev.c	2004-11-26 12:16:28.000000000 +0100
@@ -0,0 +1,956 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+#include <linux/device.h>
+#endif
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+#ifndef FUSION_MAJOR
+#define FUSION_MAJOR 252
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Denis Oliver Kropp <dok@directfb.org>");
+
+struct proc_dir_entry *proc_fusion_dir;
+
+#define NUM_MINORS 8
+
+static FusionDev  *fusion_devs[NUM_MINORS] = { 0 };
+static DECLARE_MUTEX(devs_lock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static devfs_handle_t devfs_handles[NUM_MINORS];
+static inline unsigned iminor(struct inode *inode)
+{
+        return MINOR(inode->i_rdev);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+static struct class_simple *fusion_class;
+#endif
+
+/******************************************************************************/
+
+void
+fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeout)
+{
+     wait_queue_t wait;
+
+     init_waitqueue_entry (&wait, current);
+
+     current->state = TASK_INTERRUPTIBLE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+     spin_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     spin_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+#else
+     write_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     write_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+#endif
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_stat_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionDev *dev     = private;
+     int        written = 0;
+
+     written += snprintf( buf, len,
+                          "lease/purchase   cede      attach     detach      "
+                          "ref up   ref down  prevail/swoop dismiss\n" );
+     if (written < offset) {
+          offset -= written;
+          written = 0;
+     }
+
+     if (written < len) {
+          written += snprintf( buf+written, len - written,
+                               "%10d %10d  %10d %10d  %10d %10d  %10d %10d\n",
+                               dev->stat.property_lease_purchase,
+                               dev->stat.property_cede,
+                               dev->stat.reactor_attach,
+                               dev->stat.reactor_detach,
+                               dev->stat.ref_up,
+                               dev->stat.ref_down,
+                               dev->stat.skirmish_prevail_swoop,
+                               dev->stat.skirmish_dismiss );
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+     }
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_init (FusionDev *dev)
+{
+     int ret;
+
+     ret = fusionee_init (dev);
+     if (ret)
+          goto error_fusionee;
+
+     ret = fusion_ref_init (dev);
+     if (ret)
+          goto error_ref;
+
+     ret = fusion_skirmish_init (dev);
+     if (ret)
+          goto error_skirmish;
+
+     ret = fusion_property_init (dev);
+     if (ret)
+          goto error_property;
+
+     ret = fusion_reactor_init (dev);
+     if (ret)
+          goto error_reactor;
+
+     ret = fusion_call_init (dev);
+     if (ret)
+          goto error_call;
+
+     create_proc_read_entry("stat", 0, dev->proc_dir,
+                            fusiondev_stat_read_proc, dev);
+
+     return 0;
+
+
+error_call:
+     fusion_reactor_deinit (dev);
+
+error_reactor:
+     fusion_property_deinit (dev);
+
+error_property:
+     fusion_skirmish_deinit (dev);
+
+error_skirmish:
+     fusion_ref_deinit (dev);
+
+error_ref:
+     fusionee_deinit (dev);
+
+error_fusionee:
+     return ret;
+}
+
+static void
+fusiondev_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("stat", dev->proc_dir);
+
+     fusion_call_deinit (dev);
+     fusion_reactor_deinit (dev);
+     fusion_property_deinit (dev);
+     fusion_skirmish_deinit (dev);
+     fusion_ref_deinit (dev);
+     fusionee_deinit (dev);
+}
+
+/******************************************************************************/
+
+static int
+fusion_open (struct inode *inode, struct file *file)
+{
+     int ret;
+     int fusion_id;
+     int minor = iminor(inode);
+
+     DEBUG( "fusion_open\n" );
+
+     if (down_interruptible (&devs_lock))
+          return -EINTR;
+
+     if (!fusion_devs[minor]) {
+          char buf[4];
+
+          fusion_devs[minor] = kmalloc (sizeof(FusionDev), GFP_KERNEL);
+          if (!fusion_devs[minor]) {
+               up (&devs_lock);
+               return -ENOMEM;
+          }
+
+          memset (fusion_devs[minor], 0, sizeof(FusionDev));
+
+          snprintf (buf, 4, "%d", minor);
+
+          fusion_devs[minor]->proc_dir = proc_mkdir (buf, proc_fusion_dir);
+
+          ret = fusiondev_init (fusion_devs[minor]);
+          if (ret) {
+               remove_proc_entry (buf, proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+
+               up (&devs_lock);
+
+               return ret;
+          }
+     }
+     else if (file->f_flags & O_EXCL) {
+          up (&devs_lock);
+          return -EBUSY;
+     }
+
+     ret = fusionee_new (fusion_devs[minor], &fusion_id);
+     if (ret) {
+          if (!fusion_devs[minor]->refs) {
+               fusiondev_deinit (fusion_devs[minor]);
+
+               remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                                  proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+          }
+
+          up (&devs_lock);
+
+          return ret;
+     }
+
+     fusion_devs[minor]->refs++;
+
+     up (&devs_lock);
+
+
+     file->private_data = (void*) fusion_id;
+
+     return 0;
+}
+
+static int
+fusion_release (struct inode *inode, struct file *file)
+{
+     int ret;
+     int minor     = iminor(inode);
+     int fusion_id = (int) file->private_data;
+
+     DEBUG( "fusion_release\n" );
+
+     ret = fusionee_destroy (fusion_devs[minor], fusion_id);
+     if (ret)
+          return ret;
+
+     down (&devs_lock);
+
+     if (! --fusion_devs[minor]->refs) {
+          fusiondev_deinit (fusion_devs[minor]);
+
+          remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                             proc_fusion_dir);
+
+          kfree (fusion_devs[minor]);
+          fusion_devs[minor] = NULL;
+     }
+
+     up (&devs_lock);
+
+     return 0;
+}
+
+static int
+fusion_flush (struct file *file)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     (void) fusion_id;
+
+     DEBUG( "fusion_flush (0x%08x %d)\n", fusion_id, current->pid );
+
+     if (current->flags & PF_EXITING)
+          fusion_skirmish_dismiss_all_from_pid (dev, current->pid);
+
+     return 0;
+}
+
+static ssize_t
+fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_read (%d)\n", count );
+
+     return fusionee_get_messages (dev, fusion_id, buf, count,
+                                   !(file->f_flags & O_NONBLOCK));
+}
+
+static unsigned int
+fusion_poll (struct file *file, poll_table * wait)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_poll\n" );
+
+     return fusionee_poll (dev, fusion_id, file, wait);
+}
+
+static int
+lounge_ioctl (FusionDev *dev, int fusion_id,
+              unsigned int cmd, unsigned long arg)
+{
+     int             ret;
+     FusionEnter     enter;
+     FusionKill      kill;
+     FusionEntryInfo info;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_ENTER):
+               if (copy_from_user (&enter, (FusionEnter*) arg, sizeof(enter)))
+                    return -EFAULT;
+
+               if (enter.api.major != FUSION_API_MAJOR || enter.api.minor > FUSION_API_MINOR)
+                    return -ENOPROTOOPT;
+
+               enter.fusion_id = fusion_id;
+
+               if (copy_to_user ((FusionEnter*) arg, &enter, sizeof(enter)))
+                    return -EFAULT;
+
+               return 0;
+
+          case _IOC_NR(FUSION_KILL):
+               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+                    return -EFAULT;
+
+               return fusionee_kill (dev, fusion_id,
+                                     kill.fusion_id, kill.signal, kill.timeout_ms);
+
+          case _IOC_NR(FUSION_ENTRY_SET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         return fusion_entry_set_info (&dev->skirmish, &info);
+
+                    case FT_PROPERTY:
+                         return fusion_entry_set_info (&dev->properties, &info);
+
+                    case FT_REACTOR:
+                         return fusion_entry_set_info (&dev->reactor, &info);
+
+                    default:
+                         return -ENOSYS;
+               }
+
+          case _IOC_NR(FUSION_ENTRY_GET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         ret = fusion_entry_get_info (&dev->skirmish, &info);
+                         break;
+
+                    case FT_PROPERTY:
+                         ret = fusion_entry_get_info (&dev->properties, &info);
+                         break;
+
+                    case FT_REACTOR:
+                         ret = fusion_entry_get_info (&dev->reactor, &info);
+                         break;
+
+                    default:
+                         return -ENOSYS;
+               }
+
+               if (ret)
+                    return ret;
+
+               if (copy_to_user ((FusionEntryInfo*) arg, &info, sizeof(info)))
+                    return -EFAULT;
+
+               return 0;
+     }
+
+     return -ENOSYS;
+}
+
+static int
+messaging_ioctl (FusionDev *dev, int fusion_id,
+                 unsigned int cmd, unsigned long arg)
+{
+     FusionSendMessage send;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SEND_MESSAGE):
+               if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
+                    return -EFAULT;
+
+               if (send.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (send.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusionee_send_message (dev, fusion_id, send.fusion_id, FMT_SEND,
+                                             send.msg_id, send.msg_size, send.msg_data);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+call_ioctl (FusionDev *dev, int fusion_id,
+            unsigned int cmd, unsigned long arg)
+{
+     int               id;
+     int               ret;
+     FusionCallNew     call;
+     FusionCallExecute execute;
+     FusionCallReturn  call_ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_CALL_NEW):
+               if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+                    return -EFAULT;
+
+               ret = fusion_call_new (dev, fusion_id, &call);
+               if (ret)
+                    return ret;
+
+               if (put_user (call.call_id, (int*) arg)) {
+                    fusion_call_destroy (dev, fusion_id, call.call_id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_EXECUTE):
+               if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+                    return -EFAULT;
+
+               ret = fusion_call_execute (dev, fusion_id, &execute);
+               if (ret)
+                    return ret;
+
+               if (put_user (execute.ret_val, (int*) arg))
+                    return -EFAULT;
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_RETURN):
+               if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+                    return -EFAULT;
+
+               return fusion_call_return (dev, fusion_id, &call_ret);
+
+          case _IOC_NR(FUSION_CALL_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_call_destroy (dev, fusion_id, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+ref_ioctl (FusionDev *dev, int fusion_id,
+           unsigned int cmd, unsigned long arg)
+{
+     int              id;
+     int              ret;
+     int              refs;
+     FusionRefWatch   watch;
+     FusionRefInherit inherit;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REF_NEW):
+               ret = fusion_ref_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_ref_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REF_UP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UP_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_DOWN):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_DOWN_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_ZERO_LOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_lock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_ZERO_TRYLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_trylock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UNLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_unlock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_STAT):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               ret = fusion_ref_stat (dev, id, &refs);
+               if (ret)
+                    return ret;
+
+               return refs;
+
+          case _IOC_NR(FUSION_REF_WATCH):
+               if (copy_from_user (&watch, (FusionRefWatch*) arg, sizeof(watch)))
+                    return -EFAULT;
+
+               return fusion_ref_watch (dev, watch.id, watch.call_id, watch.call_arg);
+
+          case _IOC_NR(FUSION_REF_INHERIT):
+               if (copy_from_user (&inherit, (FusionRefInherit*) arg, sizeof(inherit)))
+                    return -EFAULT;
+
+               return fusion_ref_inherit (dev, inherit.id, inherit.from);
+
+          case _IOC_NR(FUSION_REF_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+skirmish_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SKIRMISH_NEW):
+               ret = fusion_skirmish_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_skirmish_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_SKIRMISH_PREVAIL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_prevail (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_SWOOP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_swoop (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DISMISS):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_dismiss (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+property_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_PROPERTY_NEW):
+               ret = fusion_property_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_property_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_PROPERTY_LEASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_lease (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_PURCHASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_purchase (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_CEDE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_cede (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_HOLDUP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_holdup (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+reactor_ioctl (FusionDev *dev, int fusion_id,
+               unsigned int cmd, unsigned long arg)
+{
+     int                   id;
+     int                   ret;
+     FusionReactorDispatch dispatch;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REACTOR_NEW):
+               ret = fusion_reactor_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_reactor_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REACTOR_ATTACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_attach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DETACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_detach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DISPATCH):
+               if (copy_from_user (&dispatch,
+                                   (FusionReactorDispatch*) arg, sizeof(dispatch)))
+                    return -EFAULT;
+
+               if (dispatch.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (dispatch.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusion_reactor_dispatch (dev, dispatch.reactor_id,
+                                               dispatch.self ? 0 : fusion_id,
+                                               dispatch.msg_size, dispatch.msg_data);
+
+          case _IOC_NR(FUSION_REACTOR_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+     int        id  = (int) file->private_data;
+     FusionDev *dev = fusion_devs[iminor(inode)];
+
+     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+
+     switch (_IOC_TYPE(cmd)) {
+          case FT_LOUNGE:
+               return lounge_ioctl( dev, id, cmd, arg );
+
+          case FT_MESSAGING:
+               return messaging_ioctl( dev, id, cmd, arg );
+
+          case FT_CALL:
+               return call_ioctl( dev, id, cmd, arg );
+
+          case FT_REF:
+               return ref_ioctl( dev, id, cmd, arg );
+
+          case FT_SKIRMISH:
+               return skirmish_ioctl( dev, id, cmd, arg );
+
+          case FT_PROPERTY:
+               return property_ioctl( dev, id, cmd, arg );
+
+          case FT_REACTOR:
+               return reactor_ioctl( dev, id, cmd, arg );
+     }
+
+     return -ENOSYS;
+}
+
+static struct file_operations fusion_fops = {
+     .owner   = THIS_MODULE,
+     .open    = fusion_open,
+     .flush   = fusion_flush,
+     .release = fusion_release,
+     .read    = fusion_read,
+     .poll    = fusion_poll,
+     .ioctl   = fusion_ioctl
+};
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int __init
+register_devices(void)
+{
+     int  i;
+
+     if (register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     fusion_class = class_simple_create (THIS_MODULE, "fusion");
+     if (IS_ERR(fusion_class)) {
+          unregister_chrdev (FUSION_MAJOR, "fusion");
+          return PTR_ERR(fusion_class);
+     }
+#endif
+
+     devfs_mk_dir("fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_add (fusion_class,
+                                   MKDEV(FUSION_MAJOR, i),
+                                   NULL, "fusion%d", i);
+#endif
+
+          devfs_mk_cdev (MKDEV(FUSION_MAJOR, i),
+                         S_IFCHR | S_IRUSR | S_IWUSR,
+                         "fusion/%d", i);
+     }
+
+     return 0;
+}
+#else
+static int __init
+register_devices(void)
+{
+     int  i;
+     char buf[16];
+
+     if (devfs_register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+     for (i=0; i<NUM_MINORS; i++) {
+          snprintf (buf, 16, "fusion/%d", i);
+
+          devfs_handles[i] = devfs_register (NULL, buf, DEVFS_FL_DEFAULT,
+                                             FUSION_MAJOR, i,
+                                             S_IFCHR | S_IRUSR | S_IWUSR,
+                                             &fusion_fops, NULL);
+     }
+
+     return 0;
+}
+#endif
+
+int __init
+fusion_init(void)
+{
+     int ret;
+
+     ret = register_devices();
+     if (ret)
+          return ret;
+
+     proc_fusion_dir = proc_mkdir ("fusion", NULL);
+
+     return 0;
+}
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_remove (MKDEV(FUSION_MAJOR, i));
+#endif
+
+          devfs_remove ("fusion/%d", i);
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     class_simple_destroy (fusion_class);
+#endif
+
+     devfs_remove ("fusion");
+}
+#else
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     devfs_unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++)
+          devfs_unregister (devfs_handles[i]);
+}
+#endif
+
+void __exit
+fusion_exit(void)
+{
+     deregister_devices();
+
+     remove_proc_entry ("fusion", NULL);
+}
+
+module_init(fusion_init);
+module_exit(fusion_exit);
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.h linux-2.6.12/drivers/char/_fusion_/fusiondev.h
--- linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusiondev.h	2004-11-16 21:22:38.000000000 +0100
@@ -0,0 +1,79 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSIONDEV_H__
+#define __FUSIONDEV_H__
+
+#include <linux/proc_fs.h>
+
+#include "entries.h"
+#include "list.h"
+
+#define FUSION_ASSERT(exp)    if (!(exp)) BUG()
+#define FUSION_ASSUME(exp)    if (!(exp)) printk( KERN_ERR "fusiondev: assumption '" #exp "' failed!\n" )
+
+typedef struct {
+     int refs;
+
+     struct proc_dir_entry *proc_dir;
+
+     struct {
+          int property_lease_purchase;
+          int property_cede;
+
+          int reactor_attach;
+          int reactor_detach;
+
+          int ref_up;
+          int ref_down;
+
+          int skirmish_prevail_swoop;
+          int skirmish_dismiss;
+     } stat;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } call;
+
+     struct {
+          int                last_id;
+          FusionLink        *list;
+          struct semaphore   lock;
+          wait_queue_head_t  wait;
+     } fusionee;
+
+     FusionEntries  properties;
+
+     FusionEntries  reactor;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } ref;
+
+     FusionEntries  skirmish;
+} FusionDev;
+
+/*
+ * Special version of interruptible_sleep_on() that unlocks the mutex
+ * after adding the entry to the queue (just before schedule).
+ */
+void fusion_sleep_on (wait_queue_head_t *q,
+                      struct semaphore  *lock,
+                      signed long       *timeout_ms);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusionee.c linux-2.6.12/drivers/char/_fusion_/fusionee.c
--- linux-2.6.12.orig/drivers/char/_fusion_/fusionee.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusionee.c	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,507 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fifo.h"
+#include "list.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+typedef struct {
+     FusionLink        link;
+
+     struct semaphore  lock;
+
+     int               id;
+     int               pid;
+
+     FusionFifo        messages;
+
+     int               rcv_total;  /* Total number of messages received. */
+     int               snd_total;  /* Total number of messages sent. */
+
+     wait_queue_head_t wait;
+} Fusionee;
+
+typedef struct {
+     FusionLink         link;
+
+     FusionMessageType  type;
+     int                id;
+     int                size;
+     void              *data;
+} Message;
+
+/******************************************************************************/
+
+static int  lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static int  lock_fusionee   (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static void unlock_fusionee (Fusionee *fusionee);
+
+/******************************************************************************/
+
+static int
+fusionees_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee*) l;
+
+          written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %7d received, %7d sent)\n",
+                             fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->fusionee.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusionee_init (FusionDev *dev)
+{
+     init_waitqueue_head (&dev->fusionee.wait);
+
+     init_MUTEX (&dev->fusionee.lock);
+
+     create_proc_read_entry("fusionees", 0, dev->proc_dir,
+                            fusionees_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusionee_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->fusionee.lock);
+
+     remove_proc_entry ("fusionees", dev->proc_dir);
+
+     l = dev->fusionee.list;
+     while (l) {
+          FusionLink *next     = l->next;
+          Fusionee   *fusionee = (Fusionee *) l;
+
+          while (fusionee->messages.count) {
+               Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+               kfree (message);
+          }
+
+          kfree (fusionee);
+
+          l = next;
+     }
+
+     up (&dev->fusionee.lock);
+}
+
+/******************************************************************************/
+
+int
+fusionee_new (FusionDev *dev, int *id)
+{
+     Fusionee *fusionee;
+
+     fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+     if (!fusionee)
+          return -ENOMEM;
+
+     memset (fusionee, 0, sizeof(Fusionee));
+
+     if (down_interruptible (&dev->fusionee.lock)) {
+          kfree (fusionee);
+          return -EINTR;
+     }
+
+     fusionee->id  = ++dev->fusionee.last_id;
+     fusionee->pid = current->pid;
+
+     init_MUTEX (&fusionee->lock);
+
+     init_waitqueue_head (&fusionee->wait);
+
+     fusion_list_prepend (&dev->fusionee.list, &fusionee->link);
+
+     up (&dev->fusionee.lock);
+
+     *id = fusionee->id;
+
+     return 0;
+}
+
+int
+fusionee_send_message (FusionDev *dev, int id, int recipient,
+                       FusionMessageType msg_type, int msg_id,
+                       int msg_size, const void *msg_data)
+{
+     int       ret;
+     Message  *message;
+     Fusionee *sender   = NULL;
+     Fusionee *fusionee;
+
+     DEBUG( "fusionee_send_message (%d -> %d, type %d, id %d, size %d)\n",
+            id, recipient, msg_type, msg_id, msg_size );
+
+     ret = lock_fusionee (dev, recipient, &fusionee);
+     if (ret)
+          return ret;
+
+     if (id) {
+          if (id == recipient) {
+               sender = fusionee;
+          }
+          else {
+               ret = lock_fusionee (dev, id, &sender);
+               if (ret) {
+                    unlock_fusionee (fusionee);
+                    return ret == -EINVAL ? -EIO : ret;
+               }
+          }
+     }
+
+     message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
+     if (!message) {
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -ENOMEM;
+     }
+
+     message->data = message + 1;
+
+     if (msg_type == FMT_CALL)
+          memcpy (message->data, msg_data, msg_size);
+     else if (copy_from_user (message->data, msg_data, msg_size)) {
+          kfree (message);
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -EFAULT;
+     }
+
+     message->type = msg_type;
+     message->id   = msg_id;
+     message->size = msg_size;
+
+     fusion_fifo_put (&fusionee->messages, &message->link);
+
+     fusionee->rcv_total++;
+     if (sender)
+          sender->snd_total++;
+
+     wake_up_interruptible_all (&fusionee->wait);
+
+     if (sender && sender != fusionee)
+          unlock_fusionee (sender);
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_get_messages (FusionDev *dev,
+                       int id, void *buf, int buf_size, bool block)
+{
+     int       ret;
+     int       written  = 0;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     while (!fusionee->messages.count) {
+          if (!block) {
+               unlock_fusionee (fusionee);
+               return -EAGAIN;
+          }
+
+          fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
+
+          if (signal_pending(current))
+               return -EINTR;
+
+          ret = lock_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+     }
+
+     while (fusionee->messages.count) {
+          FusionReadMessage  header;
+          Message           *message = (Message*) fusionee->messages.first;
+          int                bytes   = message->size + sizeof(header);
+
+          if (bytes > buf_size) {
+               if (!written) {
+                    unlock_fusionee (fusionee);
+                    return -EMSGSIZE;
+               }
+
+               break;
+          }
+
+          header.msg_type = message->type;
+          header.msg_id   = message->id;
+          header.msg_size = message->size;
+
+          if (copy_to_user (buf, &header, sizeof(header)) ||
+              copy_to_user (buf + sizeof(header), message->data, message->size)) {
+               unlock_fusionee (fusionee);
+               return -EFAULT;
+          }
+
+          written  += bytes;
+          buf      += bytes;
+          buf_size -= bytes;
+
+          fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     unlock_fusionee (fusionee);
+
+     return written;
+}
+
+unsigned int
+fusionee_poll (FusionDev *dev, int id, struct file *file, poll_table * wait)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     unlock_fusionee (fusionee);
+
+
+     poll_wait (file, &fusionee->wait, wait);
+
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (!fusionee)
+          return -EINVAL;
+
+     if (fusionee->messages.count) {
+          unlock_fusionee (fusionee);
+
+          return POLLIN | POLLRDNORM;
+     }
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_kill (FusionDev *dev, int id, int target, int signal, int timeout_ms)
+{
+     long timeout = -1;
+
+     while (true) {
+          int         ret;
+          FusionLink *l;
+          Fusionee   *fusionee;
+          int         killed   = 0;
+
+          ret = lookup_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+
+          fusion_list_foreach (l, dev->fusionee.list) {
+               Fusionee *f = (Fusionee*) l;
+
+               if (f->id != id && (!target || target == f->id)) {
+                    kill_proc (f->pid, signal, 0);
+                    killed++;
+               }
+          }
+
+          if (!killed || timeout_ms < 0)
+               break;
+
+          if (timeout_ms) {
+               switch (timeout) {
+                    case 0:  /* timed out */
+                         up (&dev->fusionee.lock);
+                         return -ETIMEDOUT;
+
+                    case -1: /* setup timeout */
+                         timeout = (timeout_ms * HZ + 500) / 1000;
+                         if (!timeout)
+                              timeout = 1;
+
+                         /* fall through */
+
+                    default:
+                         fusion_sleep_on (&dev->fusionee.wait,
+                                          &dev->fusionee.lock, &timeout);
+                         break;
+               }
+          }
+          else
+               fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
+
+          if (signal_pending(current))
+               return -EINTR;
+     }
+
+     up (&dev->fusionee.lock);
+
+     return 0;
+}
+
+int
+fusionee_destroy (FusionDev *dev, int id)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     down (&fusionee->lock);
+
+     fusion_list_remove (&dev->fusionee.list, &fusionee->link);
+
+     wake_up_interruptible_all (&dev->fusionee.wait);
+
+     up (&dev->fusionee.lock);
+
+
+     fusion_call_destroy_all (dev, id);
+     fusion_skirmish_dismiss_all (dev, id);
+     fusion_reactor_detach_all (dev, id);
+     fusion_property_cede_all (dev, id);
+     fusion_ref_clear_all_local (dev, id);
+
+     while (fusionee->messages.count) {
+          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     up (&fusionee->lock);
+
+     kfree (fusionee);
+
+     return ret;
+}
+
+/******************************************************************************/
+
+static int
+lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee *) l;
+
+          if (fusionee->id == id) {
+               *ret_fusionee = fusionee;
+               return 0;
+          }
+     }
+
+     up (&dev->fusionee.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (fusionee) {
+          fusion_list_move_to_front (&dev->fusionee.list, &fusionee->link);
+
+          if (down_interruptible (&fusionee->lock)) {
+               up (&dev->fusionee.lock);
+               return -EINTR;
+          }
+
+          up (&dev->fusionee.lock);
+     }
+
+     *ret_fusionee = fusionee;
+
+     return 0;
+}
+
+static void
+unlock_fusionee (Fusionee *fusionee)
+{
+     up (&fusionee->lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusionee.h linux-2.6.12/drivers/char/_fusion_/fusionee.h
--- linux-2.6.12.orig/drivers/char/_fusion_/fusionee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusionee.h	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSIONEE_H__
+#define __FUSIONEE_H__
+
+#include <linux/poll.h>
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusionee_init   (FusionDev *dev);
+void fusionee_deinit (FusionDev *dev);
+
+
+/* internal functions */
+
+int fusionee_new           (FusionDev         *dev,
+                            int               *id);
+
+int fusionee_send_message  (FusionDev         *dev,
+                            int                id,
+                            int                recipient,
+                            FusionMessageType  msg_type,
+                            int                msg_id,
+                            int                msg_size,
+                            const void        *msg_data);
+
+int fusionee_get_messages  (FusionDev         *dev,
+                            int                id,
+                            void              *buf,
+                            int                buf_size,
+                            bool               block);
+
+unsigned
+int fusionee_poll          (FusionDev         *dev,
+                            int                id,
+                            struct file       *file,
+                            poll_table        *wait);
+
+int fusionee_kill          (FusionDev         *dev,
+                            int                id,
+                            int                target,
+                            int                signal,
+                            int                timeout_ms);
+
+int fusionee_destroy       (FusionDev         *dev,
+                            int                id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/list.c linux-2.6.12/drivers/char/_fusion_/list.c
--- linux-2.6.12.orig/drivers/char/_fusion_/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/list.c	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "list.h"
+
+void
+fusion_list_prepend (FusionLink **list, FusionLink *link)
+{
+     link->prev = NULL;
+     link->next = *list;
+
+     if (*list)
+          (*list)->prev = link;
+
+     *list = link;
+}
+
+void
+fusion_list_remove (FusionLink **list, FusionLink *link)
+{
+     if (link->prev)
+          link->prev->next = link->next;
+     else
+          *list = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->next = link->prev = NULL;
+}
+
+void
+fusion_list_move_to_front (FusionLink **list, FusionLink *link)
+{
+     if (*list == link)
+          return;
+
+     link->prev->next = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->prev = NULL;
+     link->next = *list;
+
+     (*list)->prev = link;
+
+     *list = link;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/list.h linux-2.6.12/drivers/char/_fusion_/list.h
--- linux-2.6.12.orig/drivers/char/_fusion_/list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/list.h	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__LIST_H__
+#define __FUSION__LIST_H__
+
+typedef struct _FusionLink {
+     struct _FusionLink *next;
+     struct _FusionLink *prev;
+} FusionLink;
+
+void fusion_list_prepend       (FusionLink **list, FusionLink *link);
+void fusion_list_remove        (FusionLink **list, FusionLink *link);
+void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
+
+
+#define fusion_list_foreach(elem, list)                     \
+     for (elem = (void*)(list);                             \
+          elem;                                             \
+          elem = (void*)(((FusionLink*)(elem))->next))
+
+#define fusion_list_foreach_safe(elem, temp, list)                                             \
+     for (elem = (void*)(list), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL); \
+          elem;                                                                                \
+          elem = (void*)(temp), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL))
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/property.c linux-2.6.12/drivers/char/_fusion_/property.c
--- linux-2.6.12.orig/drivers/char/_fusion_/property.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/property.c	2004-11-14 08:10:38.000000000 +0100
@@ -0,0 +1,337 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#ifndef yield
+#define yield schedule
+#endif
+
+#include <linux/fusion.h>
+
+#include "entries.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "property.h"
+
+typedef enum {
+     FUSION_PROPERTY_AVAILABLE = 0,
+     FUSION_PROPERTY_LEASED,
+     FUSION_PROPERTY_PURCHASED
+} FusionPropertyState;
+
+typedef struct {
+     FusionEntry         entry;
+
+     FusionPropertyState state;
+     int                 fusion_id; /* non-zero if leased/purchased */
+     unsigned long       purchase_stamp;
+     int                 lock_pid;
+     int                 count;    /* lock counter */
+} FusionProperty;
+
+static int
+fusion_property_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     FusionProperty *property = (FusionProperty*) entry;
+
+     if (property->state != FUSION_PROPERTY_AVAILABLE) {
+          return sprintf( buf, "%s by 0x%08x (%d) %dx\n",
+                          property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
+                          property->fusion_id, property->lock_pid, property->count );
+     }
+
+     return sprintf( buf, "\n" );
+}
+
+FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL, fusion_property_print )
+
+/******************************************************************************/
+
+int
+fusion_property_init( FusionDev *dev )
+{
+     fusion_entries_init( &dev->properties, &property_class, dev );
+
+     create_proc_read_entry( "properties", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->properties );
+
+     return 0;
+}
+
+void
+fusion_property_deinit( FusionDev *dev )
+{
+     remove_proc_entry( "properties", dev->proc_dir );
+
+     fusion_entries_deinit( &dev->properties );
+}
+
+/******************************************************************************/
+
+int
+fusion_property_new( FusionDev *dev, int *ret_id )
+{
+     return fusion_entry_create( &dev->properties, ret_id );
+}
+
+int
+fusion_property_lease( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     long            timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state     = FUSION_PROPERTY_LEASED;
+                    property->fusion_id = fusion_id;
+                    property->lock_pid  = current->pid;
+                    property->count     = 1;
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ / 10) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ / 10;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_purchase( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     signed long     timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state          = FUSION_PROPERTY_PURCHASED;
+                    property->fusion_id      = fusion_id;
+                    property->purchase_stamp = jiffies;
+                    property->lock_pid       = current->pid;
+                    property->count          = 1;
+
+                    fusion_property_notify( property, true );
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_cede( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     bool            purchased;
+
+     dev->stat.property_cede++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->lock_pid != current->pid) {
+          fusion_property_unlock( property );
+          return -EIO;
+     }
+
+     if (--property->count) {
+          fusion_property_unlock( property );
+          return 0;
+     }
+
+     purchased = (property->state == FUSION_PROPERTY_PURCHASED);
+
+     property->state     = FUSION_PROPERTY_AVAILABLE;
+     property->fusion_id = 0;
+     property->lock_pid  = 0;
+
+     fusion_property_notify( property, true );
+
+     fusion_property_unlock( property );
+
+     if (purchased)
+          yield();
+
+     return 0;
+}
+
+int
+fusion_property_holdup( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+
+     if (fusion_id > 1)
+          return -EPERM;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->state == FUSION_PROPERTY_PURCHASED) {
+          if (property->fusion_id == fusion_id) {
+               fusion_property_unlock( property );
+               return -EIO;
+          }
+
+          fusionee_kill( dev, fusion_id, property->fusion_id, SIGKILL, -1 );
+     }
+
+     fusion_property_unlock( property );
+
+     return 0;
+}
+
+int
+fusion_property_destroy( FusionDev *dev, int id )
+{
+     return fusion_entry_destroy( &dev->properties, id );
+}
+
+void
+fusion_property_cede_all( FusionDev *dev, int fusion_id )
+{
+     FusionLink *l;
+
+     down( &dev->properties.lock );
+
+     fusion_list_foreach (l, dev->properties.list) {
+          FusionProperty *property = (FusionProperty *) l;
+
+          down( &property->entry.lock );
+
+          if (property->fusion_id == fusion_id) {
+               property->state     = FUSION_PROPERTY_AVAILABLE;
+               property->fusion_id = 0;
+               property->lock_pid  = 0;
+
+               wake_up_interruptible_all (&property->entry.wait);
+          }
+
+          up( &property->entry.lock );
+     }
+
+     up( &dev->properties.lock );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/property.h linux-2.6.12/drivers/char/_fusion_/property.h
--- linux-2.6.12.orig/drivers/char/_fusion_/property.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/property.h	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__PROPERTY_H__
+#define __FUSION__PROPERTY_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_property_init   (FusionDev *dev);
+void fusion_property_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_property_new      (FusionDev *dev,
+                              int       *ret_id);
+
+int fusion_property_lease    (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_purchase (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_cede     (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_holdup   (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_destroy  (FusionDev *dev,
+                              int        id);
+
+
+/* internal functions */
+
+void fusion_property_cede_all (FusionDev *dev,
+                               int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/reactor.c linux-2.6.12/drivers/char/_fusion_/reactor.c
--- linux-2.6.12.orig/drivers/char/_fusion_/reactor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/reactor.c	2004-11-16 21:22:38.000000000 +0100
@@ -0,0 +1,274 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "reactor.h"
+
+typedef struct {
+     FusionLink         link;
+
+     int                fusion_id;
+
+     int                count;     /* number of attach calls */
+} ReactorNode;
+
+typedef struct {
+     FusionEntry        entry;
+
+     FusionLink        *nodes;
+
+     int                dispatch_count;
+} FusionReactor;
+
+/******************************************************************************/
+
+static ReactorNode *get_node      ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         remove_node   ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         free_all_nodes( FusionReactor *reactor );
+
+/******************************************************************************/
+
+static void
+fusion_reactor_destruct( FusionEntry *entry,
+                         void        *ctx )
+{
+     FusionReactor *reactor = (FusionReactor*) entry;
+
+     free_all_nodes( reactor );
+}
+
+static int
+fusion_reactor_print( FusionEntry *entry,
+                      void        *ctx,
+                      char        *buf )
+{
+     int            num     = 0;
+     FusionReactor *reactor = (FusionReactor*) entry;
+     FusionLink    *node    = reactor->nodes;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          num++;
+     }
+
+     return sprintf( buf, "%5dx dispatch, %d nodes\n", reactor->dispatch_count, num );
+}
+
+
+FUSION_ENTRY_CLASS( FusionReactor, reactor, NULL,
+                    fusion_reactor_destruct, fusion_reactor_print )
+
+/******************************************************************************/
+
+int
+fusion_reactor_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->reactor, &reactor_class, dev );
+
+     create_proc_read_entry( "reactors", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->reactor );
+
+     return 0;
+}
+
+void
+fusion_reactor_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("reactors", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->reactor );
+}
+
+/******************************************************************************/
+
+int
+fusion_reactor_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->reactor, ret_id );
+}
+
+int
+fusion_reactor_attach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_attach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
+          if (!node) {
+               fusion_reactor_unlock( reactor );
+               return -ENOMEM;
+          }
+
+          node->fusion_id = fusion_id;
+          node->count     = 1;
+
+          fusion_list_prepend (&reactor->nodes, &node->link);
+     }
+     else
+          node->count++;
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_detach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_detach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          fusion_reactor_unlock( reactor );
+          return -EIO;
+     }
+
+     if (! --node->count) {
+          fusion_list_remove (&reactor->nodes, &node->link);
+          kfree (node);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_dispatch (FusionDev *dev, int id, int fusion_id,
+                         int msg_size, const void *msg_data)
+{
+     int            ret;
+     FusionLink    *l;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     reactor->dispatch_count++;
+
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
+
+          if (node->fusion_id == fusion_id)
+               continue;
+
+          fusionee_send_message (dev, fusion_id, node->fusion_id, FMT_REACTOR,
+                                 reactor->entry.id, msg_size, msg_data);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->reactor, id );
+}
+
+void
+fusion_reactor_detach_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->reactor.lock);
+
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor *) l;
+
+          remove_node (reactor, fusion_id);
+     }
+
+     up (&dev->reactor.lock);
+}
+
+/******************************************************************************/
+
+static ReactorNode *
+get_node (FusionReactor *reactor,
+          int            fusion_id)
+{
+     ReactorNode *node;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id)
+               return node;
+     }
+
+     return NULL;
+}
+
+static void
+remove_node (FusionReactor *reactor, int fusion_id)
+{
+     ReactorNode *node;
+
+     down (&reactor->entry.lock);
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id) {
+               fusion_list_remove (&reactor->nodes, &node->link);
+               break;
+          }
+     }
+
+     up (&reactor->entry.lock);
+}
+
+static void
+free_all_nodes (FusionReactor *reactor)
+
+{
+     FusionLink  *n;
+     ReactorNode *node;
+
+     fusion_list_foreach_safe (node, n, reactor->nodes) {
+          kfree (node);
+     }
+
+     reactor->nodes = NULL;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/reactor.h linux-2.6.12/drivers/char/_fusion_/reactor.h
--- linux-2.6.12.orig/drivers/char/_fusion_/reactor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/reactor.h	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__REACTOR_H__
+#define __FUSION__REACTOR_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_reactor_init   (FusionDev *dev);
+void fusion_reactor_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_reactor_new      (FusionDev  *dev,
+                             int        *id);
+
+int fusion_reactor_attach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_detach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_dispatch (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id,
+                             int         msg_size,
+                             const void *msg_data);
+
+int fusion_reactor_destroy  (FusionDev  *dev,
+                             int         id);
+
+
+/* internal functions */
+
+void fusion_reactor_detach_all (FusionDev *dev,
+                                int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/ref.c linux-2.6.12/drivers/char/_fusion_/ref.c
--- linux-2.6.12.orig/drivers/char/_fusion_/ref.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/ref.c	2004-11-07 14:20:54.000000000 +0100
@@ -0,0 +1,777 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "list.h"
+#include "call.h"
+#include "ref.h"
+
+typedef struct __Fusion_FusionRef FusionRef;
+
+typedef struct {
+     FusionLink  link;
+     int         fusion_id;
+     int         refs;
+} LocalRef;
+
+typedef struct {
+     FusionLink  link;
+     FusionRef  *ref;
+} Inheritor;
+
+struct __Fusion_FusionRef {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;
+     int                pid;
+
+     int                global;
+     int                local;
+
+     int                locked;    /* non-zero fusion id of lock owner */
+
+     bool               watched;   /* true if watch has been installed */
+     int                call_id;   /* id of call registered with a watch */
+     int                call_arg;  /* optional call parameter */
+
+     FusionRef         *inherited;
+     FusionLink        *inheritors;
+
+     FusionLink        *local_refs;
+
+     wait_queue_head_t  wait;
+};
+
+/******************************************************************************/
+
+static int  lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static int  lock_ref   (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static void unlock_ref (FusionRef *ref);
+
+static int  add_local       (FusionRef *ref, int fusion_id, int add);
+static void clear_local     (FusionDev *dev, FusionRef *ref, int fusion_id);
+static void free_all_local  (FusionRef *ref);
+
+static int  propagate_local (FusionDev *dev, FusionRef *ref, int diff);
+
+static void notify_ref      (FusionDev *dev, FusionRef *ref);
+
+static int  add_inheritor   (FusionRef *ref, FusionRef *from);
+static void remove_inheritor(FusionRef *ref, FusionRef *from);
+static void drop_inheritors (FusionDev *dev, FusionRef *ref);
+
+/******************************************************************************/
+
+static int
+refs_read_proc(char *buf, char **start, off_t offset,
+               int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef*) l;
+
+          if (ref->locked)
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d (locked by %d)\n",
+                                  ref->pid, ref->id, ref->global, ref->local,
+                                  ref->locked);
+          else
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d\n",
+                                  ref->pid, ref->id, ref->global, ref->local);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->ref.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_ref_init (FusionDev *dev)
+{
+     init_MUTEX (&dev->ref.lock);
+
+     create_proc_read_entry("refs", 0, dev->proc_dir,
+                            refs_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusion_ref_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     remove_proc_entry ("refs", dev->proc_dir);
+
+     l = dev->ref.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionRef  *ref  = (FusionRef *) l;
+
+          free_all_local (ref);
+
+          kfree (ref);
+
+          l = next;
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_ref_new (FusionDev *dev, int *id)
+{
+     FusionRef *ref;
+
+     ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+     if (!ref)
+          return -ENOMEM;
+
+     memset (ref, 0, sizeof(FusionRef));
+
+     if (down_interruptible (&dev->ref.lock)) {
+          kfree (ref);
+          return -EINTR;
+     }
+
+     ref->id   = dev->ref.ids++;
+     ref->pid  = current->pid;
+
+     init_MUTEX (&ref->lock);
+
+     init_waitqueue_head (&ref->wait);
+
+     fusion_list_prepend (&dev->ref.list, &ref->link);
+
+     up (&dev->ref.lock);
+
+     *id = ref->id;
+
+     return 0;
+}
+
+int
+fusion_ref_up (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_up++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = add_local (ref, fusion_id, 1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, 1 );
+     }
+     else
+          ref->global++;
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_down (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_down++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = -EIO;
+          if (!ref->local)
+               goto out;
+
+          ret = add_local (ref, fusion_id, -1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, -1 );
+     }
+     else {
+          if (!ref->global) {
+               ret = -EIO;
+               goto out;
+          }
+
+          ref->global--;
+
+          if (ref->local + ref->global == 0)
+               notify_ref (dev, ref);
+     }
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     while (true) {
+          ret = lock_ref (dev, false, id, &ref);
+          if (ret)
+               return ret;
+
+          if (ref->watched) {
+               unlock_ref (ref);
+               return -EACCES;
+          }
+
+          if (ref->locked) {
+               unlock_ref (ref);
+               return ref->locked == fusion_id ? -EIO : -EAGAIN;
+          }
+
+          if (ref->global || ref->local) {
+               fusion_sleep_on (&ref->wait, &ref->lock, 0);
+
+               if (signal_pending(current))
+                    return -EINTR;
+          }
+          else
+               break;
+     }
+
+     ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_zero_trylock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked) {
+          unlock_ref (ref);
+          return ref->locked == fusion_id ? -EIO : -EAGAIN;
+     }
+
+     if (ref->global || ref->local)
+          ret = -ETOOMANYREFS;
+     else
+          ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_unlock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked != fusion_id) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     ref->locked = 0;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_stat (FusionDev *dev, int id, int *refs)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     *refs = ref->global + ref->local;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_watch (FusionDev      *dev,
+                  int             id,
+                  int             call_id,
+                  int             call_arg)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->pid != current->pid) {
+          unlock_ref (ref);
+          return -EACCES;
+     }
+
+     if (ref->global + ref->local == 0) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     if (ref->watched) {
+          unlock_ref (ref);
+          return -EBUSY;
+     }
+
+     ref->watched  = true;
+     ref->call_id  = call_id;
+     ref->call_arg = call_arg;
+
+     wake_up_interruptible_all (&ref->wait);
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_inherit (FusionDev *dev,
+                    int        id,
+                    int        from_id)
+{
+     int        ret;
+     FusionRef *ref;
+     FusionRef *from = NULL;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     ret = -EBUSY;
+     if (ref->inherited)
+          goto out;
+
+     ret = lock_ref (dev, true, from_id, &from);
+     if (ret)
+          goto out;
+
+     ret = add_inheritor( ref, from );
+     if (ret)
+          goto out;
+
+     ret = propagate_local( dev, ref, from->local );
+     if (ret)
+          goto out;
+
+     ref->inherited = from;
+
+out:
+     if (from)
+          unlock_ref (from);
+
+     unlock_ref (ref);
+
+     up (&dev->ref.lock);
+
+     return ret;
+}
+
+int
+fusion_ref_destroy (FusionDev *dev, int id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     drop_inheritors( dev, ref );
+
+     if (ref->inherited)
+          remove_inheritor( ref, ref->inherited );
+
+     fusion_list_remove (&dev->ref.list, &ref->link);
+
+     wake_up_interruptible_all (&ref->wait);
+
+     up (&dev->ref.lock);
+
+     free_all_local (ref);
+
+     up (&ref->lock);
+
+     kfree (ref);
+
+     return 0;
+}
+
+void
+fusion_ref_clear_all_local (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          clear_local (dev, ref, fusion_id);
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     FusionLink *l;
+
+     if (!locked && down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          if (ref->id == id) {
+               *ret_ref = ref;
+               return 0;
+          }
+     }
+
+     if (!locked)
+          up (&dev->ref.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     int         ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, locked, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref) {
+          fusion_list_move_to_front (&dev->ref.list, &ref->link);
+
+          if (down_interruptible (&ref->lock)) {
+               if (!locked)
+                    up (&dev->ref.lock);
+               return -EINTR;
+          }
+
+          if (!locked)
+               up (&dev->ref.lock);
+     }
+
+     *ret_ref = ref;
+
+     return 0;
+}
+
+static void
+unlock_ref (FusionRef *ref)
+{
+     up (&ref->lock);
+}
+
+static int
+add_local (FusionRef *ref, int fusion_id, int add)
+{
+     FusionLink *l;
+     LocalRef   *local;
+
+     fusion_list_foreach (l, ref->local_refs) {
+          local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               fusion_list_move_to_front( &ref->local_refs, l );
+
+               if (local->refs + add < 0)
+                    return -EIO;
+
+               local->refs += add;
+               return 0;
+          }
+     }
+
+     local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+     if (!local)
+          return -ENOMEM;
+
+     local->fusion_id = fusion_id;
+     local->refs      = add;
+
+     fusion_list_prepend (&ref->local_refs, &local->link);
+
+     return 0;
+}
+
+static void
+clear_local (FusionDev *dev, FusionRef *ref, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&ref->lock);
+
+     if (ref->locked == fusion_id) {
+          ref->locked = 0;
+          wake_up_interruptible_all (&ref->wait);
+     }
+
+     fusion_list_foreach (l, ref->local_refs) {
+          LocalRef *local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               if (local->refs)
+                    propagate_local( dev, ref, - local->refs );
+
+               fusion_list_remove( &ref->local_refs, l );
+
+               kfree (l);
+               break;
+          }
+     }
+
+     up (&ref->lock);
+}
+
+static void
+free_all_local (FusionRef *ref)
+{
+     FusionLink *l = ref->local_refs;
+
+     while (l) {
+          FusionLink *next = l->next;
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->local_refs = NULL;
+}
+
+static void
+notify_ref (FusionDev *dev, FusionRef *ref)
+{
+     if (ref->watched) {
+          FusionCallExecute execute;
+
+          execute.call_id  = ref->call_id;
+          execute.call_arg = ref->call_arg;
+          execute.call_ptr = NULL;
+
+          fusion_call_execute (dev, 0, &execute);
+     }
+     else
+          wake_up_interruptible_all (&ref->wait);
+}
+
+static int
+propagate_local( FusionDev *dev, FusionRef *ref, int diff )
+{
+     FusionLink *l;
+
+     /* Recurse into inheritors. */
+     fusion_list_foreach (l, ref->inheritors) {
+          FusionRef *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: propagate_local() interrupted!\n" );
+               //return -EINTR;
+          }
+
+          propagate_local( dev, inheritor, diff );
+
+          up( &inheritor->lock );
+     }
+
+     /* Apply difference. */
+     ref->local += diff;
+
+     /* Notify zero count. */
+     if (ref->local + ref->global == 0)
+          notify_ref( dev, ref );
+
+     return 0;
+}
+
+static int
+add_inheritor(FusionRef *ref, FusionRef *from)
+{
+     Inheritor *inheritor;
+
+     inheritor = kmalloc (sizeof(Inheritor), GFP_KERNEL);
+     if (!inheritor)
+          return -ENOMEM;
+
+     inheritor->ref = ref;
+
+     fusion_list_prepend( &from->inheritors, &inheritor->link );
+
+     return 0;
+}
+
+static void
+remove_inheritor(FusionRef *ref, FusionRef *from)
+{
+     FusionLink *l;
+
+     down( &from->lock );
+
+     fusion_list_foreach (l, from->inheritors) {
+          Inheritor *inheritor = (Inheritor*) l;
+
+          if (inheritor->ref == ref) {
+               fusion_list_remove( &from->inheritors, &inheritor->link );
+
+               kfree( l );
+               break;
+          }
+     }
+
+     up( &from->lock );
+}
+
+static void
+drop_inheritors( FusionDev *dev, FusionRef *ref )
+{
+     FusionLink *l = ref->inheritors;
+
+     while (l) {
+          FusionLink *next      = l->next;
+          FusionRef  *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: drop_inheritors() interrupted!\n" );
+               //return;
+          }
+
+          propagate_local( dev, inheritor, - ref->local );
+
+          inheritor->inherited = NULL;
+
+          up( &inheritor->lock );
+
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->inheritors = NULL;
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/ref.h linux-2.6.12/drivers/char/_fusion_/ref.h
--- linux-2.6.12.orig/drivers/char/_fusion_/ref.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/ref.h	2004-11-07 11:15:12.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__REF_H__
+#define __FUSION__REF_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_ref_init   (FusionDev *dev);
+void fusion_ref_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_ref_new          (FusionDev      *dev,
+                             int            *id);
+
+int fusion_ref_up           (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_down         (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_lock    (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_trylock (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_unlock       (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_stat         (FusionDev      *dev,
+                             int             id,
+                             int            *refs);
+
+int fusion_ref_watch        (FusionDev      *dev,
+                             int             id,
+                             int             call_id,
+                             int             call_arg);
+
+int fusion_ref_inherit      (FusionDev      *dev,
+                             int             id,
+                             int             from);
+
+int fusion_ref_destroy      (FusionDev      *dev,
+                             int             id);
+
+
+/* internal functions */
+
+void fusion_ref_clear_all_local (FusionDev *dev,
+                                 int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/skirmish.c linux-2.6.12/drivers/char/_fusion_/skirmish.c
--- linux-2.6.12.orig/drivers/char/_fusion_/skirmish.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/skirmish.c	2004-11-16 21:22:38.000000000 +0100
@@ -0,0 +1,246 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "skirmish.h"
+
+
+typedef struct {
+     FusionEntry        entry;
+
+     int                lock_fid;  /* non-zero if locked */
+     int                lock_pid;
+     int                lock_count;
+
+     int                lock_total;
+} FusionSkirmish;
+
+static int
+fusion_skirmish_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     int             written;
+     FusionSkirmish *skirmish = (FusionSkirmish*) entry;
+
+     written = sprintf( buf, "%6dx total", skirmish->lock_total );
+
+     if (skirmish->lock_fid)
+          return sprintf( buf + written, ", now %dx by 0x%08x (%d)\n",
+                          skirmish->lock_count, skirmish->lock_fid, skirmish->lock_pid) + written;
+
+     return sprintf( buf + written, "\n" ) + written;
+}
+
+FUSION_ENTRY_CLASS( FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print )
+
+/******************************************************************************/
+
+int
+fusion_skirmish_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->skirmish, &skirmish_class, dev );
+
+     create_proc_read_entry( "skirmishs", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->skirmish );
+
+     return 0;
+}
+
+void
+fusion_skirmish_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("skirmishs", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->skirmish );
+}
+
+/******************************************************************************/
+
+int
+fusion_skirmish_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->skirmish, ret_id );
+}
+
+int
+fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     if (skirmish->lock_pid == current->pid) {
+          skirmish->lock_count++;
+          skirmish->lock_total++;
+          fusion_skirmish_unlock( skirmish );
+          return 0;
+     }
+
+     while (skirmish->lock_pid) {
+          ret = fusion_skirmish_wait( skirmish, NULL );
+          if (ret)
+               return ret;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     if (skirmish->lock_fid) {
+          if (skirmish->lock_pid == current->pid) {
+               skirmish->lock_count++;
+               skirmish->lock_total++;
+               fusion_skirmish_unlock( skirmish );
+               return 0;
+          }
+
+          fusion_skirmish_unlock( skirmish );
+
+          return -EAGAIN;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_dismiss++;
+
+     if (skirmish->lock_pid != current->pid) {
+          fusion_skirmish_unlock( skirmish );
+          return -EIO;
+     }
+
+     if (--skirmish->lock_count == 0) {
+          skirmish->lock_fid = 0;
+          skirmish->lock_pid = 0;
+
+          fusion_skirmish_notify( skirmish, true );
+     }
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->skirmish, id );
+}
+
+void
+fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_fid == fusion_id) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
+void
+fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_pid == pid) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/skirmish.h linux-2.6.12/drivers/char/_fusion_/skirmish.h
--- linux-2.6.12.orig/drivers/char/_fusion_/skirmish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/skirmish.h	2003-12-16 08:05:42.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__SKIRMISH_H__
+#define __FUSION__SKIRMISH_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_skirmish_init   (FusionDev *dev);
+void fusion_skirmish_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_skirmish_new     (FusionDev *dev,
+                             int       *id);
+
+int fusion_skirmish_prevail (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_swoop   (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_dismiss (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_destroy (FusionDev *dev,
+                             int        id);
+
+
+/* internal functions */
+
+void fusion_skirmish_dismiss_all (FusionDev *dev,
+                                  int        fusion_id);
+
+void fusion_skirmish_dismiss_all_from_pid (FusionDev *dev,
+                                           int        pid);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/types.h linux-2.6.12/drivers/char/_fusion_/types.h
--- linux-2.6.12.orig/drivers/char/_fusion_/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/types.h	2002-11-12 23:30:40.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__TYPES_H__
+#define __FUSION__TYPES_H__
+
+typedef enum {
+  false = 0,
+  true  = !false
+} bool;
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/Makefile linux-2.6.12/drivers/char/fusion/Makefile
--- linux-2.6.12.orig/drivers/char/fusion/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/Makefile	2005-06-26 00:30:38.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSION_DEVICE) += fusion.o
+
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/call.c linux-2.6.12/drivers/char/fusion/call.c
--- linux-2.6.12.orig/drivers/char/fusion/call.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/call.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,468 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "call.h"
+
+typedef struct {
+     FusionLink        link;
+
+     int               caller;
+
+     int               ret_val;
+
+     bool              executed;
+
+     wait_queue_head_t wait;
+} FusionCallExecution;
+
+typedef struct {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;        /* call id */
+
+     int                pid;       /* owner pid */
+     int                fusion_id; /* owner fusion id */
+
+     void              *handler;
+     void              *ctx;
+
+     FusionLink          *executions;      /* prepending! */
+     FusionLink          *last;            /* points to the last item of executions */
+
+     int                count;    /* number of calls ever made */
+} FusionCall;
+
+/******************************************************************************/
+
+static int  lookup_call (FusionDev *dev, int id, FusionCall **ret_call);
+static int  lock_call   (FusionDev *dev, int id, FusionCall **ret_call);
+static void unlock_call (FusionCall *call);
+
+static FusionCallExecution *add_execution       (FusionCall          *call,
+                                                 int                  fusion_id,
+                                                 FusionCallExecute   *execute);
+static void                 remove_execution    (FusionCall          *call,
+                                                 FusionCallExecution *execution);
+static void                 free_all_executions (FusionCall          *call);
+
+/******************************************************************************/
+
+static int
+fusion_call_read_proc (char *buf, char **start, off_t offset,
+                       int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          bool        idle = true;
+          FusionCall *call = (FusionCall*) l;
+
+          if (call->executions)
+               idle = ((FusionCallExecution*) call->executions)->executed;
+
+          written += sprintf(buf+written,
+                             "(%5d) 0x%08x (%d calls) %s\n",
+                             call->pid, call->id, call->count,
+                             idle ? "idle" : "executing");
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->call.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_call_init (FusionDev *dev)
+{
+     create_proc_read_entry("calls", 0, dev->proc_dir,
+                            fusion_call_read_proc, dev);
+
+     init_MUTEX(&dev->call.lock);
+
+     return 0;
+}
+
+void
+fusion_call_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     remove_proc_entry ("calls", dev->proc_dir);
+
+     l = dev->call.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          free_all_executions (call);
+
+          kfree (call);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
+{
+     FusionCall *call;
+
+     call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+     if (!call)
+          return -ENOMEM;
+
+     memset (call, 0, sizeof(FusionCall));
+
+     if (down_interruptible (&dev->call.lock)) {
+          kfree (call);
+          return -EINTR;
+     }
+
+     call->id        = dev->call.ids++;
+     call->pid       = current->pid;
+     call->fusion_id = fusion_id;
+     call->handler   = call_new->handler;
+     call->ctx       = call_new->ctx;
+
+     init_MUTEX (&call->lock);
+
+     fusion_list_prepend (&dev->call.list, &call->link);
+
+     up (&dev->call.lock);
+
+     call_new->call_id = call->id;
+
+     return 0;
+}
+
+int
+fusion_call_execute (FusionDev *dev, int fusion_id, FusionCallExecute *execute)
+{
+     int                  ret;
+     FusionCall          *call;
+     FusionCallExecution *execution;
+     FusionCallMessage    message;
+
+     ret = lock_call (dev, execute->call_id, &call);
+     if (ret)
+          return ret;
+
+     execution = add_execution (call, fusion_id, execute);
+     if (!execution) {
+          unlock_call (call);
+          return -ENOMEM;
+     }
+
+     /* Send call message. */
+     message.handler  = call->handler;
+     message.ctx      = call->ctx;
+
+     message.caller   = fusion_id;
+
+     message.call_arg = execute->call_arg;
+     message.call_ptr = execute->call_ptr;
+
+     ret = fusionee_send_message (dev, fusion_id, call->fusion_id, FMT_CALL,
+                                  call->id, sizeof(message), &message);
+     if (ret) {
+          remove_execution (call, execution);
+          kfree (execution);
+          unlock_call (call);
+          return ret;
+     }
+
+     call->count++;
+
+     if (fusion_id) {
+          /* TODO: implement timeout */
+          fusion_sleep_on (&execution->wait, &call->lock, 0);
+
+          ret = lock_call (dev, execute->call_id, &call);
+          if (ret)
+               return ret == -EINVAL ? -EIDRM : ret;
+
+          if (signal_pending(current)) {
+               execution->caller = 0;
+               unlock_call (call);
+               return -EINTR;
+          }
+
+          execute->ret_val = execution->ret_val;
+
+          remove_execution (call, execution);
+
+          kfree (execution);
+     }
+
+     unlock_call (call);
+
+     return 0;
+}
+
+int
+fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
+{
+     int         ret;
+     FusionLink *l;
+     FusionCall *call;
+
+     ret = lock_call (dev, call_ret->call_id, &call);
+     if (ret)
+          return ret;
+
+     l = call->last;
+     while (l) {
+          FusionCallExecution *execution = (FusionCallExecution*) l;
+
+          if (execution->executed) {
+               l = l->prev;
+               continue;
+          }
+
+          if (execution->caller) {
+               execution->ret_val  = call_ret->val;
+               execution->executed = true;
+
+               wake_up_interruptible_all (&execution->wait);
+          }
+          else {
+               remove_execution (call, execution);
+
+               kfree (execution);
+          }
+
+          unlock_call (call);
+
+          return 0;
+     }
+
+     unlock_call (call);
+
+     return -EIO;
+}
+
+int
+fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, call_id, &call);
+     if (ret)
+          return ret;
+
+     if (call->fusion_id != fusion_id) {
+          up (&dev->call.lock);
+          return -EIO;
+     }
+
+     if (down_interruptible (&call->lock)) {
+          up (&dev->call.lock);
+          return -EINTR;
+     }
+
+     fusion_list_remove (&dev->call.list, &call->link);
+
+     free_all_executions (call);
+
+     up (&dev->call.lock);
+
+     up (&call->lock);
+
+     kfree (call);
+
+     return 0;
+}
+
+void
+fusion_call_destroy_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     l = dev->call.list;
+
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          down (&call->lock);
+
+          if (call->fusion_id == fusion_id) {
+               free_all_executions (call);
+
+               fusion_list_remove (&dev->call.list, &call->link);
+
+               up (&call->lock);
+
+               kfree (call);
+          }
+          else
+               up (&call->lock);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          FusionCall *call = (FusionCall *) l;
+
+          if (call->id == id) {
+               *ret_call = call;
+               return 0;
+          }
+     }
+
+     up (&dev->call.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, id, &call);
+     if (ret)
+          return ret;
+
+     if (call) {
+          fusion_list_move_to_front (&dev->call.list, &call->link);
+
+          if (down_interruptible (&call->lock)) {
+               up (&dev->call.lock);
+               return -EINTR;
+          }
+
+          up (&dev->call.lock);
+     }
+
+     *ret_call = call;
+
+     return 0;
+}
+
+static void
+unlock_call (FusionCall *call)
+{
+     up (&call->lock);
+}
+
+static FusionCallExecution *
+add_execution (FusionCall        *call,
+               int                fusion_id,
+               FusionCallExecute *execute)
+{
+     FusionCallExecution *execution;
+
+     /* Allocate execution. */
+     execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+     if (!execution)
+          return NULL;
+
+     /* Initialize execution. */
+     memset (execution, 0, sizeof(FusionCallExecution));
+
+     execution->caller = fusion_id;
+
+     init_waitqueue_head (&execution->wait);
+
+     /* Add execution. */
+     fusion_list_prepend (&call->executions, &execution->link);
+
+     if (!call->last)
+          call->last = &execution->link;
+
+     return execution;
+}
+
+static void
+remove_execution (FusionCall          *call,
+                  FusionCallExecution *execution)
+{
+     if (call->last == &execution->link)
+          call->last = execution->link.prev;
+
+     fusion_list_remove (&call->executions, &execution->link);
+}
+
+static void
+free_all_executions (FusionCall *call)
+{
+     while (call->last) {
+          FusionCallExecution *execution = (FusionCallExecution *) call->last;
+
+          remove_execution (call, execution);
+
+          wake_up_interruptible_all (&execution->wait);
+
+          kfree (execution);
+     }
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/call.h linux-2.6.12/drivers/char/fusion/call.h
--- linux-2.6.12.orig/drivers/char/fusion/call.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/call.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__CALL_H__
+#define __FUSION__CALL_H__
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+
+/* module init/cleanup */
+
+int  fusion_call_init   (FusionDev *dev);
+void fusion_call_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_call_new     (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallNew     *call);
+
+int fusion_call_execute (FusionDev         *dev,
+                         int                fusion_id, /* zero if call is
+                                                          from Fusion */
+                         FusionCallExecute *execute);
+
+int fusion_call_return  (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallReturn  *call_ret);
+
+int fusion_call_destroy (FusionDev         *dev,
+                         int                fusion_id,
+                         int                call_id);
+
+
+/* internal functions */
+
+void fusion_call_destroy_all (FusionDev *dev,
+                              int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/entries.c linux-2.6.12/drivers/char/fusion/entries.c
--- linux-2.6.12.orig/drivers/char/fusion/entries.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/entries.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,417 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/version.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "entries.h"
+
+
+void
+fusion_entries_init( FusionEntries    *entries,
+                     FusionEntryClass *class,
+                     void             *ctx )
+{
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( class != NULL );
+     FUSION_ASSERT( class->object_size >= sizeof(FusionEntry) );
+
+     memset( entries, 0, sizeof(FusionEntries) );
+
+     entries->class = class;
+     entries->ctx   = ctx;
+
+     init_MUTEX( &entries->lock );
+}
+
+void
+fusion_entries_deinit( FusionEntries *entries )
+{
+     FusionLink       *tmp;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     down( &entries->lock );
+
+     fusion_list_foreach_safe (entry, tmp, entries->list) {
+          if (class->Destroy)
+               class->Destroy( entry, entries->ctx );
+
+          kfree( entry );
+     }
+
+     up( &entries->lock );
+}
+
+int
+fusion_entries_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+     FusionEntries    *entries = private;
+     int               written = 0;
+     struct timeval    now;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     if (!class->Print)
+          return -ENOTSUPP;
+
+     if (down_interruptible (&entries->lock))
+          return -EINTR;
+
+     do_gettimeofday( &now );
+
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->last_lock.tv_sec) {
+               int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
+                           (now.tv_usec - entry->last_lock.tv_usec) / 1000);
+
+               if (diff < 1000) {
+                    written += sprintf( buf + written, "%3d  ms  ", diff );
+               }
+               else if (diff < 1000000) {
+                    written += sprintf( buf + written, "%3d.%d s  ",
+                                        diff / 1000, (diff % 1000) / 100 );
+               }
+               else {
+                    diff = ( now.tv_sec  - entry->last_lock.tv_sec +
+                            (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
+
+                    written += sprintf( buf + written, "%3d.%d h  ",
+                                        diff / 3600, (diff % 3600) / 360 );
+               }
+          }
+          else
+               written += sprintf( buf + written, "  -.-    " );
+
+
+          written += sprintf( buf + written, "(%5d) 0x%08x  ", entry->pid, entry->id );
+
+          written += sprintf( buf + written, "%-24s  ", entry->name[0] ? entry->name : "" );
+
+          written += class->Print( entry, entries->ctx, buf + written );
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&entries->lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+
+     return (written<0) ? 0 : written;
+}
+
+int
+fusion_entry_create( FusionEntries *entries,
+                     int           *ret_id )
+{
+     int               ret;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+     FUSION_ASSERT( ret_id != NULL );
+
+     class = entries->class;
+
+     entry = kmalloc( class->object_size, GFP_KERNEL );
+     if (!entry)
+          return -ENOMEM;
+
+     memset( entry, 0, class->object_size );
+
+     if (down_interruptible( &entries->lock )) {
+          kfree( entry );
+          return -EINTR;
+     }
+
+     entry->entries = entries;
+     entry->id      = entries->ids++;
+     entry->pid     = current->pid;
+
+     init_MUTEX( &entry->lock );
+
+     init_waitqueue_head( &entry->wait );
+
+     if (class->Init) {
+          ret = class->Init( entry, entries->ctx );
+          if (ret) {
+               kfree( entry );
+               return ret;
+          }
+     }
+
+     fusion_list_prepend( &entries->list, &entry->link );
+
+     up( &entries->lock );
+
+     *ret_id = entry->id;
+
+     return 0;
+}
+
+int
+fusion_entry_destroy( FusionEntries  *entries,
+                      int             id )
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Remove the entry from the list. */
+     fusion_list_remove( &entries->list, &entry->link );
+
+     /* Wake up any waiting process. */
+     wake_up_interruptible_all( &entry->wait );
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+
+     /* Call the destroy function. */
+     if (class->Destroy)
+          class->Destroy( entry, entries->ctx );
+
+     /* Deallocate the entry. */
+     kfree( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_set_info( FusionEntries         *entries,
+                       const FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( entry->name, FUSION_ENTRY_INFO_NAME_LENGTH, info->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_get_info( FusionEntries   *entries,
+                       FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( info->name, FUSION_ENTRY_INFO_NAME_LENGTH, entry->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_lock( FusionEntries  *entries,
+                   int             id,
+                   FusionEntry   **ret_entry )
+{
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( ret_entry != NULL );
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     FUSION_ASSUME( entry->lock_pid != current->pid );
+
+     /* Move the entry to the front of all entries. */
+     fusion_list_move_to_front( &entries->list, &entry->link );
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Mark as locked. */
+     entry->lock_pid = current->pid;
+
+     /* Keep timestamp, but use the slightly
+        inexact version to avoid performance impacts. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) && defined _STRUCT_TIMESPEC
+     entry->last_lock.tv_sec = xtime.tv_sec;
+     entry->last_lock.tv_usec = xtime.tv_nsec / 1000;
+#else
+     entry->last_lock = xtime;
+#endif
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+     /* Return the locked entry. */
+     *ret_entry = entry;
+
+     return 0;
+}
+
+void
+fusion_entry_unlock( FusionEntry *entry )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     entry->lock_pid = 0;
+
+     /* Unlock the entry. */
+     up( &entry->lock );
+}
+
+int
+fusion_entry_wait( FusionEntry *entry, long *timeout )
+{
+     int            ret;
+     int            id;
+     FusionEntries *entries;
+     FusionEntry   *entry2;
+
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->entries != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     id      = entry->id;
+     entries = entry->entries;
+
+     entry->waiters++;
+
+     fusion_sleep_on( &entry->wait, &entry->lock, timeout );
+
+     entry->waiters--;
+
+     if (timeout && !*timeout)
+          return -ETIMEDOUT;
+
+     if (signal_pending(current))
+          return -EINTR;
+
+     ret = fusion_entry_lock( entries, id, &entry2 );
+     switch (ret) {
+          case -EINVAL:
+               return -EIDRM;
+
+          case 0:
+               if (entry != entry2)
+                    BUG();
+     }
+
+     return ret;
+}
+
+void
+fusion_entry_notify( FusionEntry *entry, bool all )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     if (!entry->waiters)
+          return;
+
+     if (all)
+          wake_up_interruptible_all( &entry->wait );
+     else
+          wake_up_interruptible( &entry->wait );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/entries.h linux-2.6.12/drivers/char/fusion/entries.h
--- linux-2.6.12.orig/drivers/char/fusion/entries.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/entries.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,174 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__ENTRIES_H__
+#define __FUSION__ENTRIES_H__
+
+#include "types.h"
+#include "list.h"
+
+
+typedef struct __FD_FusionEntry FusionEntry;
+
+
+typedef const struct {
+     int object_size;
+
+     int  (*Init)   ( FusionEntry *entry, void *ctx );
+     void (*Destroy)( FusionEntry *entry, void *ctx );
+     int  (*Print)  ( FusionEntry *entry, void *ctx, char *buf );
+} FusionEntryClass;
+
+
+typedef struct {
+     FusionEntryClass  *class;
+     void              *ctx;
+
+     FusionLink        *list;
+     int                ids;
+     struct semaphore   lock;
+} FusionEntries;
+
+
+struct __FD_FusionEntry {
+     FusionLink         link;
+
+     FusionEntries     *entries;
+
+     int                id;
+     pid_t              pid;
+
+     pid_t              lock_pid;
+
+     struct semaphore   lock;
+     wait_queue_head_t  wait;
+     int                waiters;
+
+     struct timeval     last_lock;
+
+     char               name[FUSION_ENTRY_INFO_NAME_LENGTH];
+};
+
+
+/* Entries Init & DeInit */
+
+void fusion_entries_init  ( FusionEntries    *entries,
+                            FusionEntryClass *class,
+                            void             *ctx );
+
+void fusion_entries_deinit( FusionEntries    *entries );
+
+
+/* '/proc' support */
+
+int  fusion_entries_read_proc( char *buf, char **start, off_t offset,
+                               int len, int *eof, void *private );
+
+
+/* Create & Destroy */
+
+int  fusion_entry_create  ( FusionEntries    *entries,
+                            int              *ret_id );
+
+int  fusion_entry_destroy ( FusionEntries    *entries,
+                            int               id );
+
+
+/* Information */
+
+int  fusion_entry_set_info( FusionEntries          *entries,
+                            const FusionEntryInfo  *info );
+
+int  fusion_entry_get_info( FusionEntries          *entries,
+                            FusionEntryInfo        *info );
+
+
+/* Lock & Unlock */
+
+int  fusion_entry_lock    ( FusionEntries    *entries,
+                            int               id,
+                            FusionEntry     **ret_entry );
+
+void fusion_entry_unlock  ( FusionEntry      *entry );
+
+
+/** Wait & Notify **/
+
+/*
+ * Wait for the entry to be notified with an optional timeout.
+ *
+ * The entry
+ *   (1) has to be locked prior to calling this function.
+ *   (2) is temporarily unlocked while being waited for.
+ *
+ * If this function returns an error, the entry is not locked again!
+ *
+ * Possible errors are:
+ *   -EIDRM      Entry has been removed while being waited for.
+ *   -ETIMEDOUT  Timeout occured.
+ *   -EINTR      A signal has been received.
+ */
+int  fusion_entry_wait    ( FusionEntry      *entry,
+                            long             *timeout );
+
+/*
+ * Wake up one or all processes waiting for the entry to be notified.
+ *
+ * The entry has to be locked prior to calling this function.
+ */
+void fusion_entry_notify  ( FusionEntry      *entry,
+                            bool              all );
+
+
+#define FUSION_ENTRY_CLASS( Type, name, init_func, destroy_func, print_func )   \
+                                                                                \
+     static FusionEntryClass name##_class = {                                   \
+          .object_size = sizeof(Type),                                          \
+          .Init        = init_func,                                             \
+          .Destroy     = destroy_func,                                          \
+          .Print       = print_func                                             \
+     };                                                                         \
+                                                                                \
+     static inline int fusion_##name##_lock( FusionEntries  *entries,           \
+                                             int             id,                \
+                                             Type          **ret_##name )       \
+     {                                                                          \
+          int          ret;                                                     \
+          FusionEntry *entry;                                                   \
+                                                                                \
+          ret = fusion_entry_lock( entries, id, &entry );                       \
+                                                                                \
+          if (!ret)                                                             \
+               *ret_##name = (Type *) entry;                                    \
+                                                                                \
+          return ret;                                                           \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_unlock( Type *name )                    \
+     {                                                                          \
+          fusion_entry_unlock( (FusionEntry*) name );                           \
+     }                                                                          \
+                                                                                \
+     static inline int fusion_##name##_wait( Type *name, long *timeout )        \
+     {                                                                          \
+          return fusion_entry_wait( (FusionEntry*) name, timeout );             \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_notify( Type *name, bool all )          \
+     {                                                                          \
+          fusion_entry_notify( (FusionEntry*) name, all );                      \
+     }
+
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fifo.c linux-2.6.12/drivers/char/fusion/fifo.c
--- linux-2.6.12.orig/drivers/char/fusion/fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fifo.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "fifo.h"
+
+void
+fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
+{
+     link->prev = fifo->last;
+     link->next = NULL;
+
+     if (fifo->last)
+          fifo->last->next = link;
+     else
+          fifo->first = link;
+
+     fifo->last = link;
+
+     fifo->count++;
+}
+
+FusionLink *
+fusion_fifo_get (FusionFifo *fifo)
+{
+     FusionLink *first = fifo->first;
+
+     if (!first)
+          return NULL;
+
+     fifo->first = first->next;
+
+     if (fifo->last == first)
+          fifo->last = NULL;
+     else
+          fifo->first->prev = NULL;
+
+     fifo->count--;
+
+     return first;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fifo.h linux-2.6.12/drivers/char/fusion/fifo.h
--- linux-2.6.12.orig/drivers/char/fusion/fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fifo.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__FIFO_H__
+#define __FUSION__FIFO_H__
+
+#include "types.h"
+#include "list.h"
+
+typedef struct {
+     FusionLink *first;
+     FusionLink *last;
+
+     int         count;
+} FusionFifo;
+
+void        fusion_fifo_put   (FusionFifo *fifo,
+                               FusionLink *link);
+
+FusionLink *fusion_fifo_get   (FusionFifo *fifo);
+
+int         fusion_fifo_count (FusionFifo *fifo);
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusiondev.c linux-2.6.12/drivers/char/fusion/fusiondev.c
--- linux-2.6.12.orig/drivers/char/fusion/fusiondev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusiondev.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,956 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+#include <linux/device.h>
+#endif
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+#ifndef FUSION_MAJOR
+#define FUSION_MAJOR 252
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Denis Oliver Kropp <dok@directfb.org>");
+
+struct proc_dir_entry *proc_fusion_dir;
+
+#define NUM_MINORS 8
+
+static FusionDev  *fusion_devs[NUM_MINORS] = { 0 };
+static DECLARE_MUTEX(devs_lock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static devfs_handle_t devfs_handles[NUM_MINORS];
+static inline unsigned iminor(struct inode *inode)
+{
+        return MINOR(inode->i_rdev);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+static struct class_simple *fusion_class;
+#endif
+
+/******************************************************************************/
+
+void
+fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeout)
+{
+     wait_queue_t wait;
+
+     init_waitqueue_entry (&wait, current);
+
+     current->state = TASK_INTERRUPTIBLE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+     spin_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     spin_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+#else
+     write_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     write_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+#endif
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_stat_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionDev *dev     = private;
+     int        written = 0;
+
+     written += snprintf( buf, len,
+                          "lease/purchase   cede      attach     detach      "
+                          "ref up   ref down  prevail/swoop dismiss\n" );
+     if (written < offset) {
+          offset -= written;
+          written = 0;
+     }
+
+     if (written < len) {
+          written += snprintf( buf+written, len - written,
+                               "%10d %10d  %10d %10d  %10d %10d  %10d %10d\n",
+                               dev->stat.property_lease_purchase,
+                               dev->stat.property_cede,
+                               dev->stat.reactor_attach,
+                               dev->stat.reactor_detach,
+                               dev->stat.ref_up,
+                               dev->stat.ref_down,
+                               dev->stat.skirmish_prevail_swoop,
+                               dev->stat.skirmish_dismiss );
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+     }
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_init (FusionDev *dev)
+{
+     int ret;
+
+     ret = fusionee_init (dev);
+     if (ret)
+          goto error_fusionee;
+
+     ret = fusion_ref_init (dev);
+     if (ret)
+          goto error_ref;
+
+     ret = fusion_skirmish_init (dev);
+     if (ret)
+          goto error_skirmish;
+
+     ret = fusion_property_init (dev);
+     if (ret)
+          goto error_property;
+
+     ret = fusion_reactor_init (dev);
+     if (ret)
+          goto error_reactor;
+
+     ret = fusion_call_init (dev);
+     if (ret)
+          goto error_call;
+
+     create_proc_read_entry("stat", 0, dev->proc_dir,
+                            fusiondev_stat_read_proc, dev);
+
+     return 0;
+
+
+error_call:
+     fusion_reactor_deinit (dev);
+
+error_reactor:
+     fusion_property_deinit (dev);
+
+error_property:
+     fusion_skirmish_deinit (dev);
+
+error_skirmish:
+     fusion_ref_deinit (dev);
+
+error_ref:
+     fusionee_deinit (dev);
+
+error_fusionee:
+     return ret;
+}
+
+static void
+fusiondev_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("stat", dev->proc_dir);
+
+     fusion_call_deinit (dev);
+     fusion_reactor_deinit (dev);
+     fusion_property_deinit (dev);
+     fusion_skirmish_deinit (dev);
+     fusion_ref_deinit (dev);
+     fusionee_deinit (dev);
+}
+
+/******************************************************************************/
+
+static int
+fusion_open (struct inode *inode, struct file *file)
+{
+     int ret;
+     int fusion_id;
+     int minor = iminor(inode);
+
+     DEBUG( "fusion_open\n" );
+
+     if (down_interruptible (&devs_lock))
+          return -EINTR;
+
+     if (!fusion_devs[minor]) {
+          char buf[4];
+
+          fusion_devs[minor] = kmalloc (sizeof(FusionDev), GFP_KERNEL);
+          if (!fusion_devs[minor]) {
+               up (&devs_lock);
+               return -ENOMEM;
+          }
+
+          memset (fusion_devs[minor], 0, sizeof(FusionDev));
+
+          snprintf (buf, 4, "%d", minor);
+
+          fusion_devs[minor]->proc_dir = proc_mkdir (buf, proc_fusion_dir);
+
+          ret = fusiondev_init (fusion_devs[minor]);
+          if (ret) {
+               remove_proc_entry (buf, proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+
+               up (&devs_lock);
+
+               return ret;
+          }
+     }
+     else if (file->f_flags & O_EXCL) {
+          up (&devs_lock);
+          return -EBUSY;
+     }
+
+     ret = fusionee_new (fusion_devs[minor], &fusion_id);
+     if (ret) {
+          if (!fusion_devs[minor]->refs) {
+               fusiondev_deinit (fusion_devs[minor]);
+
+               remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                                  proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+          }
+
+          up (&devs_lock);
+
+          return ret;
+     }
+
+     fusion_devs[minor]->refs++;
+
+     up (&devs_lock);
+
+
+     file->private_data = (void*) fusion_id;
+
+     return 0;
+}
+
+static int
+fusion_release (struct inode *inode, struct file *file)
+{
+     int ret;
+     int minor     = iminor(inode);
+     int fusion_id = (int) file->private_data;
+
+     DEBUG( "fusion_release\n" );
+
+     ret = fusionee_destroy (fusion_devs[minor], fusion_id);
+     if (ret)
+          return ret;
+
+     down (&devs_lock);
+
+     if (! --fusion_devs[minor]->refs) {
+          fusiondev_deinit (fusion_devs[minor]);
+
+          remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                             proc_fusion_dir);
+
+          kfree (fusion_devs[minor]);
+          fusion_devs[minor] = NULL;
+     }
+
+     up (&devs_lock);
+
+     return 0;
+}
+
+static int
+fusion_flush (struct file *file)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     (void) fusion_id;
+
+     DEBUG( "fusion_flush (0x%08x %d)\n", fusion_id, current->pid );
+
+     if (current->flags & PF_EXITING)
+          fusion_skirmish_dismiss_all_from_pid (dev, current->pid);
+
+     return 0;
+}
+
+static ssize_t
+fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_read (%d)\n", count );
+
+     return fusionee_get_messages (dev, fusion_id, buf, count,
+                                   !(file->f_flags & O_NONBLOCK));
+}
+
+static unsigned int
+fusion_poll (struct file *file, poll_table * wait)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_poll\n" );
+
+     return fusionee_poll (dev, fusion_id, file, wait);
+}
+
+static int
+lounge_ioctl (FusionDev *dev, int fusion_id,
+              unsigned int cmd, unsigned long arg)
+{
+     int             ret;
+     FusionEnter     enter;
+     FusionKill      kill;
+     FusionEntryInfo info;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_ENTER):
+               if (copy_from_user (&enter, (FusionEnter*) arg, sizeof(enter)))
+                    return -EFAULT;
+
+               if (enter.api.major != FUSION_API_MAJOR || enter.api.minor > FUSION_API_MINOR)
+                    return -ENOPROTOOPT;
+
+               enter.fusion_id = fusion_id;
+
+               if (copy_to_user ((FusionEnter*) arg, &enter, sizeof(enter)))
+                    return -EFAULT;
+
+               return 0;
+
+          case _IOC_NR(FUSION_KILL):
+               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+                    return -EFAULT;
+
+               return fusionee_kill (dev, fusion_id,
+                                     kill.fusion_id, kill.signal, kill.timeout_ms);
+
+          case _IOC_NR(FUSION_ENTRY_SET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         return fusion_entry_set_info (&dev->skirmish, &info);
+
+                    case FT_PROPERTY:
+                         return fusion_entry_set_info (&dev->properties, &info);
+
+                    case FT_REACTOR:
+                         return fusion_entry_set_info (&dev->reactor, &info);
+
+                    default:
+                         return -ENOSYS;
+               }
+
+          case _IOC_NR(FUSION_ENTRY_GET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         ret = fusion_entry_get_info (&dev->skirmish, &info);
+                         break;
+
+                    case FT_PROPERTY:
+                         ret = fusion_entry_get_info (&dev->properties, &info);
+                         break;
+
+                    case FT_REACTOR:
+                         ret = fusion_entry_get_info (&dev->reactor, &info);
+                         break;
+
+                    default:
+                         return -ENOSYS;
+               }
+
+               if (ret)
+                    return ret;
+
+               if (copy_to_user ((FusionEntryInfo*) arg, &info, sizeof(info)))
+                    return -EFAULT;
+
+               return 0;
+     }
+
+     return -ENOSYS;
+}
+
+static int
+messaging_ioctl (FusionDev *dev, int fusion_id,
+                 unsigned int cmd, unsigned long arg)
+{
+     FusionSendMessage send;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SEND_MESSAGE):
+               if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
+                    return -EFAULT;
+
+               if (send.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (send.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusionee_send_message (dev, fusion_id, send.fusion_id, FMT_SEND,
+                                             send.msg_id, send.msg_size, send.msg_data);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+call_ioctl (FusionDev *dev, int fusion_id,
+            unsigned int cmd, unsigned long arg)
+{
+     int               id;
+     int               ret;
+     FusionCallNew     call;
+     FusionCallExecute execute;
+     FusionCallReturn  call_ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_CALL_NEW):
+               if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+                    return -EFAULT;
+
+               ret = fusion_call_new (dev, fusion_id, &call);
+               if (ret)
+                    return ret;
+
+               if (put_user (call.call_id, (int*) arg)) {
+                    fusion_call_destroy (dev, fusion_id, call.call_id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_EXECUTE):
+               if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+                    return -EFAULT;
+
+               ret = fusion_call_execute (dev, fusion_id, &execute);
+               if (ret)
+                    return ret;
+
+               if (put_user (execute.ret_val, (int*) arg))
+                    return -EFAULT;
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_RETURN):
+               if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+                    return -EFAULT;
+
+               return fusion_call_return (dev, fusion_id, &call_ret);
+
+          case _IOC_NR(FUSION_CALL_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_call_destroy (dev, fusion_id, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+ref_ioctl (FusionDev *dev, int fusion_id,
+           unsigned int cmd, unsigned long arg)
+{
+     int              id;
+     int              ret;
+     int              refs;
+     FusionRefWatch   watch;
+     FusionRefInherit inherit;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REF_NEW):
+               ret = fusion_ref_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_ref_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REF_UP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UP_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_DOWN):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_DOWN_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_ZERO_LOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_lock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_ZERO_TRYLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_trylock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UNLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_unlock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_STAT):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               ret = fusion_ref_stat (dev, id, &refs);
+               if (ret)
+                    return ret;
+
+               return refs;
+
+          case _IOC_NR(FUSION_REF_WATCH):
+               if (copy_from_user (&watch, (FusionRefWatch*) arg, sizeof(watch)))
+                    return -EFAULT;
+
+               return fusion_ref_watch (dev, watch.id, watch.call_id, watch.call_arg);
+
+          case _IOC_NR(FUSION_REF_INHERIT):
+               if (copy_from_user (&inherit, (FusionRefInherit*) arg, sizeof(inherit)))
+                    return -EFAULT;
+
+               return fusion_ref_inherit (dev, inherit.id, inherit.from);
+
+          case _IOC_NR(FUSION_REF_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+skirmish_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SKIRMISH_NEW):
+               ret = fusion_skirmish_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_skirmish_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_SKIRMISH_PREVAIL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_prevail (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_SWOOP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_swoop (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DISMISS):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_dismiss (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+property_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_PROPERTY_NEW):
+               ret = fusion_property_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_property_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_PROPERTY_LEASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_lease (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_PURCHASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_purchase (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_CEDE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_cede (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_HOLDUP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_holdup (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+reactor_ioctl (FusionDev *dev, int fusion_id,
+               unsigned int cmd, unsigned long arg)
+{
+     int                   id;
+     int                   ret;
+     FusionReactorDispatch dispatch;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REACTOR_NEW):
+               ret = fusion_reactor_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_reactor_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REACTOR_ATTACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_attach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DETACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_detach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DISPATCH):
+               if (copy_from_user (&dispatch,
+                                   (FusionReactorDispatch*) arg, sizeof(dispatch)))
+                    return -EFAULT;
+
+               if (dispatch.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (dispatch.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusion_reactor_dispatch (dev, dispatch.reactor_id,
+                                               dispatch.self ? 0 : fusion_id,
+                                               dispatch.msg_size, dispatch.msg_data);
+
+          case _IOC_NR(FUSION_REACTOR_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+     int        id  = (int) file->private_data;
+     FusionDev *dev = fusion_devs[iminor(inode)];
+
+     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+
+     switch (_IOC_TYPE(cmd)) {
+          case FT_LOUNGE:
+               return lounge_ioctl( dev, id, cmd, arg );
+
+          case FT_MESSAGING:
+               return messaging_ioctl( dev, id, cmd, arg );
+
+          case FT_CALL:
+               return call_ioctl( dev, id, cmd, arg );
+
+          case FT_REF:
+               return ref_ioctl( dev, id, cmd, arg );
+
+          case FT_SKIRMISH:
+               return skirmish_ioctl( dev, id, cmd, arg );
+
+          case FT_PROPERTY:
+               return property_ioctl( dev, id, cmd, arg );
+
+          case FT_REACTOR:
+               return reactor_ioctl( dev, id, cmd, arg );
+     }
+
+     return -ENOSYS;
+}
+
+static struct file_operations fusion_fops = {
+     .owner   = THIS_MODULE,
+     .open    = fusion_open,
+     .flush   = fusion_flush,
+     .release = fusion_release,
+     .read    = fusion_read,
+     .poll    = fusion_poll,
+     .ioctl   = fusion_ioctl
+};
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int __init
+register_devices(void)
+{
+     int  i;
+
+     if (register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     fusion_class = class_simple_create (THIS_MODULE, "fusion");
+     if (IS_ERR(fusion_class)) {
+          unregister_chrdev (FUSION_MAJOR, "fusion");
+          return PTR_ERR(fusion_class);
+     }
+#endif
+
+     devfs_mk_dir("fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_add (fusion_class,
+                                   MKDEV(FUSION_MAJOR, i),
+                                   NULL, "fusion%d", i);
+#endif
+
+          devfs_mk_cdev (MKDEV(FUSION_MAJOR, i),
+                         S_IFCHR | S_IRUSR | S_IWUSR,
+                         "fusion/%d", i);
+     }
+
+     return 0;
+}
+#else
+static int __init
+register_devices(void)
+{
+     int  i;
+     char buf[16];
+
+     if (devfs_register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+     for (i=0; i<NUM_MINORS; i++) {
+          snprintf (buf, 16, "fusion/%d", i);
+
+          devfs_handles[i] = devfs_register (NULL, buf, DEVFS_FL_DEFAULT,
+                                             FUSION_MAJOR, i,
+                                             S_IFCHR | S_IRUSR | S_IWUSR,
+                                             &fusion_fops, NULL);
+     }
+
+     return 0;
+}
+#endif
+
+int __init
+fusion_init(void)
+{
+     int ret;
+
+     ret = register_devices();
+     if (ret)
+          return ret;
+
+     proc_fusion_dir = proc_mkdir ("fusion", NULL);
+
+     return 0;
+}
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_remove (MKDEV(FUSION_MAJOR, i));
+#endif
+
+          devfs_remove ("fusion/%d", i);
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     class_simple_destroy (fusion_class);
+#endif
+
+     devfs_remove ("fusion");
+}
+#else
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     devfs_unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++)
+          devfs_unregister (devfs_handles[i]);
+}
+#endif
+
+void __exit
+fusion_exit(void)
+{
+     deregister_devices();
+
+     remove_proc_entry ("fusion", NULL);
+}
+
+module_init(fusion_init);
+module_exit(fusion_exit);
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusiondev.h linux-2.6.12/drivers/char/fusion/fusiondev.h
--- linux-2.6.12.orig/drivers/char/fusion/fusiondev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusiondev.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSIONDEV_H__
+#define __FUSIONDEV_H__
+
+#include <linux/proc_fs.h>
+
+#include "entries.h"
+#include "list.h"
+
+#define FUSION_ASSERT(exp)    if (!(exp)) BUG()
+#define FUSION_ASSUME(exp)    if (!(exp)) printk( KERN_ERR "fusiondev: assumption '" #exp "' failed!\n" )
+
+typedef struct {
+     int refs;
+
+     struct proc_dir_entry *proc_dir;
+
+     struct {
+          int property_lease_purchase;
+          int property_cede;
+
+          int reactor_attach;
+          int reactor_detach;
+
+          int ref_up;
+          int ref_down;
+
+          int skirmish_prevail_swoop;
+          int skirmish_dismiss;
+     } stat;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } call;
+
+     struct {
+          int                last_id;
+          FusionLink        *list;
+          struct semaphore   lock;
+          wait_queue_head_t  wait;
+     } fusionee;
+
+     FusionEntries  properties;
+
+     FusionEntries  reactor;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } ref;
+
+     FusionEntries  skirmish;
+} FusionDev;
+
+/*
+ * Special version of interruptible_sleep_on() that unlocks the mutex
+ * after adding the entry to the queue (just before schedule).
+ */
+void fusion_sleep_on (wait_queue_head_t *q,
+                      struct semaphore  *lock,
+                      signed long       *timeout_ms);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusionee.c linux-2.6.12/drivers/char/fusion/fusionee.c
--- linux-2.6.12.orig/drivers/char/fusion/fusionee.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusionee.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,507 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fifo.h"
+#include "list.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+typedef struct {
+     FusionLink        link;
+
+     struct semaphore  lock;
+
+     int               id;
+     int               pid;
+
+     FusionFifo        messages;
+
+     int               rcv_total;  /* Total number of messages received. */
+     int               snd_total;  /* Total number of messages sent. */
+
+     wait_queue_head_t wait;
+} Fusionee;
+
+typedef struct {
+     FusionLink         link;
+
+     FusionMessageType  type;
+     int                id;
+     int                size;
+     void              *data;
+} Message;
+
+/******************************************************************************/
+
+static int  lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static int  lock_fusionee   (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static void unlock_fusionee (Fusionee *fusionee);
+
+/******************************************************************************/
+
+static int
+fusionees_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee*) l;
+
+          written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %7d received, %7d sent)\n",
+                             fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->fusionee.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusionee_init (FusionDev *dev)
+{
+     init_waitqueue_head (&dev->fusionee.wait);
+
+     init_MUTEX (&dev->fusionee.lock);
+
+     create_proc_read_entry("fusionees", 0, dev->proc_dir,
+                            fusionees_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusionee_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->fusionee.lock);
+
+     remove_proc_entry ("fusionees", dev->proc_dir);
+
+     l = dev->fusionee.list;
+     while (l) {
+          FusionLink *next     = l->next;
+          Fusionee   *fusionee = (Fusionee *) l;
+
+          while (fusionee->messages.count) {
+               Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+               kfree (message);
+          }
+
+          kfree (fusionee);
+
+          l = next;
+     }
+
+     up (&dev->fusionee.lock);
+}
+
+/******************************************************************************/
+
+int
+fusionee_new (FusionDev *dev, int *id)
+{
+     Fusionee *fusionee;
+
+     fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+     if (!fusionee)
+          return -ENOMEM;
+
+     memset (fusionee, 0, sizeof(Fusionee));
+
+     if (down_interruptible (&dev->fusionee.lock)) {
+          kfree (fusionee);
+          return -EINTR;
+     }
+
+     fusionee->id  = ++dev->fusionee.last_id;
+     fusionee->pid = current->pid;
+
+     init_MUTEX (&fusionee->lock);
+
+     init_waitqueue_head (&fusionee->wait);
+
+     fusion_list_prepend (&dev->fusionee.list, &fusionee->link);
+
+     up (&dev->fusionee.lock);
+
+     *id = fusionee->id;
+
+     return 0;
+}
+
+int
+fusionee_send_message (FusionDev *dev, int id, int recipient,
+                       FusionMessageType msg_type, int msg_id,
+                       int msg_size, const void *msg_data)
+{
+     int       ret;
+     Message  *message;
+     Fusionee *sender   = NULL;
+     Fusionee *fusionee;
+
+     DEBUG( "fusionee_send_message (%d -> %d, type %d, id %d, size %d)\n",
+            id, recipient, msg_type, msg_id, msg_size );
+
+     ret = lock_fusionee (dev, recipient, &fusionee);
+     if (ret)
+          return ret;
+
+     if (id) {
+          if (id == recipient) {
+               sender = fusionee;
+          }
+          else {
+               ret = lock_fusionee (dev, id, &sender);
+               if (ret) {
+                    unlock_fusionee (fusionee);
+                    return ret == -EINVAL ? -EIO : ret;
+               }
+          }
+     }
+
+     message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
+     if (!message) {
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -ENOMEM;
+     }
+
+     message->data = message + 1;
+
+     if (msg_type == FMT_CALL)
+          memcpy (message->data, msg_data, msg_size);
+     else if (copy_from_user (message->data, msg_data, msg_size)) {
+          kfree (message);
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -EFAULT;
+     }
+
+     message->type = msg_type;
+     message->id   = msg_id;
+     message->size = msg_size;
+
+     fusion_fifo_put (&fusionee->messages, &message->link);
+
+     fusionee->rcv_total++;
+     if (sender)
+          sender->snd_total++;
+
+     wake_up_interruptible_all (&fusionee->wait);
+
+     if (sender && sender != fusionee)
+          unlock_fusionee (sender);
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_get_messages (FusionDev *dev,
+                       int id, void *buf, int buf_size, bool block)
+{
+     int       ret;
+     int       written  = 0;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     while (!fusionee->messages.count) {
+          if (!block) {
+               unlock_fusionee (fusionee);
+               return -EAGAIN;
+          }
+
+          fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
+
+          if (signal_pending(current))
+               return -EINTR;
+
+          ret = lock_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+     }
+
+     while (fusionee->messages.count) {
+          FusionReadMessage  header;
+          Message           *message = (Message*) fusionee->messages.first;
+          int                bytes   = message->size + sizeof(header);
+
+          if (bytes > buf_size) {
+               if (!written) {
+                    unlock_fusionee (fusionee);
+                    return -EMSGSIZE;
+               }
+
+               break;
+          }
+
+          header.msg_type = message->type;
+          header.msg_id   = message->id;
+          header.msg_size = message->size;
+
+          if (copy_to_user (buf, &header, sizeof(header)) ||
+              copy_to_user (buf + sizeof(header), message->data, message->size)) {
+               unlock_fusionee (fusionee);
+               return -EFAULT;
+          }
+
+          written  += bytes;
+          buf      += bytes;
+          buf_size -= bytes;
+
+          fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     unlock_fusionee (fusionee);
+
+     return written;
+}
+
+unsigned int
+fusionee_poll (FusionDev *dev, int id, struct file *file, poll_table * wait)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     unlock_fusionee (fusionee);
+
+
+     poll_wait (file, &fusionee->wait, wait);
+
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (!fusionee)
+          return -EINVAL;
+
+     if (fusionee->messages.count) {
+          unlock_fusionee (fusionee);
+
+          return POLLIN | POLLRDNORM;
+     }
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_kill (FusionDev *dev, int id, int target, int signal, int timeout_ms)
+{
+     long timeout = -1;
+
+     while (true) {
+          int         ret;
+          FusionLink *l;
+          Fusionee   *fusionee;
+          int         killed   = 0;
+
+          ret = lookup_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+
+          fusion_list_foreach (l, dev->fusionee.list) {
+               Fusionee *f = (Fusionee*) l;
+
+               if (f->id != id && (!target || target == f->id)) {
+                    kill_proc (f->pid, signal, 0);
+                    killed++;
+               }
+          }
+
+          if (!killed || timeout_ms < 0)
+               break;
+
+          if (timeout_ms) {
+               switch (timeout) {
+                    case 0:  /* timed out */
+                         up (&dev->fusionee.lock);
+                         return -ETIMEDOUT;
+
+                    case -1: /* setup timeout */
+                         timeout = (timeout_ms * HZ + 500) / 1000;
+                         if (!timeout)
+                              timeout = 1;
+
+                         /* fall through */
+
+                    default:
+                         fusion_sleep_on (&dev->fusionee.wait,
+                                          &dev->fusionee.lock, &timeout);
+                         break;
+               }
+          }
+          else
+               fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
+
+          if (signal_pending(current))
+               return -EINTR;
+     }
+
+     up (&dev->fusionee.lock);
+
+     return 0;
+}
+
+int
+fusionee_destroy (FusionDev *dev, int id)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     down (&fusionee->lock);
+
+     fusion_list_remove (&dev->fusionee.list, &fusionee->link);
+
+     wake_up_interruptible_all (&dev->fusionee.wait);
+
+     up (&dev->fusionee.lock);
+
+
+     fusion_call_destroy_all (dev, id);
+     fusion_skirmish_dismiss_all (dev, id);
+     fusion_reactor_detach_all (dev, id);
+     fusion_property_cede_all (dev, id);
+     fusion_ref_clear_all_local (dev, id);
+
+     while (fusionee->messages.count) {
+          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     up (&fusionee->lock);
+
+     kfree (fusionee);
+
+     return ret;
+}
+
+/******************************************************************************/
+
+static int
+lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee *) l;
+
+          if (fusionee->id == id) {
+               *ret_fusionee = fusionee;
+               return 0;
+          }
+     }
+
+     up (&dev->fusionee.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (fusionee) {
+          fusion_list_move_to_front (&dev->fusionee.list, &fusionee->link);
+
+          if (down_interruptible (&fusionee->lock)) {
+               up (&dev->fusionee.lock);
+               return -EINTR;
+          }
+
+          up (&dev->fusionee.lock);
+     }
+
+     *ret_fusionee = fusionee;
+
+     return 0;
+}
+
+static void
+unlock_fusionee (Fusionee *fusionee)
+{
+     up (&fusionee->lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusionee.h linux-2.6.12/drivers/char/fusion/fusionee.h
--- linux-2.6.12.orig/drivers/char/fusion/fusionee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusionee.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSIONEE_H__
+#define __FUSIONEE_H__
+
+#include <linux/poll.h>
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusionee_init   (FusionDev *dev);
+void fusionee_deinit (FusionDev *dev);
+
+
+/* internal functions */
+
+int fusionee_new           (FusionDev         *dev,
+                            int               *id);
+
+int fusionee_send_message  (FusionDev         *dev,
+                            int                id,
+                            int                recipient,
+                            FusionMessageType  msg_type,
+                            int                msg_id,
+                            int                msg_size,
+                            const void        *msg_data);
+
+int fusionee_get_messages  (FusionDev         *dev,
+                            int                id,
+                            void              *buf,
+                            int                buf_size,
+                            bool               block);
+
+unsigned
+int fusionee_poll          (FusionDev         *dev,
+                            int                id,
+                            struct file       *file,
+                            poll_table        *wait);
+
+int fusionee_kill          (FusionDev         *dev,
+                            int                id,
+                            int                target,
+                            int                signal,
+                            int                timeout_ms);
+
+int fusionee_destroy       (FusionDev         *dev,
+                            int                id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/list.c linux-2.6.12/drivers/char/fusion/list.c
--- linux-2.6.12.orig/drivers/char/fusion/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/list.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "list.h"
+
+void
+fusion_list_prepend (FusionLink **list, FusionLink *link)
+{
+     link->prev = NULL;
+     link->next = *list;
+
+     if (*list)
+          (*list)->prev = link;
+
+     *list = link;
+}
+
+void
+fusion_list_remove (FusionLink **list, FusionLink *link)
+{
+     if (link->prev)
+          link->prev->next = link->next;
+     else
+          *list = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->next = link->prev = NULL;
+}
+
+void
+fusion_list_move_to_front (FusionLink **list, FusionLink *link)
+{
+     if (*list == link)
+          return;
+
+     link->prev->next = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->prev = NULL;
+     link->next = *list;
+
+     (*list)->prev = link;
+
+     *list = link;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/list.h linux-2.6.12/drivers/char/fusion/list.h
--- linux-2.6.12.orig/drivers/char/fusion/list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/list.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__LIST_H__
+#define __FUSION__LIST_H__
+
+typedef struct _FusionLink {
+     struct _FusionLink *next;
+     struct _FusionLink *prev;
+} FusionLink;
+
+void fusion_list_prepend       (FusionLink **list, FusionLink *link);
+void fusion_list_remove        (FusionLink **list, FusionLink *link);
+void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
+
+
+#define fusion_list_foreach(elem, list)                     \
+     for (elem = (void*)(list);                             \
+          elem;                                             \
+          elem = (void*)(((FusionLink*)(elem))->next))
+
+#define fusion_list_foreach_safe(elem, temp, list)                                             \
+     for (elem = (void*)(list), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL); \
+          elem;                                                                                \
+          elem = (void*)(temp), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL))
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/property.c linux-2.6.12/drivers/char/fusion/property.c
--- linux-2.6.12.orig/drivers/char/fusion/property.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/property.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,337 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#ifndef yield
+#define yield schedule
+#endif
+
+#include <linux/fusion.h>
+
+#include "entries.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "property.h"
+
+typedef enum {
+     FUSION_PROPERTY_AVAILABLE = 0,
+     FUSION_PROPERTY_LEASED,
+     FUSION_PROPERTY_PURCHASED
+} FusionPropertyState;
+
+typedef struct {
+     FusionEntry         entry;
+
+     FusionPropertyState state;
+     int                 fusion_id; /* non-zero if leased/purchased */
+     unsigned long       purchase_stamp;
+     int                 lock_pid;
+     int                 count;    /* lock counter */
+} FusionProperty;
+
+static int
+fusion_property_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     FusionProperty *property = (FusionProperty*) entry;
+
+     if (property->state != FUSION_PROPERTY_AVAILABLE) {
+          return sprintf( buf, "%s by 0x%08x (%d) %dx\n",
+                          property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
+                          property->fusion_id, property->lock_pid, property->count );
+     }
+
+     return sprintf( buf, "\n" );
+}
+
+FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL, fusion_property_print )
+
+/******************************************************************************/
+
+int
+fusion_property_init( FusionDev *dev )
+{
+     fusion_entries_init( &dev->properties, &property_class, dev );
+
+     create_proc_read_entry( "properties", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->properties );
+
+     return 0;
+}
+
+void
+fusion_property_deinit( FusionDev *dev )
+{
+     remove_proc_entry( "properties", dev->proc_dir );
+
+     fusion_entries_deinit( &dev->properties );
+}
+
+/******************************************************************************/
+
+int
+fusion_property_new( FusionDev *dev, int *ret_id )
+{
+     return fusion_entry_create( &dev->properties, ret_id );
+}
+
+int
+fusion_property_lease( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     long            timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state     = FUSION_PROPERTY_LEASED;
+                    property->fusion_id = fusion_id;
+                    property->lock_pid  = current->pid;
+                    property->count     = 1;
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ / 10) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ / 10;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_purchase( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     signed long     timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state          = FUSION_PROPERTY_PURCHASED;
+                    property->fusion_id      = fusion_id;
+                    property->purchase_stamp = jiffies;
+                    property->lock_pid       = current->pid;
+                    property->count          = 1;
+
+                    fusion_property_notify( property, true );
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_cede( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     bool            purchased;
+
+     dev->stat.property_cede++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->lock_pid != current->pid) {
+          fusion_property_unlock( property );
+          return -EIO;
+     }
+
+     if (--property->count) {
+          fusion_property_unlock( property );
+          return 0;
+     }
+
+     purchased = (property->state == FUSION_PROPERTY_PURCHASED);
+
+     property->state     = FUSION_PROPERTY_AVAILABLE;
+     property->fusion_id = 0;
+     property->lock_pid  = 0;
+
+     fusion_property_notify( property, true );
+
+     fusion_property_unlock( property );
+
+     if (purchased)
+          yield();
+
+     return 0;
+}
+
+int
+fusion_property_holdup( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+
+     if (fusion_id > 1)
+          return -EPERM;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->state == FUSION_PROPERTY_PURCHASED) {
+          if (property->fusion_id == fusion_id) {
+               fusion_property_unlock( property );
+               return -EIO;
+          }
+
+          fusionee_kill( dev, fusion_id, property->fusion_id, SIGKILL, -1 );
+     }
+
+     fusion_property_unlock( property );
+
+     return 0;
+}
+
+int
+fusion_property_destroy( FusionDev *dev, int id )
+{
+     return fusion_entry_destroy( &dev->properties, id );
+}
+
+void
+fusion_property_cede_all( FusionDev *dev, int fusion_id )
+{
+     FusionLink *l;
+
+     down( &dev->properties.lock );
+
+     fusion_list_foreach (l, dev->properties.list) {
+          FusionProperty *property = (FusionProperty *) l;
+
+          down( &property->entry.lock );
+
+          if (property->fusion_id == fusion_id) {
+               property->state     = FUSION_PROPERTY_AVAILABLE;
+               property->fusion_id = 0;
+               property->lock_pid  = 0;
+
+               wake_up_interruptible_all (&property->entry.wait);
+          }
+
+          up( &property->entry.lock );
+     }
+
+     up( &dev->properties.lock );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/property.h linux-2.6.12/drivers/char/fusion/property.h
--- linux-2.6.12.orig/drivers/char/fusion/property.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/property.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__PROPERTY_H__
+#define __FUSION__PROPERTY_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_property_init   (FusionDev *dev);
+void fusion_property_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_property_new      (FusionDev *dev,
+                              int       *ret_id);
+
+int fusion_property_lease    (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_purchase (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_cede     (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_holdup   (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_destroy  (FusionDev *dev,
+                              int        id);
+
+
+/* internal functions */
+
+void fusion_property_cede_all (FusionDev *dev,
+                               int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/reactor.c linux-2.6.12/drivers/char/fusion/reactor.c
--- linux-2.6.12.orig/drivers/char/fusion/reactor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/reactor.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "reactor.h"
+
+typedef struct {
+     FusionLink         link;
+
+     int                fusion_id;
+
+     int                count;     /* number of attach calls */
+} ReactorNode;
+
+typedef struct {
+     FusionEntry        entry;
+
+     FusionLink        *nodes;
+
+     int                dispatch_count;
+} FusionReactor;
+
+/******************************************************************************/
+
+static ReactorNode *get_node      ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         remove_node   ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         free_all_nodes( FusionReactor *reactor );
+
+/******************************************************************************/
+
+static void
+fusion_reactor_destruct( FusionEntry *entry,
+                         void        *ctx )
+{
+     FusionReactor *reactor = (FusionReactor*) entry;
+
+     free_all_nodes( reactor );
+}
+
+static int
+fusion_reactor_print( FusionEntry *entry,
+                      void        *ctx,
+                      char        *buf )
+{
+     int            num     = 0;
+     FusionReactor *reactor = (FusionReactor*) entry;
+     FusionLink    *node    = reactor->nodes;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          num++;
+     }
+
+     return sprintf( buf, "%5dx dispatch, %d nodes\n", reactor->dispatch_count, num );
+}
+
+
+FUSION_ENTRY_CLASS( FusionReactor, reactor, NULL,
+                    fusion_reactor_destruct, fusion_reactor_print )
+
+/******************************************************************************/
+
+int
+fusion_reactor_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->reactor, &reactor_class, dev );
+
+     create_proc_read_entry( "reactors", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->reactor );
+
+     return 0;
+}
+
+void
+fusion_reactor_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("reactors", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->reactor );
+}
+
+/******************************************************************************/
+
+int
+fusion_reactor_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->reactor, ret_id );
+}
+
+int
+fusion_reactor_attach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_attach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
+          if (!node) {
+               fusion_reactor_unlock( reactor );
+               return -ENOMEM;
+          }
+
+          node->fusion_id = fusion_id;
+          node->count     = 1;
+
+          fusion_list_prepend (&reactor->nodes, &node->link);
+     }
+     else
+          node->count++;
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_detach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_detach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          fusion_reactor_unlock( reactor );
+          return -EIO;
+     }
+
+     if (! --node->count) {
+          fusion_list_remove (&reactor->nodes, &node->link);
+          kfree (node);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_dispatch (FusionDev *dev, int id, int fusion_id,
+                         int msg_size, const void *msg_data)
+{
+     int            ret;
+     FusionLink    *l;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     reactor->dispatch_count++;
+
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
+
+          if (node->fusion_id == fusion_id)
+               continue;
+
+          fusionee_send_message (dev, fusion_id, node->fusion_id, FMT_REACTOR,
+                                 reactor->entry.id, msg_size, msg_data);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->reactor, id );
+}
+
+void
+fusion_reactor_detach_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->reactor.lock);
+
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor *) l;
+
+          remove_node (reactor, fusion_id);
+     }
+
+     up (&dev->reactor.lock);
+}
+
+/******************************************************************************/
+
+static ReactorNode *
+get_node (FusionReactor *reactor,
+          int            fusion_id)
+{
+     ReactorNode *node;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id)
+               return node;
+     }
+
+     return NULL;
+}
+
+static void
+remove_node (FusionReactor *reactor, int fusion_id)
+{
+     ReactorNode *node;
+
+     down (&reactor->entry.lock);
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id) {
+               fusion_list_remove (&reactor->nodes, &node->link);
+               break;
+          }
+     }
+
+     up (&reactor->entry.lock);
+}
+
+static void
+free_all_nodes (FusionReactor *reactor)
+
+{
+     FusionLink  *n;
+     ReactorNode *node;
+
+     fusion_list_foreach_safe (node, n, reactor->nodes) {
+          kfree (node);
+     }
+
+     reactor->nodes = NULL;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/reactor.h linux-2.6.12/drivers/char/fusion/reactor.h
--- linux-2.6.12.orig/drivers/char/fusion/reactor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/reactor.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__REACTOR_H__
+#define __FUSION__REACTOR_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_reactor_init   (FusionDev *dev);
+void fusion_reactor_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_reactor_new      (FusionDev  *dev,
+                             int        *id);
+
+int fusion_reactor_attach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_detach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_dispatch (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id,
+                             int         msg_size,
+                             const void *msg_data);
+
+int fusion_reactor_destroy  (FusionDev  *dev,
+                             int         id);
+
+
+/* internal functions */
+
+void fusion_reactor_detach_all (FusionDev *dev,
+                                int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/ref.c linux-2.6.12/drivers/char/fusion/ref.c
--- linux-2.6.12.orig/drivers/char/fusion/ref.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/ref.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,777 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "list.h"
+#include "call.h"
+#include "ref.h"
+
+typedef struct __Fusion_FusionRef FusionRef;
+
+typedef struct {
+     FusionLink  link;
+     int         fusion_id;
+     int         refs;
+} LocalRef;
+
+typedef struct {
+     FusionLink  link;
+     FusionRef  *ref;
+} Inheritor;
+
+struct __Fusion_FusionRef {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;
+     int                pid;
+
+     int                global;
+     int                local;
+
+     int                locked;    /* non-zero fusion id of lock owner */
+
+     bool               watched;   /* true if watch has been installed */
+     int                call_id;   /* id of call registered with a watch */
+     int                call_arg;  /* optional call parameter */
+
+     FusionRef         *inherited;
+     FusionLink        *inheritors;
+
+     FusionLink        *local_refs;
+
+     wait_queue_head_t  wait;
+};
+
+/******************************************************************************/
+
+static int  lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static int  lock_ref   (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static void unlock_ref (FusionRef *ref);
+
+static int  add_local       (FusionRef *ref, int fusion_id, int add);
+static void clear_local     (FusionDev *dev, FusionRef *ref, int fusion_id);
+static void free_all_local  (FusionRef *ref);
+
+static int  propagate_local (FusionDev *dev, FusionRef *ref, int diff);
+
+static void notify_ref      (FusionDev *dev, FusionRef *ref);
+
+static int  add_inheritor   (FusionRef *ref, FusionRef *from);
+static void remove_inheritor(FusionRef *ref, FusionRef *from);
+static void drop_inheritors (FusionDev *dev, FusionRef *ref);
+
+/******************************************************************************/
+
+static int
+refs_read_proc(char *buf, char **start, off_t offset,
+               int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef*) l;
+
+          if (ref->locked)
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d (locked by %d)\n",
+                                  ref->pid, ref->id, ref->global, ref->local,
+                                  ref->locked);
+          else
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d\n",
+                                  ref->pid, ref->id, ref->global, ref->local);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->ref.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_ref_init (FusionDev *dev)
+{
+     init_MUTEX (&dev->ref.lock);
+
+     create_proc_read_entry("refs", 0, dev->proc_dir,
+                            refs_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusion_ref_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     remove_proc_entry ("refs", dev->proc_dir);
+
+     l = dev->ref.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionRef  *ref  = (FusionRef *) l;
+
+          free_all_local (ref);
+
+          kfree (ref);
+
+          l = next;
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_ref_new (FusionDev *dev, int *id)
+{
+     FusionRef *ref;
+
+     ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+     if (!ref)
+          return -ENOMEM;
+
+     memset (ref, 0, sizeof(FusionRef));
+
+     if (down_interruptible (&dev->ref.lock)) {
+          kfree (ref);
+          return -EINTR;
+     }
+
+     ref->id   = dev->ref.ids++;
+     ref->pid  = current->pid;
+
+     init_MUTEX (&ref->lock);
+
+     init_waitqueue_head (&ref->wait);
+
+     fusion_list_prepend (&dev->ref.list, &ref->link);
+
+     up (&dev->ref.lock);
+
+     *id = ref->id;
+
+     return 0;
+}
+
+int
+fusion_ref_up (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_up++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = add_local (ref, fusion_id, 1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, 1 );
+     }
+     else
+          ref->global++;
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_down (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_down++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = -EIO;
+          if (!ref->local)
+               goto out;
+
+          ret = add_local (ref, fusion_id, -1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, -1 );
+     }
+     else {
+          if (!ref->global) {
+               ret = -EIO;
+               goto out;
+          }
+
+          ref->global--;
+
+          if (ref->local + ref->global == 0)
+               notify_ref (dev, ref);
+     }
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     while (true) {
+          ret = lock_ref (dev, false, id, &ref);
+          if (ret)
+               return ret;
+
+          if (ref->watched) {
+               unlock_ref (ref);
+               return -EACCES;
+          }
+
+          if (ref->locked) {
+               unlock_ref (ref);
+               return ref->locked == fusion_id ? -EIO : -EAGAIN;
+          }
+
+          if (ref->global || ref->local) {
+               fusion_sleep_on (&ref->wait, &ref->lock, 0);
+
+               if (signal_pending(current))
+                    return -EINTR;
+          }
+          else
+               break;
+     }
+
+     ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_zero_trylock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked) {
+          unlock_ref (ref);
+          return ref->locked == fusion_id ? -EIO : -EAGAIN;
+     }
+
+     if (ref->global || ref->local)
+          ret = -ETOOMANYREFS;
+     else
+          ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_unlock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked != fusion_id) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     ref->locked = 0;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_stat (FusionDev *dev, int id, int *refs)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     *refs = ref->global + ref->local;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_watch (FusionDev      *dev,
+                  int             id,
+                  int             call_id,
+                  int             call_arg)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->pid != current->pid) {
+          unlock_ref (ref);
+          return -EACCES;
+     }
+
+     if (ref->global + ref->local == 0) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     if (ref->watched) {
+          unlock_ref (ref);
+          return -EBUSY;
+     }
+
+     ref->watched  = true;
+     ref->call_id  = call_id;
+     ref->call_arg = call_arg;
+
+     wake_up_interruptible_all (&ref->wait);
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_inherit (FusionDev *dev,
+                    int        id,
+                    int        from_id)
+{
+     int        ret;
+     FusionRef *ref;
+     FusionRef *from = NULL;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     ret = -EBUSY;
+     if (ref->inherited)
+          goto out;
+
+     ret = lock_ref (dev, true, from_id, &from);
+     if (ret)
+          goto out;
+
+     ret = add_inheritor( ref, from );
+     if (ret)
+          goto out;
+
+     ret = propagate_local( dev, ref, from->local );
+     if (ret)
+          goto out;
+
+     ref->inherited = from;
+
+out:
+     if (from)
+          unlock_ref (from);
+
+     unlock_ref (ref);
+
+     up (&dev->ref.lock);
+
+     return ret;
+}
+
+int
+fusion_ref_destroy (FusionDev *dev, int id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     drop_inheritors( dev, ref );
+
+     if (ref->inherited)
+          remove_inheritor( ref, ref->inherited );
+
+     fusion_list_remove (&dev->ref.list, &ref->link);
+
+     wake_up_interruptible_all (&ref->wait);
+
+     up (&dev->ref.lock);
+
+     free_all_local (ref);
+
+     up (&ref->lock);
+
+     kfree (ref);
+
+     return 0;
+}
+
+void
+fusion_ref_clear_all_local (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          clear_local (dev, ref, fusion_id);
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     FusionLink *l;
+
+     if (!locked && down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          if (ref->id == id) {
+               *ret_ref = ref;
+               return 0;
+          }
+     }
+
+     if (!locked)
+          up (&dev->ref.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     int         ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, locked, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref) {
+          fusion_list_move_to_front (&dev->ref.list, &ref->link);
+
+          if (down_interruptible (&ref->lock)) {
+               if (!locked)
+                    up (&dev->ref.lock);
+               return -EINTR;
+          }
+
+          if (!locked)
+               up (&dev->ref.lock);
+     }
+
+     *ret_ref = ref;
+
+     return 0;
+}
+
+static void
+unlock_ref (FusionRef *ref)
+{
+     up (&ref->lock);
+}
+
+static int
+add_local (FusionRef *ref, int fusion_id, int add)
+{
+     FusionLink *l;
+     LocalRef   *local;
+
+     fusion_list_foreach (l, ref->local_refs) {
+          local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               fusion_list_move_to_front( &ref->local_refs, l );
+
+               if (local->refs + add < 0)
+                    return -EIO;
+
+               local->refs += add;
+               return 0;
+          }
+     }
+
+     local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+     if (!local)
+          return -ENOMEM;
+
+     local->fusion_id = fusion_id;
+     local->refs      = add;
+
+     fusion_list_prepend (&ref->local_refs, &local->link);
+
+     return 0;
+}
+
+static void
+clear_local (FusionDev *dev, FusionRef *ref, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&ref->lock);
+
+     if (ref->locked == fusion_id) {
+          ref->locked = 0;
+          wake_up_interruptible_all (&ref->wait);
+     }
+
+     fusion_list_foreach (l, ref->local_refs) {
+          LocalRef *local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               if (local->refs)
+                    propagate_local( dev, ref, - local->refs );
+
+               fusion_list_remove( &ref->local_refs, l );
+
+               kfree (l);
+               break;
+          }
+     }
+
+     up (&ref->lock);
+}
+
+static void
+free_all_local (FusionRef *ref)
+{
+     FusionLink *l = ref->local_refs;
+
+     while (l) {
+          FusionLink *next = l->next;
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->local_refs = NULL;
+}
+
+static void
+notify_ref (FusionDev *dev, FusionRef *ref)
+{
+     if (ref->watched) {
+          FusionCallExecute execute;
+
+          execute.call_id  = ref->call_id;
+          execute.call_arg = ref->call_arg;
+          execute.call_ptr = NULL;
+
+          fusion_call_execute (dev, 0, &execute);
+     }
+     else
+          wake_up_interruptible_all (&ref->wait);
+}
+
+static int
+propagate_local( FusionDev *dev, FusionRef *ref, int diff )
+{
+     FusionLink *l;
+
+     /* Recurse into inheritors. */
+     fusion_list_foreach (l, ref->inheritors) {
+          FusionRef *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: propagate_local() interrupted!\n" );
+               //return -EINTR;
+          }
+
+          propagate_local( dev, inheritor, diff );
+
+          up( &inheritor->lock );
+     }
+
+     /* Apply difference. */
+     ref->local += diff;
+
+     /* Notify zero count. */
+     if (ref->local + ref->global == 0)
+          notify_ref( dev, ref );
+
+     return 0;
+}
+
+static int
+add_inheritor(FusionRef *ref, FusionRef *from)
+{
+     Inheritor *inheritor;
+
+     inheritor = kmalloc (sizeof(Inheritor), GFP_KERNEL);
+     if (!inheritor)
+          return -ENOMEM;
+
+     inheritor->ref = ref;
+
+     fusion_list_prepend( &from->inheritors, &inheritor->link );
+
+     return 0;
+}
+
+static void
+remove_inheritor(FusionRef *ref, FusionRef *from)
+{
+     FusionLink *l;
+
+     down( &from->lock );
+
+     fusion_list_foreach (l, from->inheritors) {
+          Inheritor *inheritor = (Inheritor*) l;
+
+          if (inheritor->ref == ref) {
+               fusion_list_remove( &from->inheritors, &inheritor->link );
+
+               kfree( l );
+               break;
+          }
+     }
+
+     up( &from->lock );
+}
+
+static void
+drop_inheritors( FusionDev *dev, FusionRef *ref )
+{
+     FusionLink *l = ref->inheritors;
+
+     while (l) {
+          FusionLink *next      = l->next;
+          FusionRef  *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: drop_inheritors() interrupted!\n" );
+               //return;
+          }
+
+          propagate_local( dev, inheritor, - ref->local );
+
+          inheritor->inherited = NULL;
+
+          up( &inheritor->lock );
+
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->inheritors = NULL;
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/ref.h linux-2.6.12/drivers/char/fusion/ref.h
--- linux-2.6.12.orig/drivers/char/fusion/ref.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/ref.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__REF_H__
+#define __FUSION__REF_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_ref_init   (FusionDev *dev);
+void fusion_ref_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_ref_new          (FusionDev      *dev,
+                             int            *id);
+
+int fusion_ref_up           (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_down         (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_lock    (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_trylock (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_unlock       (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_stat         (FusionDev      *dev,
+                             int             id,
+                             int            *refs);
+
+int fusion_ref_watch        (FusionDev      *dev,
+                             int             id,
+                             int             call_id,
+                             int             call_arg);
+
+int fusion_ref_inherit      (FusionDev      *dev,
+                             int             id,
+                             int             from);
+
+int fusion_ref_destroy      (FusionDev      *dev,
+                             int             id);
+
+
+/* internal functions */
+
+void fusion_ref_clear_all_local (FusionDev *dev,
+                                 int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/skirmish.c linux-2.6.12/drivers/char/fusion/skirmish.c
--- linux-2.6.12.orig/drivers/char/fusion/skirmish.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/skirmish.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,246 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "skirmish.h"
+
+
+typedef struct {
+     FusionEntry        entry;
+
+     int                lock_fid;  /* non-zero if locked */
+     int                lock_pid;
+     int                lock_count;
+
+     int                lock_total;
+} FusionSkirmish;
+
+static int
+fusion_skirmish_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     int             written;
+     FusionSkirmish *skirmish = (FusionSkirmish*) entry;
+
+     written = sprintf( buf, "%6dx total", skirmish->lock_total );
+
+     if (skirmish->lock_fid)
+          return sprintf( buf + written, ", now %dx by 0x%08x (%d)\n",
+                          skirmish->lock_count, skirmish->lock_fid, skirmish->lock_pid) + written;
+
+     return sprintf( buf + written, "\n" ) + written;
+}
+
+FUSION_ENTRY_CLASS( FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print )
+
+/******************************************************************************/
+
+int
+fusion_skirmish_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->skirmish, &skirmish_class, dev );
+
+     create_proc_read_entry( "skirmishs", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->skirmish );
+
+     return 0;
+}
+
+void
+fusion_skirmish_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("skirmishs", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->skirmish );
+}
+
+/******************************************************************************/
+
+int
+fusion_skirmish_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->skirmish, ret_id );
+}
+
+int
+fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     if (skirmish->lock_pid == current->pid) {
+          skirmish->lock_count++;
+          skirmish->lock_total++;
+          fusion_skirmish_unlock( skirmish );
+          return 0;
+     }
+
+     while (skirmish->lock_pid) {
+          ret = fusion_skirmish_wait( skirmish, NULL );
+          if (ret)
+               return ret;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     if (skirmish->lock_fid) {
+          if (skirmish->lock_pid == current->pid) {
+               skirmish->lock_count++;
+               skirmish->lock_total++;
+               fusion_skirmish_unlock( skirmish );
+               return 0;
+          }
+
+          fusion_skirmish_unlock( skirmish );
+
+          return -EAGAIN;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_dismiss++;
+
+     if (skirmish->lock_pid != current->pid) {
+          fusion_skirmish_unlock( skirmish );
+          return -EIO;
+     }
+
+     if (--skirmish->lock_count == 0) {
+          skirmish->lock_fid = 0;
+          skirmish->lock_pid = 0;
+
+          fusion_skirmish_notify( skirmish, true );
+     }
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->skirmish, id );
+}
+
+void
+fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_fid == fusion_id) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
+void
+fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_pid == pid) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/skirmish.h linux-2.6.12/drivers/char/fusion/skirmish.h
--- linux-2.6.12.orig/drivers/char/fusion/skirmish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/skirmish.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,57 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__SKIRMISH_H__
+#define __FUSION__SKIRMISH_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_skirmish_init   (FusionDev *dev);
+void fusion_skirmish_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_skirmish_new     (FusionDev *dev,
+                             int       *id);
+
+int fusion_skirmish_prevail (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_swoop   (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_dismiss (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_destroy (FusionDev *dev,
+                             int        id);
+
+
+/* internal functions */
+
+void fusion_skirmish_dismiss_all (FusionDev *dev,
+                                  int        fusion_id);
+
+void fusion_skirmish_dismiss_all_from_pid (FusionDev *dev,
+                                           int        pid);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/types.h linux-2.6.12/drivers/char/fusion/types.h
--- linux-2.6.12.orig/drivers/char/fusion/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/types.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__TYPES_H__
+#define __FUSION__TYPES_H__
+
+typedef enum {
+  false = 0,
+  true  = !false
+} bool;
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/vt.c linux-2.6.12/drivers/char/vt.c
--- linux-2.6.12.orig/drivers/char/vt.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/vt.c	2005-06-27 11:31:27.000000000 +0200
@@ -158,7 +158,8 @@
 int console_blanked;
 
 static int vesa_blank_mode; /* 0:none 1:suspendV 2:suspendH 3:powerdown */
-static int blankinterval = 10*60*HZ;
+//static int blankinterval = 10*60*HZ;
+static int blankinterval = 0;
 static int vesa_off_interval;
 
 static DECLARE_WORK(console_work, console_callback, NULL);
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/i2c/busses/i2c-ibm_iic.c linux-2.6.12/drivers/i2c/busses/i2c-ibm_iic.c
--- linux-2.6.12.orig/drivers/i2c/busses/i2c-ibm_iic.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/i2c/busses/i2c-ibm_iic.c	2005-06-27 03:14:24.000000000 +0200
@@ -20,6 +20,10 @@
  *
  *   	With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> 
  *	and even Frodo Looijaard <frodol@dds.nl>
+ *  and more changes by Uli.H
+ *  - more stable, (kernel-reboot was needed after bus hang)
+ *  - introduced "I2C_CLIENT_FAST" to switch 100/400 kHz on the fly
+ *  - bitbanging not possible with stb04500 hardware
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -45,18 +49,40 @@
 
 #include "i2c-ibm_iic.h"
 
-#define DRIVER_VERSION "2.1"
+#define DRIVER_VERSION "3.1"
 
 MODULE_DESCRIPTION("IBM IIC driver v" DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
-static int iic_force_poll;
-module_param(iic_force_poll, bool, 0);
+static int iic_force_poll = 0;
+MODULE_PARM(iic_force_poll, "i");
 MODULE_PARM_DESC(iic_force_poll, "Force polling mode");
 
-static int iic_force_fast;
-module_param(iic_force_fast, bool, 0);
-MODULE_PARM_DESC(iic_fast_poll, "Force fast mode (400 kHz)");
+static int iic_force_fast = 0;
+MODULE_PARM(iic_force_fast, "i");
+MODULE_PARM_DESC(iic_force_fast, "Force fast mode (400 kHz)");
+
+#define ansi_n "\x1b[0m"
+
+#define ansi_red "\x1b[31m"
+#define ansi_grn "\x1b[32m"
+#define ansi_yel "\x1b[33m"
+#define ansi_blu "\x1b[34m"
+#define ansi_mgn "\x1b[35m"
+#define ansi_cya "\x1b[36m"
+#define ansi_wht "\x1b[37m"
+
+#define ansi_redlight "\x1b[1;31m"
+#define ansi_grnlight "\x1b[1;32m"
+#define ansi_yellight "\x1b[1;33m"
+#define ansi_blulight "\x1b[1;34m"
+#define ansi_mgnlight "\x1b[1;35m"
+#define ansi_cyalight "\x1b[1;36m"
+#define ansi_whtlight "\x1b[1;37m"
+
+//--------------------------------------------------------------------------
+#define EPRINTK( format, args... ) printk( ansi_redlight "\r[%s] " ansi_n "Error: " format, __FUNCTION__, ##args )
+
 
 #define DBG_LEVEL 0
 
@@ -81,360 +107,212 @@
 #if DBG_LEVEL > 2
 static void dump_iic_regs(const char* header, struct ibm_iic_private* dev)
 {
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
+	volatile struct iic_regs *iic = dev->vaddr;
 	printk(KERN_DEBUG "ibm-iic%d: %s\n", dev->idx, header);
 	printk(KERN_DEBUG "  cntl     = 0x%02x, mdcntl = 0x%02x\n"
 	       KERN_DEBUG "  sts      = 0x%02x, extsts = 0x%02x\n"
 	       KERN_DEBUG "  clkdiv   = 0x%02x, xfrcnt = 0x%02x\n"
-	       KERN_DEBUG "  xtcntlss = 0x%02x, directcntl = 0x%02x\n",
+	       KERN_DEBUG "  xtcntlss = 0x%02x\n",
 		in_8(&iic->cntl), in_8(&iic->mdcntl), in_8(&iic->sts), 
 		in_8(&iic->extsts), in_8(&iic->clkdiv), in_8(&iic->xfrcnt), 
-		in_8(&iic->xtcntlss), in_8(&iic->directcntl));
+		in_8(&iic->xtcntlss));
 }
 #  define DUMP_REGS(h,dev)	dump_iic_regs((h),(dev))
 #else
 #  define DUMP_REGS(h,dev)	((void)0)
 #endif
 
-/* Bus timings (in ns) for bit-banging */
-static struct i2c_timings {
-	unsigned int hd_sta;
-	unsigned int su_sto;
-	unsigned int low;
-	unsigned int high;
-	unsigned int buf;
-} timings [] = {
-/* Standard mode (100 KHz) */
-{
-	.hd_sta	= 4000,
-	.su_sto	= 4000,
-	.low	= 4700,
-	.high	= 4000,
-	.buf	= 4700,
-},
-/* Fast mode (400 KHz) */
-{
-	.hd_sta = 600,
-	.su_sto	= 600,
-	.low 	= 1300,
-	.high 	= 600,
-	.buf	= 1300,
-}};
-
-/* Enable/disable interrupt generation */
-static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)
-{
-	out_8(&dev->vaddr->intmsk, enable ? INTRMSK_EIMTC : 0);
-}
- 
-/*
- * Initialize IIC interface.
- */
-static void iic_dev_init(struct ibm_iic_private* dev)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
-
-	DBG("%d: init\n", dev->idx);
-	
-	/* Clear master address */
-	out_8(&iic->lmadr, 0);
-	out_8(&iic->hmadr, 0);
-
-	/* Clear slave address */
-	out_8(&iic->lsadr, 0);
-	out_8(&iic->hsadr, 0);
-
-	/* Clear status & extended status */
-	out_8(&iic->sts, STS_SCMP | STS_IRQA);
-	out_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | EXTSTS_LA
-			    | EXTSTS_ICT | EXTSTS_XFRA);
-
-	/* Set clock divider */
-	out_8(&iic->clkdiv, dev->clckdiv);
 
-	/* Clear transfer count */
-	out_8(&iic->xfrcnt, 0);
+//--------------------------------------------------------------------------
+#define SLEEP(ms) ( { current->state = TASK_INTERRUPTIBLE; \
+		schedule_timeout( (HZ * ms) / 1000 ); } )
 
-	/* Clear extended control and status */
-	out_8(&iic->xtcntlss, XTCNTLSS_SRC | XTCNTLSS_SRS | XTCNTLSS_SWC
-			    | XTCNTLSS_SWS);
 
-	/* Clear control register */
-	out_8(&iic->cntl, 0);
+//--------------------------------------------------------------------------
+//--------------------------------------------------------------------------
+static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable);
+static void iic_abort_xfer(struct ibm_iic_private* dev);
+static int iic_wait_for_tc(struct ibm_iic_private* dev);
+static int iic_xfer_result(struct ibm_iic_private* dev);
+static int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm, int combined_xfer);
+static inline void iic_address(struct ibm_iic_private* dev, struct i2c_msg* msg);
+static int iic_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], signed int num);
 	
-	/* Enable interrupts if possible */
-	iic_interrupt_mode(dev, dev->irq >= 0);
 
-	/* Set mode control */
-	out_8(&iic->mdcntl, MDCNTL_FMDB | MDCNTL_EINT | MDCNTL_EUBS
-			    | (dev->fast_mode ? MDCNTL_FSM : 0));
 
-	DUMP_REGS("iic_init", dev);
+//--------------------------------------------------------------------------
+//--------------------------------------------------------------------------
+// Enable/disable interrupt generation
+static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable) {
+	out_8(&dev->vaddr->intmsk, enable ? INTRMSK_EIMTC : 0);
 }
 
-/* 
- * Reset IIC interface
- */
-static void iic_dev_reset(struct ibm_iic_private* dev)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
-	int i;
-	u8 dc;
-	
-	DBG("%d: soft reset\n", dev->idx);
-	DUMP_REGS("reset", dev);
-	
-    	/* Place chip in the reset state */
-	out_8(&iic->xtcntlss, XTCNTLSS_SRST);
-	
-	/* Check if bus is free */
-	dc = in_8(&iic->directcntl);	
-	if (!DIRCTNL_FREE(dc)){
-		DBG("%d: trying to regain bus control\n", dev->idx);
-	
-		/* Try to set bus free state */
-		out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);	
 	
-		/* Wait until we regain bus control */
-		for (i = 0; i < 100; ++i){
-			dc = in_8(&iic->directcntl);
-			if (DIRCTNL_FREE(dc))
-				break;
-			
-			/* Toggle SCL line */
-			dc ^= DIRCNTL_SCC;
-			out_8(&iic->directcntl, dc);
-			udelay(10);
-			dc ^= DIRCNTL_SCC;
-			out_8(&iic->directcntl, dc);
-			
-			/* be nice */
-			cond_resched();
-		}
-	}
+//--------------------------------------------------------------------------
+// Initialize IIC interface.
+static void iic_dev_init(struct ibm_iic_private* dev) {
+	volatile struct iic_regs *iic = dev->vaddr;
 	
-	/* Remove reset */
-	out_8(&iic->xtcntlss, 0);
+	out_8(&iic->lmadr, 0);																	// Clear master address
+	out_8(&iic->hmadr, 0);
 	
-	/* Reinitialize interface */
-	iic_dev_init(dev);
-}
+	out_8(&iic->lsadr, 0);																	// Clear slave address
+	out_8(&iic->hsadr, 0);
 
-/*
- * Do 0-length transaction using bit-banging through IIC_DIRECTCNTL register.
- */
+	out_8(&iic->sts, STS_SCMP | STS_IRQA);													// Clear status & extended status
+	out_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | EXTSTS_LA | EXTSTS_ICT | EXTSTS_XFRA);
 
-/* Wait for SCL and/or SDA to be high */
-static int iic_dc_wait(volatile struct iic_regs __iomem *iic, u8 mask)
-{
-	unsigned long x = jiffies + HZ / 28 + 2;
-	while ((in_8(&iic->directcntl) & mask) != mask){
-		if (unlikely(time_after(jiffies, x)))
-			return -1;
-		cond_resched();
-	}
-	return 0;
-}
+	out_8(&iic->clkdiv, dev->clckdiv);														// Set clock divider
+	out_8(&iic->xfrcnt, 0);																	// Clear transfer count
+	out_8(&iic->xtcntlss, XTCNTLSS_SRC | XTCNTLSS_SRS | XTCNTLSS_SWC | XTCNTLSS_SWS);		// Clear extended control and status
+	out_8(&iic->cntl, 0);																	// Clear control register
+	iic_interrupt_mode(dev, dev->irq >= 0);													// Enable interrupts if possible
 
-static int iic_smbus_quick(struct ibm_iic_private* dev, const struct i2c_msg* p)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
-	const struct i2c_timings* t = &timings[dev->fast_mode ? 1 : 0];
-	u8 mask, v, sda;
-	int i, res;
+	/* Set mode control */
+	out_8(&iic->mdcntl, MDCNTL_FMDB | MDCNTL_EINT | MDCNTL_EUBS | (dev->fast_mode_enable ? MDCNTL_FSM : 0));
 
-	/* Only 7-bit addresses are supported */
-	if (unlikely(p->flags & I2C_M_TEN)){
-		DBG("%d: smbus_quick - 10 bit addresses are not supported\n",
-			dev->idx);
-		return -EINVAL;
 	}
 
-	DBG("%d: smbus_quick(0x%02x)\n", dev->idx, p->addr);
-
-	/* Reset IIC interface */
-	out_8(&iic->xtcntlss, XTCNTLSS_SRST);
 
-	/* Wait for bus to become free */
-	out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);
-	if (unlikely(iic_dc_wait(iic, DIRCNTL_MSDA | DIRCNTL_MSC)))
-		goto err;
-	ndelay(t->buf);
-
-	/* START */
-	out_8(&iic->directcntl, DIRCNTL_SCC);
-	sda = 0;
-	ndelay(t->hd_sta);
-
-	/* Send address */
-	v = (u8)((p->addr << 1) | ((p->flags & I2C_M_RD) ? 1 : 0));
-	for (i = 0, mask = 0x80; i < 8; ++i, mask >>= 1){
-		out_8(&iic->directcntl, sda);
-		ndelay(t->low / 2);
-		sda = (v & mask) ? DIRCNTL_SDAC : 0;
-		out_8(&iic->directcntl, sda);
-		ndelay(t->low / 2);
+//--------------------------------------------------------------------------
+// Reset IIC interface
+static void iic_dev_reset(struct ibm_iic_private* dev) {
+	volatile struct iic_regs *iic = dev->vaddr;
+	unsigned int tmout;
 
-		out_8(&iic->directcntl, DIRCNTL_SCC | sda);
-		if (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))
-			goto err;
-		ndelay(t->high);
+	//printk( "\x1b[1;31m" "bus %d: soft reset\n" "\x1b[0m", dev->idx );
+	out_8(&iic->mdcntl, in_8(&iic->mdcntl) | 0x02 );										// EUBS (exit unknown bus state) (no effect if chip is not in this state)
+	out_8(&iic->xtcntlss, XTCNTLSS_SRST);													// Place chip in the reset state
+	tmout = jiffies+10;
+	while( tmout > jiffies ) in_8(&iic->xtcntlss);
+	out_8(&iic->xtcntlss, XTCNTLSS_SRC | XTCNTLSS_SRS | XTCNTLSS_SWC | XTCNTLSS_SWS);
+	iic_dev_init(dev);
 	}
 
-	/* ACK */
-	out_8(&iic->directcntl, sda);
-	ndelay(t->low / 2);
-	out_8(&iic->directcntl, DIRCNTL_SDAC);
-	ndelay(t->low / 2);
-	out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);
-	if (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))
-		goto err;
-	res = (in_8(&iic->directcntl) & DIRCNTL_MSDA) ? -EREMOTEIO : 1;
-	ndelay(t->high);
 
-	/* STOP */
-	out_8(&iic->directcntl, 0);
-	ndelay(t->low);
-	out_8(&iic->directcntl, DIRCNTL_SCC);
-	if (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))
-		goto err;
-	ndelay(t->su_sto);
-	out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);
-
-	ndelay(t->buf);
-
-	DBG("%d: smbus_quick -> %s\n", dev->idx, res ? "NACK" : "ACK");
-out:
-	/* Remove reset */
-	out_8(&iic->xtcntlss, 0);
-
-	/* Reinitialize interface */
-	iic_dev_init(dev);
-
-	return res;
-err:
-	DBG("%d: smbus_quick - bus is stuck\n", dev->idx);
-	res = -EREMOTEIO;
-	goto out;
-}
 
-/*
- * IIC interrupt handler
- */
-static irqreturn_t iic_handler(int irq, void *dev_id, struct pt_regs *regs)
-{
+//--------------------------------------------------------------------------
+// IIC interrupt handler
+//--------------------------------------------------------------------------
+static irqreturn_t iic_handler(int irq, void *dev_id, struct pt_regs *regs) {
 	struct ibm_iic_private* dev = (struct ibm_iic_private*)dev_id;
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
+	volatile struct iic_regs* iic = dev->vaddr;
 	
-	DBG2("%d: irq handler, STS = 0x%02x, EXTSTS = 0x%02x\n", 
-	     dev->idx, in_8(&iic->sts), in_8(&iic->extsts));
+//	DBG2("%d: irq handler, STS = 0x%02x, EXTSTS = 0x%02x\n", dev->idx, in_8(&iic->sts), in_8(&iic->extsts));
 	
-	/* Acknowledge IRQ and wakeup iic_wait_for_tc */
-	out_8(&iic->sts, STS_IRQA | STS_SCMP);
+	out_8(&iic->sts, STS_IRQA | STS_SCMP);									// Acknowledge IRQ and wakeup iic_wait_for_tc
 	wake_up_interruptible(&dev->wq);
-	
-	return IRQ_HANDLED;
+	return(IRQ_HANDLED);
 }
 
-/*
- * Get master transfer result and clear errors if any.
- * Returns the number of actually transferred bytes or error (<0)
- */
-static int iic_xfer_result(struct ibm_iic_private* dev)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;	
+
+//--------------------------------------------------------------------------
+// Get master transfer result and clear errors if any.
+// Returns the number of actually transferred bytes or error (<0)
+//--------------------------------------------------------------------------
+static int iic_xfer_result(struct ibm_iic_private* dev) {
+	volatile struct iic_regs *iic = dev->vaddr;
 	
 	if (unlikely(in_8(&iic->sts) & STS_ERR)){
-		DBG("%d: xfer error, EXTSTS = 0x%02x\n", dev->idx, 
-			in_8(&iic->extsts));
+		// we also come here if we try to address unknown device
+		// printk("%d: xfer error, EXTSTS = 0x%02x\n", dev->idx, in_8(&iic->extsts));
 				
-		/* Clear errors and possible pending IRQs */
-		out_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | 
-			EXTSTS_LA | EXTSTS_ICT | EXTSTS_XFRA);
+		// Clear errors and possible pending IRQs
+		out_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | EXTSTS_LA | EXTSTS_ICT | EXTSTS_XFRA);
 			
-		/* Flush master data buffer */
+		// Flush master data buffer
 		out_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);
 		
-		/* Is bus free?
-		 * If error happened during combined xfer
-		 * IIC interface is usually stuck in some strange
-		 * state, the only way out - soft reset.
-		 */
+		// Is bus free?
+		// If error happened during combined xfer
+		// IIC interface is usually stuck in some strange
+		// state, the only way out - soft reset.
 		if ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
-			DBG("%d: bus is stuck, resetting\n", dev->idx);
+			printk("** bus %d is stuck, resetting **\n", dev->idx);
 			iic_dev_reset(dev);
 		}
-		return -EREMOTEIO;
+		return(-EREMOTEIO);
+	} else {
+		return(in_8(&iic->xfrcnt) & XFRCNT_MTC_MASK);
 	}
-	else
-		return in_8(&iic->xfrcnt) & XFRCNT_MTC_MASK;
 }
 
-/*
- * Try to abort active transfer.
- */
-static void iic_abort_xfer(struct ibm_iic_private* dev)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
+//--------------------------------------------------------------------------
+// Try to abort active transfer.
+//--------------------------------------------------------------------------
+static void iic_abort_xfer(struct ibm_iic_private* dev) {
+	volatile struct iic_regs *iic = dev->vaddr;
 	unsigned long x;
 	
-	DBG("%d: iic_abort_xfer\n", dev->idx);
-	
 	out_8(&iic->cntl, CNTL_HMT);
 	
-	/*
-	 * Wait for the abort command to complete.
-	 * It's not worth to be optimized, just poll (timeout >= 1 tick)
-	 */
+	// Wait for the abort command to complete.
+	// It's not worth to be optimized, just poll (timeout >= 1 tick)
 	x = jiffies + 2;
 	while ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
 		if (time_after(jiffies, x)){
-			DBG("%d: abort timeout, resetting...\n", dev->idx);
+			EPRINTK("abort timeout, resetting (index %d)\n", dev->idx);
 			iic_dev_reset(dev);
 			return;
 		}
 		schedule();
 	}
-
-	/* Just to clear errors */
-	iic_xfer_result(dev);
+	iic_xfer_result(dev);													// Just to clear errors
 }
 
-/*
- * Wait for master transfer to complete.
- * It puts current process to sleep until we get interrupt or timeout expires.
- * Returns the number of transferred bytes or error (<0)
- */
+
+//--------------------------------------------------------------------------
+// Wait for master transfer to complete.
+// It puts current process to sleep until we get interrupt or timeout expires.
+// Returns the number of transferred bytes or error (<0)
+//--------------------------------------------------------------------------
 static int iic_wait_for_tc(struct ibm_iic_private* dev){
+	unsigned long xc;
+	signed int ret = 0;
+	volatile struct iic_regs *iic = dev->vaddr;
 	
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
-	int ret = 0;
+	if( dev->irq >= 0 ) {													// Interrupt mode
+		wait_queue_t wait;
+		init_waitqueue_entry(&wait, current);
 	
-	if (dev->irq >= 0){
-		/* Interrupt mode */
-		ret = wait_event_interruptible_timeout(dev->wq, 
-			!(in_8(&iic->sts) & STS_PT), dev->adap.timeout * HZ);
+		add_wait_queue(&dev->wq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
 
-		if (unlikely(ret < 0))
-			DBG("%d: wait interrupted\n", dev->idx);
-		else if (unlikely(in_8(&iic->sts) & STS_PT)){
-			DBG("%d: wait timeout\n", dev->idx);
-			ret = -ETIMEDOUT;
+		if( in_8(&iic->sts) & STS_PT ) {									// if transfer pending
+			schedule_timeout(dev->adap.timeout * HZ);
 		}
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&dev->wq, &wait);
+
+		if( signal_pending(current) ) {
+			EPRINTK( "wait interrupted\n" );
+			ret = -ERESTARTSYS;
+
+		} else if( in_8(&iic->sts) & STS_PT ) {
+			EPRINTK( "wait timeout, sts: 0x%.2X, extsts: 0x%.2X\n", in_8(&iic->sts), in_8(&iic->extsts ) );
+//			printk( "Control     : 0x%.2X\n", in_8(&iic->cntl) );
+//			printk( "Mode Control: 0x%.2X\n", in_8(&iic->mdcntl) );
+//			printk( "LSA         : 0x%.2X\n", in_8(&iic->lsadr) );
+//			printk( "HSA         : 0x%.2X\n", in_8(&iic->hsadr) );
+//			printk( "CLKDIV      : 0x%.2X\n", in_8(&iic->clkdiv) );
+//			printk( "INTEN       : 0x%.2X\n", in_8(&iic->intmsk) );
+//			printk( "TCNT        : 0x%.2X\n", in_8(&iic->xfrcnt) );
+//			printk( "ECSS        : 0x%.2X\n", in_8(&iic->xtcntlss) );
+			ret = -ETIMEDOUT;
 	}
-	else {
-		/* Polling mode */
-		unsigned long x = jiffies + dev->adap.timeout * HZ;
 		
-		while (in_8(&iic->sts) & STS_PT){
-			if (unlikely(time_after(jiffies, x))){
-				DBG("%d: poll timeout\n", dev->idx);
+	} else {																// Polling mode
+		xc = jiffies + dev->adap.timeout * HZ;
+
+		while( in_8(&iic->sts) & STS_PT ) {									// while transfer pending (PXFER)
+			if( time_after(jiffies, xc) ) {
+				EPRINTK( "poll timeout, idx %d\n", dev->idx );
 				ret = -ETIMEDOUT;
 				break;
 			}
 		
-			if (unlikely(signal_pending(current))){
-				DBG("%d: poll interrupted\n", dev->idx);
+			if( signal_pending(current) ) {
+				EPRINTK( "poll interrupted, idx %d\n", dev->idx );
 				ret = -ERESTARTSYS;
 				break;
 			}
@@ -442,187 +320,144 @@
 		}	
 	}
 	
-	if (unlikely(ret < 0))
+	if( unlikely(ret < 0) ) {												// also called on ctrl-C for example
 		iic_abort_xfer(dev);
-	else
+	} else {
 		ret = iic_xfer_result(dev);
+	}
 	
-	DBG2("%d: iic_wait_for_tc -> %d\n", dev->idx, ret);
-	
-	return ret;
+	return(ret);
 }
 
-/*
- * Low level master transfer routine
- */
-static int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm, 
-			  int combined_xfer)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
+
+//--------------------------------------------------------------------------
+// Low level master transfer routine
+static int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm, int combined_xfer) {
+	volatile struct iic_regs *iic = dev->vaddr;
+	u8 cmd, cntl;
 	char* buf = pm->buf;
-	int i, j, loops, ret = 0;
-	int len = pm->len;
+	s32 i, j, loops, count, ret = 0;
+	s32 len = pm->len;
 
-	u8 cntl = (in_8(&iic->cntl) & CNTL_AMD) | CNTL_PT;
-	if (pm->flags & I2C_M_RD)
-		cntl |= CNTL_RW;
 	
-	loops = (len + 3) / 4;
+	cntl = (in_8(&iic->cntl) & CNTL_AMD) | CNTL_PT;
+	if( pm->flags & I2C_M_RD ) cntl |= CNTL_RW;
+
+	loops = (len + 3) >> 2;													// use 4-byte transfer
 	for (i = 0; i < loops; ++i, len -= 4){
-		int count = len > 4 ? 4 : len;
-		u8 cmd = cntl | ((count - 1) << CNTL_TCT_SHIFT);
+		count = len > 4 ? 4 : len;
+		cmd = cntl | ((count - 1) << CNTL_TCT_SHIFT);
 		
-		if (!(cntl & CNTL_RW))
-			for (j = 0; j < count; ++j)
-				out_8((void __iomem *)&iic->mdbuf, *buf++);
+		if( !(cntl & CNTL_RW) ) {											// if not a READ
+			for( j = 0; j < count; ++j ) {
+				out_8((volatile u8*)&iic->mdbuf, *buf++);
+			}
+		}
 		
-		if (i < loops - 1)
+		if( i < loops - 1 ) {
 			cmd |= CNTL_CHT;
-		else if (combined_xfer)
+		} else if( combined_xfer ) {
 			cmd |= CNTL_RPST;
+		}
+		out_8(&iic->cntl, cmd);												// Start transfer
 		
-		DBG2("%d: xfer_bytes, %d, CNTL = 0x%02x\n", dev->idx, count, cmd);
-		
-		/* Start transfer */
-		out_8(&iic->cntl, cmd);
-		
-		/* Wait for completion */
-		ret = iic_wait_for_tc(dev);
+		ret = iic_wait_for_tc(dev);											// Wait for completion
 
-		if (unlikely(ret < 0))
+		if( ret < 0 ) {
 			break;
-		else if (unlikely(ret != count)){
-			DBG("%d: xfer_bytes, requested %d, transfered %d\n", 
-				dev->idx, count, ret);
-			
-			/* If it's not a last part of xfer, abort it */
-			if (combined_xfer || (i < loops - 1))
-    				iic_abort_xfer(dev);
-				
+		} else if( ret != count ) {
+			EPRINTK( "xfer_bytes, requested %d, transfered %d (index %d)\n", count, ret, dev->idx );
+			if( combined_xfer || (i < loops - 1) ) iic_abort_xfer(dev);		// If it's not a last part of xfer, abort it
 			ret = -EREMOTEIO;
 			break;				
 		}
 		
-		if (cntl & CNTL_RW)
-			for (j = 0; j < count; ++j)
-				*buf++ = in_8((void __iomem *)&iic->mdbuf);
+		if( cntl & CNTL_RW ) {
+			for( j = 0; j < count; ++j ) {
+				*buf++ = in_8((volatile u8*)&iic->mdbuf);
+			}
+		}
 	}
 	
-	return ret > 0 ? 0 : ret;
+	return(ret > 0 ? 0 : ret);
 }
 
-/*
- * Set target slave address for master transfer
- */
-static inline void iic_address(struct ibm_iic_private* dev, struct i2c_msg* msg)
-{
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
+
+//--------------------------------------------------------------------------
+// Set target slave address for master transfer
+static inline void iic_address(struct ibm_iic_private* dev, struct i2c_msg* msg) {
+	volatile struct iic_regs *iic = dev->vaddr;
 	u16 addr = msg->addr;
 	
-	DBG2("%d: iic_address, 0x%03x (%d-bit)\n", dev->idx, 
-		addr, msg->flags & I2C_M_TEN ? 10 : 7);
+	if( dev->fast_mode_enable ) {
+		out_8(&iic->mdcntl, (in_8(&iic->mdcntl) & 0xef) | ((msg->flags & I2C_CLIENT_FAST)? 0x10 : 0) );
+	}
 	
-	if (msg->flags & I2C_M_TEN){
+	if( unlikely(msg->flags & I2C_M_TEN) ) {
 	    out_8(&iic->cntl, CNTL_AMD);
 	    out_8(&iic->lmadr, addr);
 	    out_8(&iic->hmadr, 0xf0 | ((addr >> 7) & 0x06));
-	}
-	else {
+	} else {
 	    out_8(&iic->cntl, 0);
 	    out_8(&iic->lmadr, addr << 1);
 	}
 }
 
-static inline int iic_invalid_address(const struct i2c_msg* p)
-{
+static inline int iic_invalid_address(const struct i2c_msg* p) {
 	return (p->addr > 0x3ff) || (!(p->flags & I2C_M_TEN) && (p->addr > 0x7f));
 }
 
-static inline int iic_address_neq(const struct i2c_msg* p1, 
-				  const struct i2c_msg* p2)
-{
-	return (p1->addr != p2->addr) 
-		|| ((p1->flags & I2C_M_TEN) != (p2->flags & I2C_M_TEN));
+static inline int iic_address_neq(const struct i2c_msg* p1, const struct i2c_msg* p2) {
+	return( (p1->addr != p2->addr) || ((p1->flags & I2C_M_TEN) != (p2->flags & I2C_M_TEN)) );
 } 
 
-/*
- * Generic master transfer entrypoint. 
- * Returns the number of processed messages or error (<0)
- */
-static int iic_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
-{
-    	struct ibm_iic_private* dev = (struct ibm_iic_private*)(i2c_get_adapdata(adap));
-	volatile struct iic_regs __iomem *iic = dev->vaddr;
-	int i, ret = 0;
 	
-	DBG2("%d: iic_xfer, %d msg(s)\n", dev->idx, num);
+//--------------------------------------------------------------------------
+// Generic master transfer entrypoint.
+// Returns the number of processed messages or error (<0)
+static int iic_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], signed int num) {
+	struct ibm_iic_private* dev = (struct ibm_iic_private*)(i2c_get_adapdata(adap));
+	volatile struct iic_regs *iic = dev->vaddr;
+	signed int i, ret = 0;
 	
-	if (!num)
-		return 0;
+	if( !num ) return(0);
 	
-	/* Check the sanity of the passed messages.
-	 * Uhh, generic i2c layer is more suitable place for such code...
-	 */
-	if (unlikely(iic_invalid_address(&msgs[0]))){
-		DBG("%d: invalid address 0x%03x (%d-bit)\n", dev->idx, 
-			msgs[0].addr, msgs[0].flags & I2C_M_TEN ? 10 : 7);
-		return -EINVAL;
-	}		
+	// Check the sanity of the passed messages.
+	// Uhh, generic i2c layer is more suitable place for such code...
+	if( unlikely(iic_invalid_address(&msgs[0])) ) return(-EINVAL);
 	for (i = 0; i < num; ++i){
-		if (unlikely(msgs[i].len <= 0)){
-			if (num == 1 && !msgs[0].len){
-				/* Special case for I2C_SMBUS_QUICK emulation.
-				 * IBM IIC doesn't support 0-length transactions
-				 * so we have to emulate them using bit-banging.
-				 */
-				return iic_smbus_quick(dev, &msgs[0]);
-			}
-			DBG("%d: invalid len %d in msg[%d]\n", dev->idx, 
-				msgs[i].len, i);
-			return -EINVAL;
-		}
-		if (unlikely(iic_address_neq(&msgs[0], &msgs[i]))){
-			DBG("%d: invalid addr in msg[%d]\n", dev->idx, i);
-			return -EINVAL;
-		}
+		if( unlikely(msgs[i].len <= 0) ) return(-EINVAL);
+		if( unlikely(iic_address_neq(&msgs[0], &msgs[i])) )	return(-EINVAL);
 	}
 	
-	/* Check bus state */
-	if (unlikely((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE)){
-		DBG("%d: iic_xfer, bus is not free\n", dev->idx);
+	if( unlikely((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE) ) {		// Check bus state
+		printk( "%s, Bus %d is not free\n", __FUNCTION__, dev->idx );
+		// Usually it means something serious has happend.
+		// We *cannot* have unfinished previous transfer
+		// so it doesn't make any sense to try to stop it.
+		// Probably we were not able to recover from the
+		// previous error.
+		// The only *reasonable* thing I can think of here
+		// is soft reset.  --ebs
 		
-		/* Usually it means something serious has happend.
-		 * We *cannot* have unfinished previous transfer
-		 * so it doesn't make any sense to try to stop it.
-		 * Probably we were not able to recover from the 
-		 * previous error.
-		 * The only *reasonable* thing I can think of here
-		 * is soft reset.  --ebs
-		 */
 		iic_dev_reset(dev);
-		
 		if ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
-			DBG("%d: iic_xfer, bus is still not free\n", dev->idx);
-			return -EREMOTEIO;
-		}
+			printk( "%s, Bus %d is still not free\n", __FUNCTION__, dev->idx );
+			return(-EREMOTEIO);
 	} 
-	else {
-		/* Flush master data buffer (just in case) */
-		out_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);
+	} else {
+		out_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);						// Flush master data buffer (just in case)
 	}
 	
-	/* Load slave address */
-	iic_address(dev, &msgs[0]);
-	
-	/* Do real transfer */
-    	for (i = 0; i < num && !ret; ++i)
+	iic_address(dev, &msgs[0]);														// Load slave address
+	for( i = 0; i < num && !ret; ++i )												// Do real transfer
 		ret = iic_xfer_bytes(dev, &msgs[i], i < num - 1);
 
-	return ret < 0 ? ret : num;
+	return(ret < 0 ? ret : num);
 }
 
-static u32 iic_func(struct i2c_adapter *adap)
-{
+
+static u32 iic_func(struct i2c_adapter *adap) {
 	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;
 }
 
@@ -630,54 +465,45 @@
 	.name 		= "IBM IIC algorithm",
 	.id   		= I2C_ALGO_OCP,
 	.master_xfer 	= iic_xfer,
+	.smbus_xfer	= NULL,
+	.slave_send	= NULL,
+	.slave_recv	= NULL,
+	.algo_control	= NULL,
 	.functionality	= iic_func
 };
 
-/*
- * Calculates IICx_CLCKDIV value for a specific OPB clock frequency
- */
-static inline u8 iic_clckdiv(unsigned int opb)
-{
-	/* Compatibility kludge, should go away after all cards
-	 * are fixed to fill correct value for opbfreq.
-	 * Previous driver version used hardcoded divider value 4,
-	 * it corresponds to OPB frequency from the range (40, 50] MHz
-	 */
-	if (!opb){
-		printk(KERN_WARNING "ibm-iic: using compatibility value for OPB freq,"
-			" fix your board specific setup\n");
+
+// Calculates IICx_CLCKDIV value for a specific OPB clock frequency
+static inline u8 iic_clckdiv(unsigned int opb) {
+	// Compatibility kludge, should go away after all cards
+	// are fixed to fill correct value for opbfreq.
+	// Previous driver version used hardcoded divider value 4,
+	// it corresponds to OPB frequency from the range (40, 50] MHz
+	if( (opb < 20000000) || (opb > 150000000) ) {
+		EPRINTK(KERN_WARNING "using compatibility value for OPB freq fix your board specific setup\n" );
 		opb = 50000000;
 	}
 
-	/* Convert to MHz */
-	opb /= 1000000;
-	
-	if (opb < 20 || opb > 150){
-		printk(KERN_CRIT "ibm-iic: invalid OPB clock frequency %u MHz\n",
-			opb);
-		opb = opb < 20 ? 20 : 150;
-	}
+	opb /= 1000000;															// Convert to MHz
 	return (u8)((opb + 9) / 10 - 1);
 }
 
-/*
- * Register single IIC interface
- */
-static int __devinit iic_probe(struct ocp_device *ocp){
 
+//--------------------------------------------------------------------------
+// Register single IIC interface
+static int __devinit iic_probe(struct ocp_device *ocp) {
 	struct ibm_iic_private* dev;
 	struct i2c_adapter* adap;
 	struct ocp_func_iic_data* iic_data = ocp->def->additions;
 	int ret;
+	const bd_t * const bip = &__res;
 	
 	if (!iic_data)
-		printk(KERN_WARNING"ibm-iic%d: missing additional data!\n",
-			ocp->def->index);
+		printk( KERN_WARNING "ibm-iic%d: missing additional data!\n", ocp->def->index );
 
 	if (!(dev = kmalloc(sizeof(*dev), GFP_KERNEL))){
-		printk(KERN_CRIT "ibm-iic%d: failed to allocate device data\n",
-			ocp->def->index);
-		return -ENOMEM;
+		printk( KERN_CRIT "ibm-iic%d: failed to allocate device data\n", ocp->def->index );
+		return(-ENOMEM);
 	}
 
 	memset(dev, 0, sizeof(*dev));
@@ -685,84 +511,66 @@
 	ocp_set_drvdata(ocp, dev);
 	
 	if (!(dev->vaddr = ioremap(ocp->def->paddr, sizeof(struct iic_regs)))){
-		printk(KERN_CRIT "ibm-iic%d: failed to ioremap device registers\n",
-			dev->idx);
+		printk(KERN_CRIT "ibm-iic%d: failed to ioremap device registers\n", dev->idx);
 		ret = -ENXIO;
-		goto fail2;
-	}
-	
+	} else {
 	init_waitqueue_head(&dev->wq);
 
 	dev->irq = iic_force_poll ? -1 : ocp->def->irq;
 	if (dev->irq >= 0){
-		/* Disable interrupts until we finish intialization,
-		   assumes level-sensitive IRQ setup...
-		 */
+			// Disable interrupts until we finish intialization,
+			// assumes level-sensitive IRQ setup...
 		iic_interrupt_mode(dev, 0);
 		if (request_irq(dev->irq, iic_handler, 0, "IBM IIC", dev)){
-			printk(KERN_ERR "ibm-iic%d: request_irq %d failed\n", 
-				dev->idx, dev->irq);
-			/* Fallback to the polling mode */	
-			dev->irq = -1;
+				printk(KERN_ERR "ibm-iic%d: request_irq %d failed\n", dev->idx, dev->irq);
+				dev->irq = -1;												// Fallback to the polling mode
 		}
 	}
 	
 	if (dev->irq < 0)
-		printk(KERN_WARNING "ibm-iic%d: using polling mode\n", 
-			dev->idx);
+			printk(KERN_WARNING "ibm-iic%d: using polling mode\n", dev->idx);
 		
-	/* Board specific settings */
-	dev->fast_mode = iic_force_fast ? 1 : (iic_data ? iic_data->fast_mode : 0);
+		dev->fast_mode_enable = iic_force_fast ? 1 : bip->bi_iic_fast[dev->idx];	// Board specific settings
 	
-	/* clckdiv is the same for *all* IIC interfaces, 
-	 * but I'd rather make a copy than introduce another global. --ebs
-	 */
-	dev->clckdiv = iic_clckdiv(ocp_sys_info.opb_bus_freq);
+		// clckdiv is the same for *all* IIC interfaces,
+		// but I'd rather make a copy than introduce another global.
+		dev->clckdiv = iic_clckdiv(bip->bi_opb_busfreq);
 	DBG("%d: clckdiv = %d\n", dev->idx, dev->clckdiv);
 	
-	/* Initialize IIC interface */
-	iic_dev_init(dev);
+		iic_dev_init(dev);													// Initialize IIC interface
 	
-	/* Register it with i2c layer */
-	adap = &dev->adap;
+		adap = &dev->adap;													// Register it with i2c layer
 	strcpy(adap->name, "IBM IIC");
 	i2c_set_adapdata(adap, dev);
 	adap->id = I2C_HW_OCP | iic_algo.id;
 	adap->algo = &iic_algo;
 	adap->client_register = NULL;
 	adap->client_unregister = NULL;
-	adap->timeout = 1;
+		adap->timeout = 1;													// this is 1 Sec.
 	adap->retries = 1;
 
-	if ((ret = i2c_add_adapter(adap)) != 0){
-		printk(KERN_CRIT "ibm-iic%d: failed to register i2c adapter\n",
-			dev->idx);
-		goto fail;
+		if( !(ret = i2c_add_adapter(adap)) ) {
+			printk(KERN_INFO "ibm-iic%d: using %s mode\n", dev->idx, dev->fast_mode_enable? "fast (400 kHz)" : "standard (100 kHz)");
+			return(0);
 	}
 	
-	printk(KERN_INFO "ibm-iic%d: using %s mode\n", dev->idx,
-		dev->fast_mode ? "fast (400 kHz)" : "standard (100 kHz)");
-
-	return 0;
-
-fail:	
+		printk(KERN_CRIT "ibm-iic%d: failed to register i2c adapter\n", dev->idx);
 	if (dev->irq >= 0){
 		iic_interrupt_mode(dev, 0);
 		free_irq(dev->irq, dev);
 	}	
 
-	iounmap(dev->vaddr);
-fail2:	
-	ocp_set_drvdata(ocp, NULL);
+		iounmap((void*)dev->vaddr);
+	}
+	ocp_set_drvdata(ocp, 0);
 	kfree(dev);	
-	return ret;
+	return(ret);
 }
 
-/*
- * Cleanup initialized IIC interface
- */
-static void __devexit iic_remove(struct ocp_device *ocp)
-{
+
+//--------------------------------------------------------------------------
+// Cleanup initialized IIC interface
+static void __devexit iic_remove(struct ocp_device *ocp) {
 	struct ibm_iic_private* dev = (struct ibm_iic_private*)ocp_get_drvdata(ocp);
 	BUG_ON(dev == NULL);
 	if (i2c_del_adapter(&dev->adap)){
@@ -779,21 +587,19 @@
 		    iic_interrupt_mode(dev, 0);	
 		    free_irq(dev->irq, dev);
 		}
-		iounmap(dev->vaddr);
+		iounmap((void*)dev->vaddr);
 		kfree(dev);
 	}
 }
 
-static struct ocp_device_id ibm_iic_ids[] __devinitdata = 
-{
+static struct ocp_device_id ibm_iic_ids[] __devinitdata = {
 	{ .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_IIC },
 	{ .vendor = OCP_VENDOR_INVALID }
 };
 
 MODULE_DEVICE_TABLE(ocp, ibm_iic_ids);
 
-static struct ocp_driver ibm_iic_driver =
-{
+static struct ocp_driver ibm_iic_driver = {
 	.name 		= "iic",
 	.id_table	= ibm_iic_ids,
 	.probe		= iic_probe,
@@ -804,16 +610,16 @@
 #endif
 };
 
-static int __init iic_init(void)
-{
+static int __init iic_init(void) {
 	printk(KERN_INFO "IBM IIC driver v" DRIVER_VERSION "\n");
 	return ocp_register_driver(&ibm_iic_driver);
 }
 
-static void __exit iic_exit(void)
-{
+static void __exit iic_exit(void) {
 	ocp_unregister_driver(&ibm_iic_driver);
 }
 
+//--------------------------------------------------------------------------
 module_init(iic_init);
 module_exit(iic_exit);
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/i2c/busses/i2c-ibm_iic.h linux-2.6.12/drivers/i2c/busses/i2c-ibm_iic.h
--- linux-2.6.12.orig/drivers/i2c/busses/i2c-ibm_iic.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/i2c/busses/i2c-ibm_iic.h	2005-06-26 22:01:52.000000000 +0200
@@ -49,7 +49,7 @@
 	wait_queue_head_t wq;
 	int idx;
 	int irq;
-	int fast_mode;
+	int fast_mode_enable;
 	u8  clckdiv;
 };
 
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/i2c/i2c-core.c linux-2.6.12/drivers/i2c/i2c-core.c
--- linux-2.6.12.orig/drivers/i2c/i2c-core.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/i2c/i2c-core.c	2005-06-27 03:04:16.000000000 +0200
@@ -614,7 +614,7 @@
 
 	if (client->adapter->algo->master_xfer) {
 		msg.addr   = client->addr;
-		msg.flags = client->flags & I2C_M_TEN;
+		msg.flags = client->flags & (I2C_M_TEN | I2C_CLIENT_FAST);
 		msg.len = count;
 		msg.buf = (char *)buf;
 	
@@ -642,7 +642,7 @@
 	int ret;
 	if (client->adapter->algo->master_xfer) {
 		msg.addr   = client->addr;
-		msg.flags = client->flags & I2C_M_TEN;
+		msg.flags = client->flags & (I2C_M_TEN | I2C_CLIENT_FAST);
 		msg.flags |= I2C_M_RD;
 		msg.len = count;
 		msg.buf = buf;
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/ide/Kconfig linux-2.6.12/drivers/ide/Kconfig
--- linux-2.6.12.orig/drivers/ide/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/ide/Kconfig	2005-06-27 22:15:40.000000000 +0200
@@ -928,6 +928,15 @@
 
 endchoice
 
+config BLK_DEV_IDE_STB04xxx
+	tristate "STB04xxx TripleDragon IDE support"
+	depends on BLK_DEV_IDE && IBM_PALLAS
+	help
+	  This option provides support for IDE on IBM STB04xxx Redwood-5
+	  systems.
+
+	  If unsure, say N.
+
 # no isa -> no vlb
 config IDE_CHIPSETS
 	bool "Other IDE chipset support"
@@ -1006,11 +1015,11 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_STB04xxx
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
-	depends on BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	depends on BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_STB04xxx
 	---help---
 	  There are unclear terms in ATA-4 and ATA-5 standards how certain
 	  hardware (an 80c ribbon) should be detected. Different interpretations
@@ -1025,7 +1034,7 @@
 	  It is normally safe to answer Y; however, the default is N.
 
 config IDEDMA_AUTO
-	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO
+	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO || BLK_DEV_IDE_STB04xxx
 
 endif
 
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/ide/Makefile linux-2.6.12/drivers/ide/Makefile
--- linux-2.6.12.orig/drivers/ide/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/ide/Makefile	2005-06-25 03:48:21.000000000 +0200
@@ -37,6 +37,11 @@
 # built-in only drivers from ppc/
 ide-core-$(CONFIG_BLK_DEV_MPC8xx_IDE)	+= ppc/mpc8xx.o
 ide-core-$(CONFIG_BLK_DEV_IDE_PMAC)	+= ppc/pmac.o
+ifeq ($(CONFIG_BLK_DEV_IDE_STB04xxx),y)
+ide-core-$(CONFIG_BLK_DEV_IDE_STB04xxx)	+= ppc/ibm_ocp_ide.o
+else
+obj-$(CONFIG_BLK_DEV_IDE_STB04xxx)	+= ppc/ibm_ocp_ide.o
+endif
 
 # built-in only drivers from h8300/
 ide-core-$(CONFIG_H8300)		+= h8300/ide-h8300.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/ide/ppc/ibm_ocp_ide.c linux-2.6.12/drivers/ide/ppc/ibm_ocp_ide.c
--- linux-2.6.12.orig/drivers/ide/ppc/ibm_ocp_ide.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/ide/ppc/ibm_ocp_ide.c	2005-06-27 23:27:12.000000000 +0200
@@ -0,0 +1,957 @@
+/*
+ * IDE driver for IBM On-chip IDE contollers
+ *    Copyright 2001 - 2002 MontaVista Software Inc.
+ *    Dan Malek.
+ *    2003/2004 Andr Draszik
+ *    I snagged bits and pieces from a variety of drivers, primarily
+ *    ide-pmac.c and ide-dma.c .....thanks to previous authors!
+ *
+ *    Version 1.2 (01/30/12) Armin
+ *    Converted to ocp
+ *    merger up to new ide-timing.h
+ *
+ *    Version 2.0 (05/02/15) - armin
+ *    converted to new core_ocp and only supports one interface for now.
+ *
+ *    Version 2.1 (05/25/02) - armin
+ *      name change from *_driver to *_dev
+ *    Version 2.2 06/13/02 - Armin
+ *      changed irq_resource array to just irq
+ *
+ *    Version 2.3au (June 2003) - andre
+ *      rewrote much of it to fix some serious bugs
+ *
+ *    Version 2.4au (Jan 2004) - andre
+ *      enable DMA read/write from within ide_dma_read/write () hoping
+ *      to fix IDE SCSI and such
+ *
+ *    Version 2.4aw (Jul 2004) - andre
+ *      - finally fix that nasty DMA bug which prevented non hard disk
+ *        devices from working correctly. the driver is kewl now!
+ *      - add white and blacklists from ide-dma.c
+ *      - increase max size of one PRD entry to 65536 bytes
+ *
+ *    Version 2.6aw (Jul 2004) - andre
+ *      - support linux kernels 2.6.x
+ *
+ *    Version 2.6ax (Jul 2004) - andre, uli
+ *      - fix DMA with 2.6.x kernels
+ *
+ *    Versipm 2.73
+ *      - support powerup by tdcore and/or loader
+ *
+ *    Version 2.74 (Juni 2005) - uli
+ *      - support 2.6.12 kernel
+ */
+
+//#define _LDEBUG_
+#define fprintk(x...)  ( { } )
+
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/version.h>
+#include <ide-timing.h>
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/dma-mapping.h>
+
+
+#include "/projects/stb/drivers/include/os/registerio.h"
+#include "/projects/stb/drivers/include/os/os-generic.h"
+
+#define _DRV_NAME_		"\rSTB04500 OCP IDE"
+#define _DRV_VERSION_	"2.74"
+
+#include "/projects/stb/drivers/include/os/pversion.h"
+
+
+//--------------------------------------------------------------------------
+static s32 ide_debug = 0;
+module_param(ide_debug, int, 0644);
+MODULE_PARM_DESC(ide_debug, "IDE debugging level (default = 0)");
+
+//--------------------------------------------------------------------------
+#define FPRINTK( format, args... ) printk( format, ##args )
+#define DPRINTK( format, args... ) printk( "\r\x1b[34m[%s] \x1b[0m" format, __FUNCTION__, ##args )
+#define EPRINTK( format, args... ) printk( "\r\x1b[1;31m[%s] \x1b[0mError: " format, __FUNCTION__, ##args )
+
+
+//--------------------------------------------------------------------------
+static void stb04xxx_init_ocp_ide(ide_hwif_t * const hwif);
+static void stb04xxx_dma_start(ide_drive_t * const drive);
+
+
+//--------------------------------------------------------------------------
+//--------------------------------------------------------------------------
+/****************************************************************
+* #define SLEEP(ms) ( { current->state = TASK_INTERRUPTIBLE; \  *
+*         schedule_timeout(((HZ / 100) * ms) / 10); } )         *
+****************************************************************/
+
+//--------------------------------------------------------------------------
+#define MK_TIMING(AS, DIOP, DIOY, DH) \
+	((FIT((AS),    0, 0x0f) << 27) | \
+	 (FIT((DIOP),  0, 0x3f) << 20) | \
+	 (FIT((DIOY),  0, 0x3f) << 13) | \
+	 (FIT((DH),    0, 0x07) <<  9))
+
+#define UTIMING_SETHLD	(EZ(20 /*tACK*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_ENV	(EZ(20 /*tENV*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_SS	(EZ(50 /*tSS */, SYS_CLOCK_NS) - 3 /*fixed cycles*/)
+
+#define MK_UTIMING(CYC, RP) \
+	((FIT(UTIMING_SETHLD, 0, 0x0f) << 27) | \
+	 (FIT(UTIMING_ENV,    0, 0x0f) << 22) | \
+	 (FIT((CYC),          0, 0x0f) << 17) | \
+	 (FIT((RP),           0, 0x3f) << 10) | \
+	 (FIT(UTIMING_SS,     0, 0x0f) <<  5) | \
+	 1 /* Turn on Ultra DMA */)
+
+/* Define the period of the STB clock used to generate the
+ * IDE bus timing.  The clock is actually 63 MHz, but it
+ * gets rounded in a favorable direction.
+ */
+#define IDE_SYS_FREQ	63	/* MHz */
+#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)   /* 1takt == SYS_CLOCK_NS nanosekunden */
+
+struct whold_timing {
+	short mode;
+	short whold;
+};
+
+static const struct whold_timing whold_timing[] = {
+
+	{XFER_UDMA_5, 0},
+	{XFER_UDMA_4, 0},
+	{XFER_UDMA_3, 0},
+
+	{XFER_UDMA_2, 0},
+	{XFER_UDMA_1, 0},
+	{XFER_UDMA_0, 0},
+
+	{XFER_UDMA_SLOW, 0},
+
+	{XFER_MW_DMA_2, 0},
+	{XFER_MW_DMA_1, 0},
+	{XFER_MW_DMA_0, 0},
+
+	{XFER_SW_DMA_2, 0},
+	{XFER_SW_DMA_1, 0},
+	{XFER_SW_DMA_0, 10},
+
+	{XFER_PIO_5, 10},
+	{XFER_PIO_4, 10},
+	{XFER_PIO_3, 15},
+
+	{XFER_PIO_2, 20},
+	{XFER_PIO_1, 30},
+	{XFER_PIO_0, 50},
+
+	{XFER_PIO_SLOW,},
+
+	{-1}
+};
+
+/* The interface doesn't have register/PIO timing for each device,
+ * but rather "fast" and "slow" timing.  We have to determeine
+ * which is the "fast" device based upon their capability.
+ */
+static int pio_mode[3] = { -1, -1, 0 }; /* entry 3: not our hardware */
+
+
+/* structure of the memory mapped IDE control */
+typedef struct ide_regs {
+	unsigned int si_stat;	/* IDE status */
+	unsigned int si_intenable;	/* IDE interrupt enable */
+	unsigned int si_control;	/* IDE control */
+	unsigned int pad0[0x3d];
+	unsigned int si_c0rt;	/* Chan 0 Register transfer timing */
+	unsigned int si_c0fpt;	/* Chan 0 Fast PIO transfer timing */
+	unsigned int si_c0timo;	/* Chan 0 timeout */
+	unsigned int pad1[2];
+	unsigned int si_c0d0u;	/* Chan 0 dev 0 UDMA timing */
+#define si_c0d0m si_c0d0u	/* Chan 0 dev 0 Multiword DMA timing */
+	unsigned int pad2;
+	unsigned int si_c0d1u;	/* Chan 0 dev 1 UDMA timing */
+#define si_c0d1m si_c0d1u	/* Chan 0 dev 1 Multiword DMA timing */
+	unsigned int si_c0c;	/* Chan 0 Control */
+	unsigned int si_c0s0;	/* Chan 0 Status 0 */
+	unsigned int si_c0ie;	/* Chan 0 Interrupt Enable */
+	unsigned int si_c0s1;	/* Chan 0 Status 0 */
+	unsigned int pad4[4];
+	unsigned int si_c0dcm;	/* Chan 0 DMA Command */
+	unsigned int si_c0tb;	/* Chan 0 PRD Table base address */
+	unsigned int si_c0dct;	/* Chan 0 DMA Count */
+	unsigned int si_c0da;	/* Chan 0 DMA Address */
+	unsigned int si_c0sr;	/* Chan 0 Slew Rate Output Control */
+	unsigned char pad5[0xa2];
+	unsigned short si_c0adc;	/* Chan 0 Alt status/control */
+	unsigned char si_c0d;	/* Chan 0 data */
+	unsigned char si_c0ef;	/* Chan 0 error/features */
+	unsigned char si_c0sct;	/* Chan 0 sector count */
+	unsigned char si_c0sn;	/* Chan 0 sector number */
+	unsigned char si_c0cl;	/* Chan 0 cylinder low */
+	unsigned char si_c0ch;	/* Chan 0 cylinder high */
+	unsigned char si_c0dh;	/* Chan 0 device/head */
+	unsigned char si_c0scm;	/* Chan 0 status/command */
+} ide_t;
+
+/* The structure of the PRD entry.  The address must be word aligned,
+ * and the count must be an even number of bytes.
+ */
+typedef struct {
+	unsigned int prd_physptr;
+	unsigned int prd_count;	/* Count only in lower 16 bits */
+} prd_entry_t;
+#define PRD_EOT		0x80000000lu	/* Set in prd_count */
+
+/* The number of PRDs required in a single transfer from the upper IDE
+ * functions. The maximum number is 128 (ide.h), but most seem to code to
+ * 256 (because of having two IDE channels). must be less than one page.
+ */
+#define NUM_PRD	256
+
+
+//--------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------
+//--------------------------------------------------------------------------
+//--------------------------------------------------------------------------
+// this is borrowed from ide_timing_find_mode so we can find the proper whold parameter
+static s16 whold_timing_find_mode(short speed) {
+	const struct whold_timing *t;
+
+	for( t = whold_timing; likely(t->mode >= 0); t++ )
+		if( t->mode == speed ) return(t->whold);
+
+	return(0);
+}
+
+//--------------------------------------------------------------------------
+// The STB04 has a fixed number of cycles that get added in regardless.
+// Adjust an ide_timing struct to accommodate that.
+static void stb04xxx_ide_adjust_timing(struct ide_timing * const t) {
+	t->setup   -= 2;
+	t->act8b   -= 1;
+	t->rec8b   -= 1;
+	t->active  -= 1;
+	t->recover -= 1;
+}
+
+static s32 stb04xxx_ide_tune_chipset (ide_drive_t * const drive, u8 speed) {
+	volatile ide_t    * const ide  = HWIF(drive)->hwif_data;
+	ide_drive_t       *peer        = HWIF(drive)->drives + (~drive->dn & 1);
+	struct ide_timing  t, p, merge, *fast;
+	s32 fast_device;
+	u32 ctl;
+
+	if( speed != XFER_PIO_SLOW && speed != drive->current_speed )
+		if( ide_config_drive_speed(drive, speed) )
+			printk(KERN_WARNING "ide%d: Drive %d didn't accept speed setting\n", drive->dn >> 1, drive->dn & 1);
+
+	ide_timing_compute(drive, speed, &t, SYS_CLOCK_NS, SYS_CLOCK_NS);
+	stb04xxx_ide_adjust_timing(&t);
+
+	/* peer is the other, i.e. not current, drive */
+	if( peer->present ) {
+		ide_timing_compute(peer, peer->current_speed, &p, SYS_CLOCK_NS, SYS_CLOCK_NS);
+		stb04xxx_ide_adjust_timing(&p);
+		ide_timing_merge(&p, &t, &merge, IDE_TIMING_8BIT | IDE_TIMING_SETUP);
+	} else {
+		merge = t;
+	}
+
+	if(!drive->init_speed) drive->init_speed = speed;
+	drive->current_speed = speed;
+
+	/* Now determine which drive is faster, and set up the
+	 * interface timing.  It would sure be nice if they would
+	 * have just had the timing registers for each device......
+	 */
+	/* change pio_mode of current drive */
+	pio_mode[(drive->dn & 1)] = (int) speed;
+
+	/* Now determine which of the drives
+	 * the first call we only know one device, and on subsequent
+	 * calls the user may manually change drive parameters.
+	 * Make timing[0] the fast device and timing[1] the slow.
+	 */
+
+	// compare pio_mode of both drives, one of them is faster than the other
+	if (pio_mode[0] >= pio_mode[1]) {
+		fast_device = 0;
+	} else {
+		fast_device = 1;
+	}
+
+	if (fast_device == (drive->dn & 1)) {									// if fast drive == current drive
+		fast = &t;
+	} else {																// if fast drive == peer (other) drive
+		fast = &p;
+	}
+
+	/* Now we know which device is the fast one and which is
+	 * the slow one.  The merged timing goes into the "regular"
+	 * timing registers and represents the slower of both times.
+	 */
+	ide->si_c0rt = MK_TIMING(merge.setup, merge.act8b, merge.rec8b, whold_timing_find_mode(merge.mode));
+
+	ide->si_c0fpt = MK_TIMING(fast->setup, fast->act8b, fast->rec8b, whold_timing_find_mode(fast->mode));
+
+	/* tell the interface which drive is the fast one. 	 */
+	ctl = ide->si_c0c; /* Chan 0 Control */
+	ctl &= ~0x10000000;
+	ctl |= fast_device << 28;
+	ide->si_c0c = ctl;
+
+	/* Set up DMA timing. */
+	if( (speed & XFER_MODE) != XFER_PIO ) {
+		/* NOTE: si_c0d0m and si_c0d0u are two different names
+		 * for the same register.  Whether it is used for
+		 * Multi-word DMA timings or Ultra DMA timings is
+		 * determined by the LSB written into it.  This is also
+		 * true for si_c0d1m and si_c0d1u.  */
+		volatile unsigned int *dtiming;
+		if( drive->dn & 1 ) {
+			dtiming = &(ide->si_c0d1u);
+		} else {
+			dtiming = &(ide->si_c0d0u);
+		}
+
+		if( (speed & XFER_MODE) == XFER_UDMA ) {
+			static const int tRP[] = {
+				EZ(160, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(125, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ( 85, SYS_CLOCK_NS) - 2 /*fixed cycles */
+			};
+			static const int NUMtRP = (sizeof (tRP) / sizeof (tRP[0]));
+			*dtiming = MK_UTIMING(t.udma, tRP[FIT(speed & 0xf, 0, NUMtRP - 1)]);
+		} else {
+			/* Multi-word DMA.  Note that t.recover/2 is an
+			 * approximation of MAX(tH, MAX(tJ, tN)) */
+			*dtiming = MK_TIMING(t.setup, t.active, t.recover, t.recover / 2);
+		}
+		drive->using_dma = 1;
+	}
+
+	return(0);
+}
+
+
+//--------------------------------------------------------------------------
+// stb04xxx_ide_tune_drive - tune a drive attached to a stb04
+// @drive: drive to tune
+// @pio: desired PIO mode (255 for "best possible")
+// Set the interface PIO mode.
+//--------------------------------------------------------------------------
+static void stb04xxx_ide_tune_drive (ide_drive_t *drive, u8 pio) {
+	pio = ide_get_best_pio_mode (drive, pio, 4, NULL);
+	stb04xxx_ide_tune_chipset(drive, XFER_PIO_0 + pio);
+}
+
+static s32 stb04xxx_ide_dma_host_off (ide_drive_t * const drive) {
+	return(0);
+}
+
+static s32 stb04xxx_ide_dma_host_on (ide_drive_t * const drive) __attribute__((alias("stb04xxx_ide_dma_host_off")));
+
+static s32 stb04xxx_ide_dma_off_quietly (ide_drive_t * const drive) {
+	printk( "gonna switch off DMA - try PIO-Mode from now on\n" );
+	drive->using_dma = 0;
+	return(0);
+}
+
+
+//--------------------------------------------------------------------------
+//	stb04xxx_ide_dma_check - set up for DMA if possible
+//	@drive: IDE drive to set up
+//
+//	Set up the drive for the highest supported speed considering the
+//	driver, controller and cable
+//
+// Section 1.6.2.6 "IDE Controller, ATA/ATAPI-5" in the STB04xxx
+// Datasheet says the following modes are supported:
+//   PIO modes 0 to 4
+//   Multiword DMA modes 0 to 2
+//   UltraDMA modes 0 to 4
+//--------------------------------------------------------------------------
+static s32 stb04xxx_ide_dma_check(ide_drive_t * const drive) {
+	u16 w80 = HWIF(drive)->udma_four;										// Allow UDMA_66 only if an 80 conductor cable is connected
+	s32 modes = XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA | (w80 ? XFER_UDMA_66 : 0);
+	s32 mode;
+
+	// XFER_EPIO includes both PIO modes 4 and 5.  Mode 5 is not
+	// valid for the STB04, so mask it out of consideration just
+	// in case some drive sets it... */
+	drive->id->eide_pio_modes &= ~4;
+	mode = ide_find_best_mode (drive, modes);
+
+	drive->using_dma = 0;
+	stb04xxx_ide_tune_chipset (drive, mode);
+	if( HWIF(drive)->autodma && (((mode & XFER_MODE) == XFER_PIO) || ((mode & XFER_MODE) == XFER_EPIO))) drive->using_dma = 0;
+	return 0;
+}
+
+//--------------------------------------------------------------------------
+static s32 stb04xxx_ide_dma_on (ide_drive_t * const drive) {
+	drive->using_dma = 1;
+	return(stb04xxx_ide_dma_host_on(drive));
+}
+
+
+
+//--------------------------------------------------------------------------
+// fill in the next PRD entry note that one PRD entry can transfer at most 65536 bytes
+static s32 build_prd_entry (prd_entry_t **table, u32 paddr, u32 size, s32 *count) {
+	u16 tc;
+
+	while( size ) {
+		tc = size & 0xffff;
+
+		if( unlikely(*count >= NUM_PRD) ) return(0);
+		if( unlikely(paddr & 0xf) )	return(0);								// data must be 16 byte aligned
+		if( unlikely(tc & 0x0f) ) return(0);								// transfer count must be a multiple of 16
+
+		(*table)->prd_physptr = paddr;
+		(*table)->prd_count   = tc;
+
+		paddr += (tc ? : 65536);
+		size  -= (tc ? : 65536);
+
+		++(*table);
+		++(*count);
+	}
+
+	return 1;
+}
+
+
+//--------------------------------------------------------------------------
+static s32 stb04xxx_ide_raw_build_sglist(ide_drive_t *drive, ide_hwif_t *hwif, struct request *rq, struct scatterlist *sg) {
+	s32 nents = 0;
+	ide_task_t *args = rq->special;
+	u8 *virt_addr = rq->buffer;
+	unsigned long  sector_count = rq->nr_sectors;
+
+	hwif->sg_dma_direction = (args->command_type == IDE_DRIVE_TASK_RAW_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	if( sector_count > 128 ) {
+		memset (&sg[nents], 0, sizeof(*sg));
+		sg[nents].page   = virt_to_page (virt_addr);
+		sg[nents].offset = offset_in_page (virt_addr);
+		sg[nents].length = 128 * SECTOR_SIZE;
+		nents++;
+		virt_addr    += (128 * SECTOR_SIZE);
+		sector_count -= 128;
+	}
+	memset (&sg[nents], 0, sizeof(*sg));
+	sg[nents].page   = virt_to_page (virt_addr);
+	sg[nents].offset = offset_in_page (virt_addr);
+	sg[nents].length = sector_count * SECTOR_SIZE;
+	nents++;
+	return(dma_map_sg(NULL, sg, nents, hwif->sg_dma_direction));
+}
+
+static s32 stb04xxx_ide_build_sglist (ide_drive_t *drive, ide_hwif_t *hwif, struct request *rq, struct scatterlist *sg) {
+	s32 nents;
+
+//	BUG_ON(hwif->sg_dma_active);
+	nents = blk_rq_map_sg (drive->queue, rq, sg);
+	hwif->sg_dma_direction = (rq_data_dir (rq) == READ) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	return(dma_map_sg (NULL, sg, nents, hwif->sg_dma_direction));
+}
+
+
+
+//--------------------------------------------------------------------------
+static s32 stb04xxx_ide_build_dmatable(ide_drive_t *drive, ide_hwif_t *hwif, struct request *rq) {
+	prd_entry_t  *table = (prd_entry_t *) hwif->dmatable_cpu;
+	u32 count = 0;
+	s32 icnt;
+	struct scatterlist *sg = hwif->sg_table;
+
+	if( HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE ) {
+		hwif->sg_nents = icnt = stb04xxx_ide_raw_build_sglist(drive, hwif, rq, sg);
+	} else {
+		hwif->sg_nents = icnt = stb04xxx_ide_build_sglist (drive, hwif, rq, sg);
+	}
+
+	if( icnt ) {
+		++icnt;
+		while( --icnt ) {
+			if( !build_prd_entry(&table, sg_dma_address(sg) + pio_mode[2], sg_dma_len (sg), &count) ) {
+				count = 0;													// fallback to PIO
+				break;
+			}
+			++sg;
+		}
+
+		if( likely(count) ) {
+			--table;
+			table->prd_count |= PRD_EOT;
+			return(count);
+		}
+	}
+
+	dma_unmap_sg(NULL, hwif->sg_table, hwif->sg_nents, hwif->sg_dma_direction);
+//	hwif->sg_dma_active = 0;
+	return(0);																 // revert to PIO for this request
+}
+
+
+//--------------------------------------------------------------------------
+static void stb04xxx_ide_destroy_dmatable(ide_drive_t *drive) {
+	dma_unmap_sg (NULL, HWIF(drive)->sg_table, HWIF(drive)->sg_nents, HWIF(drive)->sg_dma_direction);
+//	HWIF(drive)->sg_dma_active = 0;
+}
+
+
+//--------------------------------------------------------------------------
+// dma_intr() is the handler for disk read/write DMA interrupts
+// This is taken directly from ide-dma.c, which we can't use because
+// it requires PCI support.
+//--------------------------------------------------------------------------
+ide_startstop_t ide_dma_intr(ide_drive_t *drive) {
+	u8 dma_stat = HWIF(drive)->ide_dma_end (drive);
+	u8 stat     = HWIF(drive)->INB (IDE_STATUS_REG);						// get drive status
+
+	if( OK_STAT (stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT) ) {
+		if( !dma_stat ) {
+			struct request * const rq = HWGROUP(drive)->rq;
+
+//
+//             DRIVER(drive)->end_request (drive, 1, rq->nr_sectors);
+//             return ide_stopped;
+//         }
+//
+//
+
+			if( rq->rq_disk ) {
+				ide_driver_t *drv;
+
+				drv = *(ide_driver_t **)rq->rq_disk->private_data;;
+				drv->end_request(drive, 1, rq->nr_sectors);
+			} else
+				ide_end_request(drive, 1, rq->nr_sectors);
+			return(ide_stopped);
+		}
+
+		printk ("%s: dma_intr: bad DMA status (dma_stat=%x)\n",
+				drive->name, dma_stat);
+	}
+
+//	return(DRIVER(drive)->error (drive, "dma_intr", stat));
+	return ide_error(drive, "dma_intr", stat);
+}
+
+
+
+
+
+
+
+//--------------------------------------------------------------------------
+static void stb04xxx_dma_exec_cmd(ide_drive_t *drive, u8 cmd) {
+	/* issue cmd to drive */
+//	printk( "ide_execute_command, cmd is: %.2X\n", cmd );
+//	ide_execute_command(drive, cmd, ide_dma_intr, 2 * WAIT_CMD, NULL);
+	HWIF(drive)->OUTB(cmd, IDE_COMMAND_REG);								// issue cmd to drive
+
+}
+
+
+//--------------------------------------------------------------------------
+static s32 stb04xxx_ide_dma_end (ide_drive_t * const drive) {
+	volatile ide_t * const ide = (ide_t *) HWIF(drive)->hwif_data;
+	u32 dstat;
+
+	drive->waiting_for_dma = 0;												// stop DMA
+	ide->si_c0dcm &= ~0x01000000;
+	dstat = ide->si_c0s1;													// get DMA status
+	ide->si_c0s0 = 0xdc800000;												// clear all status bits
+	wmb ();
+	stb04xxx_ide_destroy_dmatable (drive);
+	/* verify good dma status */
+	return (dstat & 0x10000000) ? 0 : 1;									// return true if DMA still active
+}
+
+
+//--------------------------------------------------------------------------
+static s32 start_dma(ide_drive_t *const drive, ide_hwif_t * const hwif, struct request * const rq) {
+	volatile ide_t * const ide = (ide_t *) hwif->hwif_data;
+
+	if(unlikely (!stb04xxx_ide_build_dmatable(drive, hwif, rq))) return 1;	// try PIO instead of DMA
+
+	ide->si_c0tb = hwif->dmatable_dma;
+	ide->si_c0s0 = 0xdc800000;												// Clear all status
+	ide->si_c0ie = 0x90000000;												// Enable all intr
+	drive->waiting_for_dma = 1;
+	return 0;
+}
+
+
+//--------------------------------------------------------------------------
+static void stb04xxx_dma_start(ide_drive_t * const drive) {
+	volatile ide_t * const ide  = (ide_t *) HWIF(drive)->hwif_data;
+
+	mb();																	// start DMA
+	ide->si_c0dcm |= 0x01000000;
+}
+
+
+//--------------------------------------------------------------------------
+static int stb04xxx_dma_setup(ide_drive_t *drive) {
+	struct request *rq = drive->hwif->hwgroup->rq;
+	ide_hwif_t     *hwif = HWIF(drive);
+	volatile ide_t *ide  = (ide_t *) hwif->hwif_data;
+	u8              lba48= (drive->addressing == 1) ? 1 : 0;
+	task_ioreg_t    command;
+
+	ide_set_handler(drive, &ide_dma_intr, WAIT_CMD, NULL);
+
+	if( unlikely( start_dma( drive, hwif, rq ) ) ) return(1);				  // try PIO instead of DMA
+
+	if( rq_data_dir(rq) == READ ) {
+		ide->si_c0dcm = 0x00000000;											// specify r/w (READ)
+	} else {
+		ide->si_c0dcm = 0x08000000;											// specify r/w (WRITE)
+	}
+
+	if( drive->media != ide_disk ) return(0);
+
+	if( rq_data_dir(rq)  == READ ) {
+		command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
+		if( drive->vdma ) command = lba48? WIN_READ_EXT : WIN_READ;
+	} else {
+		command = (lba48) ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
+		if( drive->vdma ) command = lba48? WIN_WRITE_EXT : WIN_WRITE;
+	}
+
+//	printk( "stb04xxx_dma_setup, cmd should be: %.2X\n", command );
+	return(0);
+}
+
+
+
+
+//--------------------------------------------------------------------------
+static s32 stb04xxx_ide_dma_test_irq (ide_drive_t * const drive) {
+	/* return 1 if dma irq issued, 0 otherwise */
+	volatile ide_t * const ide = (ide_t *) HWIF (drive)->hwif_data;
+
+	if( ide->si_c0s0 & 0x10000000 )	return(1);
+	if( !drive->waiting_for_dma ) {
+		EPRINTK(KERN_WARNING "%s: called while not waiting\n", drive->name );
+	}
+
+	return(0);
+}
+
+
+//--------------------------------------------------------------------------
+// static s32 stb04xxx_ide_dma_verbose (ide_drive_t * const drive) {
+//     const struct hd_driveid * const id   = drive->id;
+//     const ide_hwif_t        * const hwif = HWIF (drive);
+//
+//     GDEB_DPRINTK(ide_debug, 0x02, "field_valid: 0x%.2X, dma_ultra: 0x%.2X, dma_mword: 0x%.2X, ultra_mask: 0x%.2X, mwdma_mask: 0x%.2X\n",
+//          id->field_valid, id->dma_ultra, id->dma_mword, hwif->ultra_mask, hwif->mwdma_mask);
+//
+//     if (id->field_valid & 4) {
+//         if ((id->dma_ultra >> 8) && (id->dma_mword >> 8)) {
+//             GDEB_DPRINTK(ide_debug, 0x02, "BUG DMA OFF\n");
+//             return hwif->ide_dma_off_quietly(drive);
+//         }
+//         if (id->dma_ultra & ((id->dma_ultra >> 8) & hwif->ultra_mask)) {
+//             if (((id->dma_ultra >> 11) & 0x1F) &&
+//                 eighty_ninty_three(drive)) {
+//                 if ((id->dma_ultra >> 15) & 1) {
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(mode 7)\n");
+//                 } else if ((id->dma_ultra >> 14) & 1) {
+//                     /* ATA - 7 */
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(133)\n");
+//                 } else if ((id->dma_ultra >> 13) & 1) {
+//                     /* ATA - 6 UDMA mode 5 */
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(100)\n");
+//                 } else if ((id->dma_ultra >> 12) & 1) {
+//                     /* ATA - 5 UDMA mode 4 */
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(66)\n");
+//                 } else if ((id->dma_ultra >> 11) & 1) {
+//                     /* UDMA mode 3 */
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(44)\n");
+//                 } else
+//                     goto mode_two;
+//             } else {
+//         mode_two:
+//                 /* ATA - 4: UDMA modes 2 .. 0 */
+//                 if ((id->dma_ultra >> 10) & 1) {
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(33)\n");
+//                 } else if ((id->dma_ultra >> 9) & 1) {
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(25)\n");
+//                 } else if ((id->dma_ultra >> 8) & 1) {
+//                     GDEB_DPRINTK(ide_debug, 0x02, "UDMA(16)\n");
+//                 }
+//             }
+//         } else {
+//             GDEB_DPRINTK(ide_debug, 0x02, "(U)DMA\n");                      // Can be BIOS-enabled!
+//         }
+//     } else if (id->field_valid & 2) {
+//         if ((id->dma_mword >> 8) && (id->dma_1word >> 8)) {
+//             GDEB_DPRINTK(ide_debug, 0x02, "BUG DMA OFF\n");
+//             return hwif->ide_dma_off_quietly(drive);
+//         }
+//         GDEB_DPRINTK(ide_debug, 0x02, "DMA\n");
+//     } else if (id->field_valid & 1) {
+//         GDEB_DPRINTK(ide_debug, 0x02, "BUG\n");
+//     }
+//     return 1;
+// }
+
+
+static s32 stb04xxx_ide_dma_lostirq(ide_drive_t * const drive) {
+	GDEB_EPRINTK(ide_debug, 0x01, "%s: DMA interrupt recovery neccessary\n", drive->name);
+	return 1;
+}
+
+static s32 stb04xxx_ide_dma_timeout(ide_drive_t * const drive) {
+	GDEB_EPRINTK(ide_debug, 0x01, "%s: timeout waiting for DMA\n", drive->name);
+	if(stb04xxx_ide_dma_test_irq (drive)) return 0;
+	return stb04xxx_ide_dma_end (drive);
+}
+
+static void stb04xxx_init_ocp_ide(ide_hwif_t * const hwif) {
+	hwif->autodma = 1;
+	hwif->drives[0].autotune = hwif->drives[1].autotune = IDE_TUNE_AUTO;
+	hwif->drives[0].autodma  = hwif->drives[1].autodma  = hwif->autodma;
+
+	hwif->atapi_dma  = 1;
+	hwif->ultra_mask = hwif->udma_four ? 0x1f : 0x07;
+	hwif->mwdma_mask = 0x07;
+	hwif->swdma_mask = 0x00;
+
+	/* set everything to something != NULL */
+	hwif->ide_dma_host_off = &stb04xxx_ide_dma_host_off;
+	hwif->ide_dma_host_on  = &stb04xxx_ide_dma_host_on;
+
+	hwif->ide_dma_check       = &stb04xxx_ide_dma_check;
+	hwif->ide_dma_off_quietly = &stb04xxx_ide_dma_off_quietly;
+	hwif->ide_dma_on          = &stb04xxx_ide_dma_on;
+
+//  hwif->ide_dma_write = &stb04xxx_ide_dma_write;
+//  hwif->ide_dma_read  = &stb04xxx_ide_dma_read;
+//	hwif->ide_dma_begin = &stb04xxx_ide_dma_begin;
+	hwif->dma_setup    = &stb04xxx_dma_setup;
+	hwif->dma_exec_cmd = &stb04xxx_dma_exec_cmd;
+	hwif->dma_start    = &stb04xxx_dma_start;
+
+	hwif->ide_dma_end   = &stb04xxx_ide_dma_end;
+
+	hwif->ide_dma_test_irq = &stb04xxx_ide_dma_test_irq;
+
+//	hwif->ide_dma_verbose = &stb04xxx_ide_dma_verbose;
+	hwif->ide_dma_lostirq = &stb04xxx_ide_dma_lostirq;
+	hwif->ide_dma_timeout = &stb04xxx_ide_dma_timeout;
+}
+
+
+//--------------------------------------------------------------------------
+static s32 __init stb04xxx_ide_probe (struct ocp_device * const ocp) {
+	s32 err;
+	u32 uicdcr;
+	volatile ide_t *ide;
+	unsigned long   flags;
+	ide_hwif_t *hwif = &ide_hwifs[0];
+	u8 *ip;
+	s32 icnt;
+
+	PMVERSION();															// print the driver verision info for futher reference
+
+	if( !request_region(ocp->def->paddr, sizeof(ide_t), "ide") ) return(-ENOMEM);
+
+	ocp_force_power_on(ocp);
+	ide = ioremap (ocp->def->paddr, sizeof (ide_t));
+	if( !ide ) {
+		err = -ENOMEM;
+		release_region(ocp->def->paddr, sizeof(ide_t));
+		return(err);
+	}
+
+	ide->si_control = 0x80000000;											// Enable the interface
+	ide->si_c0s0 = 0xdc800000;												// Clear all status
+	ide->si_intenable = 0x80000000;
+	/* Per the STB04 data sheet:
+	 *  1)  tTO = ((8*RDYT) + 1) * SYS_CLK
+	 * and:
+	 *  2)  tTO >= 1250 + (2 * SYS_CLK) - t2
+	 * Solving the first equation for RDYT:
+	 *             (tTO/SYS_CLK) - 1
+	 *  3)  RDYT = -----------------
+	 *                     8
+	 * Substituting equation 2) for tTO in equation 3:
+	 *             ((1250 + (2 * SYS_CLK) - t2)/SYS_CLK) - 1
+	 *  3)  RDYT = -----------------------------------------
+	 *                                8
+	 * It's just the timeout so having it too long isn't too
+	 * significant, so we'll just assume t2 is zero.  All this math
+	 * is handled by the compiler and RDYT ends up being 11 assuming
+	 * that SYS_CLOCK_NS is 15.
+	 */
+	ide->si_c0timo = (EZ(EZ(1250 + 2 * SYS_CLOCK_NS, SYS_CLOCK_NS) - 1, 8)) << 23;	/* Chan 0 timeout */
+
+	ide->si_c0rt = MK_TIMING(6, 19, 15, 2);									// stuff some slow default PIO timing
+	ide->si_c0fpt = MK_TIMING(6, 19, 15, 2);
+	ide->si_c0c |= 0x00008040;												// enable 32bit access on both devices
+	local_irq_save(flags);													// we should probably have UIC functions to set external interrupt level/edge
+	uicdcr = mfdcr(DCRN_UIC_PR(UIC0));
+	uicdcr &= ~(0x80000000 >> IDE0_IRQ);
+	mtdcr(DCRN_UIC_PR(UIC0), uicdcr);
+	mtdcr(DCRN_UIC_TR(UIC0), mfdcr(DCRN_UIC_TR (UIC0)) | (0x80000000 >> IDE0_IRQ));
+	local_irq_restore (flags);
+	ocp_set_drvdata(ocp, hwif);												// initialize
+	default_hwif_mmiops(hwif);												// setup MMIO ops
+
+	hwif->mmio = 2;															// tell common code _not_ to mess with resources
+	ide_set_hwifdata(hwif, (void *) ide);
+
+	ip = (u8 *)(&(ide->si_c0d));											// Chan 0 data
+	for( icnt = IDE_DATA_OFFSET; icnt <= IDE_STATUS_OFFSET; icnt++ ) {
+		hwif->hw.io_ports[icnt] = (s32)(ip++);
+	}
+	hwif->hw.io_ports[IDE_CONTROL_OFFSET] = (s32) (&(ide->si_c0adc));
+	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->hw.io_ports));
+	hwif->chipset = ide_generic;
+	hwif->irq     = ocp->def->irq;
+	hwif->noprobe = 0;
+	hwif->hold    = 1;
+
+	hwif->udma_four = (ide->si_c0s1 & 0x20000000) != 0;						// Figure out if an 80 conductor cable is connected
+	hwif->tuneproc  = &stb04xxx_ide_tune_drive;
+	hwif->speedproc = &stb04xxx_ide_tune_chipset;
+	hwif->drives[0].io_32bit = hwif->drives[1].io_32bit = 1;
+	hwif->drives[0].unmask   = hwif->drives[1].unmask   = 1;
+	pio_mode[0] = pio_mode[1] = -1;
+	stb04xxx_init_ocp_ide(hwif);
+
+	/* grab a page for the PRD table. this is save with respect to not
+	   crossing a 64k border because returned memory is page aligned
+	   and NUM_PRD*sizeof(prd_entry_t) end up being 2048 bytes, i.e.
+	   less than one page. */
+	hwif->dmatable_cpu = dma_alloc_coherent(NULL, NUM_PRD * sizeof (prd_entry_t), &hwif->dmatable_dma, GFP_KERNEL);
+	if( !hwif->dmatable_cpu ) {
+		err = -ENOMEM;
+	} else {
+		hwif->sg_table = kmalloc(sizeof (struct scatterlist) * NUM_PRD, GFP_KERNEL);
+		if( hwif->sg_table ) {
+			probe_hwif_init(hwif);
+			create_proc_ide_interfaces();
+			return(0);
+		}
+		err = -ENOMEM;
+		dma_free_coherent(NULL, NUM_PRD * sizeof (prd_entry_t), hwif->dmatable_cpu, hwif->dmatable_dma);
+	}
+
+	ide_set_hwifdata(hwif, NULL);
+	hwif->noprobe = 1;
+	hwif->chipset = ide_unknown;
+	ocp_set_drvdata(ocp, NULL);
+	iounmap((void *) ide);
+	release_region(ocp->def->paddr, sizeof(ide_t));
+	return(err);
+}
+
+
+
+static void stb04xxx_ide_remove(struct ocp_device * const ocp) {
+	ide_hwif_t     *hwif = ocp_get_drvdata(ocp);
+	volatile ide_t *ide_regs = ide_get_hwifdata(hwif);
+
+	GDEB_DPRINTK(ide_debug, 0x04, "remove IDE %d, major: %d, drive %s\n", hwif->index, hwif->major, hwif->drives[hwif->index].name );
+	ide_unregister(hwif->index);
+
+	if( hwif->dmatable_cpu )
+		dma_free_coherent(NULL, NUM_PRD * sizeof(prd_entry_t), hwif->dmatable_cpu, hwif->dmatable_dma);
+
+	/* dunno whether or not ide_unregister() will mess with those */
+	hwif->dmatable_cpu = NULL;
+	hwif->dmatable_dma = 0;
+
+	// 2.6.12 - ide_unregister calls destroy_proc_ide_interface()
+//	destroy_proc_ide_interfaces();
+	iounmap( (void *)ide_regs );
+	release_region( ocp->def->paddr, sizeof(ide_t) );
+
+	if( hwif->sg_table ) kfree(hwif->sg_table);
+	hwif->sg_table = NULL;
+}
+
+
+
+
+
+
+
+
+
+//--------------------------------------------------------------------------
+static struct ocp_device_id stb04xxx_ide_ids[] __devinitdata = {
+	{ .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_IDE,
+	},
+
+	{ .vendor = OCP_VENDOR_INVALID,
+	}
+};
+
+MODULE_DEVICE_TABLE(ocp, stb04xxx_ide_ids);
+
+static struct ocp_driver stb04xxx_ide_driver = {
+	.name     = "ide",
+	.id_table = stb04xxx_ide_ids,
+	.probe    = stb04xxx_ide_probe,
+	.remove   = __devexit_p(stb04xxx_ide_remove),
+#if defined(CONFIG_PM)
+	.suspend  = NULL,
+	.resume   = NULL,
+#endif
+};
+
+
+//--------------------------------------------------------------------------
+static s32 __init stb04xxx_ide_init(void) {
+	GDEB_DPRINTK(ide_debug, 0x10, "Ensure HD is powered up\n");				// we need to power up before probing
+
+// have to solve this problem different (unwanted dependencies to binary-only driver)
+// the problem here is we cannot read from the extended-io the power is switched with.
+// this is write-only-register and backupped in "tdcore"
+// we will release this stuff later
+//     if( !pw_cdhd_on() ) {                                                   // power up and test if already up
+//         GDEB_DPRINTK(ide_debug, 0x10, "Spinnup delay (power was off)\n");   // we need to power up before probing
+//         SLEEP(3000);
+//     }
+	return(ocp_register_driver(&stb04xxx_ide_driver));
+}
+
+static void __exit stb04xxx_ide_exit(void) {
+	ocp_unregister_driver(&stb04xxx_ide_driver);
+}
+
+
+
+/* needs to be called after ide has been initialized */
+late_initcall(stb04xxx_ide_init);
+module_exit(stb04xxx_ide_exit);
+
+MODULE_AUTHOR ("Andr D. / Uli H.");
+MODULE_DESCRIPTION ("driver for IBM OCP IDE on STB04xxx");
+MODULE_LICENSE ("GPL");
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/net/Kconfig linux-2.6.12/drivers/net/Kconfig
--- linux-2.6.12.orig/drivers/net/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/net/Kconfig	2005-06-25 22:22:58.000000000 +0200
@@ -794,7 +794,7 @@
 	tristate "SMC 91C9x/91C1xxx support"
 	select CRC32
 	select MII
-	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R || SUPERH)
+	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R || SUPERH || TRIPLEDRAGON)
 	help
 	  This is a driver for SMC's 91x series of Ethernet chipsets,
 	  including the SMC91C94 and the SMC91C111. Say Y if you want it
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/net/smc91x.h linux-2.6.12/drivers/net/smc91x.h
--- linux-2.6.12.orig/drivers/net/smc91x.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/net/smc91x.h	2005-06-27 22:48:05.000000000 +0200
@@ -55,7 +55,7 @@
 #define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
 #define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
 
-#elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6)
+#elif defined(CONFIG_IBM_PALLAS) || defined(CONFIG_REDWOOD_6)
 
 /* We can only do 16-bit reads and writes in the static memory space. */
 #define SMC_CAN_USE_8BIT	0
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/usb/Kconfig linux-2.6.12/drivers/usb/Kconfig
--- linux-2.6.12.orig/drivers/usb/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/usb/Kconfig	2005-06-25 23:35:38.000000000 +0200
@@ -24,6 +24,7 @@
 	# PPC:
 	default y if STB03xxx
 	default y if PPC_MPC52xx
+	default y if TRIPLEDRAGON
 	# MIPS:
 	default y if SOC_AU1X00
 	# more:
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/usb/host/Kconfig linux-2.6.12/drivers/usb/host/Kconfig
--- linux-2.6.12.orig/drivers/usb/host/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/usb/host/Kconfig	2005-06-25 23:37:19.000000000 +0200
@@ -68,7 +68,7 @@
 
 config USB_OHCI_HCD_PPC_SOC
 	bool "OHCI support for on-chip PPC USB controller"
-	depends on USB_OHCI_HCD && (STB03xxx || PPC_MPC52xx)
+	depends on USB_OHCI_HCD && (STB03xxx || PPC_MPC52xx || TRIPLEDRAGON)
 	default y
 	select USB_OHCI_BIG_ENDIAN
 	---help---
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/usb/host/ohci-ppc-soc.c linux-2.6.12/drivers/usb/host/ohci-ppc-soc.c
--- linux-2.6.12.orig/drivers/usb/host/ohci-ppc-soc.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/usb/host/ohci-ppc-soc.c	2005-06-26 21:36:35.000000000 +0200
@@ -15,6 +15,8 @@
  */
 
 #include <asm/usb.h>
+// #include <asm/ocp.h>
+// #include <asm/dma-mapping.h>
 
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
@@ -123,7 +125,7 @@
 
 	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_hcd_put(hcd);
+	usb_put_hcd(hcd);
 }
 
 static int __devinit
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/video/Kconfig linux-2.6.12/drivers/video/Kconfig
--- linux-2.6.12.orig/drivers/video/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/video/Kconfig	2005-06-25 01:23:16.000000000 +0200
@@ -39,7 +39,7 @@
 	  device-aware may cause unexpected results. If unsure, say N.
 
 config FB_CFB_FILLRECT
-	tristate
+	tristate "Support cfb_fillrect"
 	depends on FB
 	default n
 	---help---
@@ -48,7 +48,7 @@
 	  (accelerated) version.
 
 config FB_CFB_COPYAREA
-	tristate
+	tristate "Support cfb_copyarea"
 	depends on FB
 	default n
 	---help---
@@ -57,7 +57,7 @@
 	  version.
 
 config FB_CFB_IMAGEBLIT
-	tristate
+	tristate "Support cfb_imageblit"
 	depends on FB
 	default n
 	---help---
@@ -66,7 +66,7 @@
 	  (accelerated) version.
 
 config FB_SOFT_CURSOR
-	tristate
+	tristate "Support soft_cursor"
 	depends on FB
 	default n
 	---help---
diff -Xxfiles -rNBwdu linux-2.6.12.orig/fs/Kconfig linux-2.6.12/fs/Kconfig
--- linux-2.6.12.orig/fs/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/fs/Kconfig	2005-06-24 22:36:59.000000000 +0200
@@ -1171,6 +1171,29 @@
 
 	  If unsure, say N.
 
+config SQUASHFS
+	tristate "SquashFS 2.1 - Squashed file system support"
+	select ZLIB_INFLATE
+	help
+	  Saying Y here includes support for SquashFs 2.1 (Compressed Read-Only File
+	  System).  Squashfs is a highly compressed read-only filesystem for Linux.
+	  It uses zlib compression to compress both files, inodes and directories.
+	  Inodes in the system are very small and all blocks are packed to minimise
+	  data overhead. Block sizes greater than 4K are supported up to a maximum of 64K.
+
+	  Squashfs is intended for general read-only filesystem use, for archival
+	  use (i.e. in cases where a .tar.gz file may be used), and in embedded
+	  systems where low overhead is needed.  Further information and filesystem tools
+	  are available from http://squashfs.sourceforge.net.
+
+	  If you want to compile this as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called squashfs.  Note that the root file system (the one
+	  containing the directory /) cannot be compiled as a module.
+
+	  If unsure, say N.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	help
diff -Xxfiles -rNBwdu linux-2.6.12.orig/fs/Makefile linux-2.6.12/fs/Makefile
--- linux-2.6.12.orig/fs/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/fs/Makefile	2005-06-24 22:38:22.000000000 +0200
@@ -52,6 +52,7 @@
 obj-$(CONFIG_JBD)		+= jbd/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
diff -Xxfiles -rNBwdu linux-2.6.12.orig/fs/squashfs/Makefile linux-2.6.12/fs/squashfs/Makefile
--- linux-2.6.12.orig/fs/squashfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/fs/squashfs/Makefile	2005-06-24 22:42:37.000000000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux squashfs routines.
+#
+
+obj-$(CONFIG_SQUASHFS) += squashfs.o
+
+squashfs-objs := inode.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/fs/squashfs/inode.c linux-2.6.12/fs/squashfs/inode.c
--- linux-2.6.12.orig/fs/squashfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/fs/squashfs/inode.c	2005-06-24 22:41:55.000000000 +0200
@@ -0,0 +1,1787 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * inode.c
+ */
+
+#define SQUASHFS_1_0_COMPATIBILITY
+
+#include <linux/types.h>
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/init.h>
+#include <linux/dcache.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+#include <asm/semaphore.h>
+#include <linux/zlib.h>
+#include <linux/blkdev.h>
+#include <linux/vmalloc.h>
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)				printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)				{}
+#endif
+
+#define ERROR(s, args...)				printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)				if(!silent) printk(KERN_ERR "SQUASHFS error: "s, ## args)
+#define WARNING(s, args...)				printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static void squashfs_put_super(struct super_block *);
+static int squashfs_statfs(struct super_block *, struct kstatfs *);
+static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static int squashfs_readpage(struct file *file, struct page *page);
+static int squashfs_readpage4K(struct file *file, struct page *page);
+static int squashfs_readdir(struct file *, void *, filldir_t);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *, struct nameidata *);
+static unsigned int read_data(struct super_block *s, char *buffer,
+		unsigned int index, unsigned int length, unsigned int *next_index);
+static int squashfs_get_cached_block(struct super_block *s, char *buffer,
+		unsigned int block, unsigned int offset, int length,
+		unsigned int *next_block, unsigned int *next_offset);
+static struct inode *squashfs_iget(struct super_block *s, squashfs_inode inode);
+static unsigned int read_blocklist(struct inode *inode, int index, int readahead_blks,
+		char *block_list, unsigned short **block_p, unsigned int *bsize);
+static void squashfs_put_super(struct super_block *s);
+static struct super_block *squashfs_get_sb(struct file_system_type *, int, const char *, void *);
+static struct inode *squashfs_alloc_inode(struct super_block *sb);
+static void squashfs_destroy_inode(struct inode *inode);
+static int init_inodecache(void);
+static void destroy_inodecache(void);
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+static int squashfs_readpage_lessthan4K(struct file *file, struct page *page);
+static struct inode *squashfs_iget_1(struct super_block *s, squashfs_inode inode);
+static unsigned int read_blocklist_1(struct inode *inode, int index, int readahead_blks,
+		char *block_list, unsigned short **block_p, unsigned int *bsize);
+#endif
+
+DECLARE_MUTEX(read_data_mutex);
+
+static z_stream stream;
+
+static struct file_system_type squashfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "squashfs",
+	.get_sb = squashfs_get_sb,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV
+	};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static struct super_operations squashfs_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+};
+
+static struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
+};
+
+static struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
+};
+
+static struct address_space_operations squashfs_aops_4K = {
+	.readpage = squashfs_readpage4K
+};
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+static struct address_space_operations squashfs_aops_lessthan4K = {
+	.readpage = squashfs_readpage_lessthan4K
+};
+#endif
+
+static struct file_operations squashfs_dir_ops = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir
+};
+
+static struct inode_operations squashfs_dir_inode_ops = {
+	.lookup = squashfs_lookup
+};
+
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+
+static struct buffer_head *get_block_length(struct super_block *s, int *cur_index, int *offset, int *c_byte)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	unsigned short temp;
+	struct buffer_head *bh;
+
+	if(!(bh = sb_bread(s, *cur_index)))
+		return NULL;
+
+	if(msBlk->devblksize - *offset == 1) {
+		if(msBlk->swap)
+			((unsigned char *) &temp)[1] = *((unsigned char *) (bh->b_data + *offset));
+		else
+			((unsigned char *) &temp)[0] = *((unsigned char *) (bh->b_data + *offset));
+		brelse(bh);
+		if(!(bh = sb_bread(s, ++(*cur_index))))
+			return NULL;
+		if(msBlk->swap)
+			((unsigned char *) &temp)[0] = *((unsigned char *) bh->b_data);
+		else
+			((unsigned char *) &temp)[1] = *((unsigned char *) bh->b_data);
+		*c_byte = temp;
+		*offset = 1;
+	}
+	else {
+		if(msBlk->swap) {
+			unsigned short temp;
+			((unsigned char *) &temp)[1] = *((unsigned char *) (bh->b_data + *offset));
+			((unsigned char *) &temp)[0] = *((unsigned char *) (bh->b_data + *offset + 1));
+			*c_byte = temp;
+		} else
+			*c_byte = *((unsigned short *) (bh->b_data + *offset));
+		*offset += 2;
+	}
+	if(SQUASHFS_CHECK_DATA(msBlk->sBlk.flags)) {
+		if(*offset == msBlk->devblksize) {
+			brelse(bh);
+			if(!(bh = sb_bread(s, ++(*cur_index))))
+				return NULL;
+			offset = 0;
+		}
+		if(*((unsigned char *) (bh->b_data + *offset)) != SQUASHFS_MARKER_BYTE) {
+			ERROR("Metadata block marker corrupt @ %x\n", *cur_index);
+			brelse(bh);
+			return NULL;
+		}
+		*offset ++;
+	}
+
+	return bh;
+}
+
+
+static unsigned int read_data(struct super_block *s, char *buffer,
+		unsigned int index, unsigned int length, unsigned int *next_index)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	struct buffer_head *bh[((SQUASHFS_FILE_MAX_SIZE - 1) >> msBlk->devblksize_log2) + 2];
+	unsigned int offset = index & ((1 << msBlk->devblksize_log2) - 1);
+	unsigned int cur_index = index >> msBlk->devblksize_log2;
+	int bytes, avail_bytes, b = 0, k;
+	char *c_buffer;
+	unsigned int compressed;
+	unsigned int c_byte = length;
+
+	if(c_byte) {
+		bytes = msBlk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
+		c_buffer = compressed ? msBlk->read_data : buffer;
+		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+
+		TRACE("Block @ 0x%x, %scompressed size %d\n", index, compressed ? "" : "un", (unsigned int) c_byte);
+
+		if(!(bh[0] = sb_getblk(s, cur_index)))
+			goto block_release;
+		for(b = 1; bytes < c_byte; b++) {
+			if(!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msBlk->devblksize;
+		}
+		ll_rw_block(READ, b, bh);
+	} else {
+		if(!(bh[0] = get_block_length(s, &cur_index, &offset, &c_byte)))
+			goto read_failure;
+
+		bytes = msBlk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED(c_byte);
+		c_buffer = compressed ? msBlk->read_data : buffer;
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+		TRACE("Block @ 0x%x, %scompressed size %d\n", index, compressed ? "" : "un", (unsigned int) c_byte);
+
+		for(b = 1; bytes < c_byte; b++) {
+			if(!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msBlk->devblksize;
+		}
+		ll_rw_block(READ, b - 1, bh + 1);
+	}
+
+	if(compressed)
+		down(&read_data_mutex);
+
+	for(bytes = 0, k = 0; k < b; k++) {
+		avail_bytes = (c_byte - bytes) > (msBlk->devblksize - offset) ? msBlk->devblksize - offset : c_byte - bytes;
+		wait_on_buffer(bh[k]);
+		memcpy(c_buffer + bytes, bh[k]->b_data + offset, avail_bytes);
+		bytes += avail_bytes;
+		offset = 0;
+		brelse(bh[k]);
+	}
+
+	/*
+	 * uncompress block
+	 */
+	if(compressed) {
+		int zlib_err;
+
+		stream.next_in = c_buffer;
+		stream.avail_in = c_byte;
+		stream.next_out = buffer;
+		stream.avail_out = msBlk->read_size;
+		if(((zlib_err = zlib_inflateInit(&stream)) != Z_OK) ||
+				((zlib_err = zlib_inflate(&stream, Z_FINISH)) != Z_STREAM_END) ||
+				((zlib_err = zlib_inflateEnd(&stream)) != Z_OK)) {
+			ERROR("zlib_fs returned unexpected result 0x%x\n", zlib_err);
+			bytes = 0;
+		} else
+			bytes = stream.total_out;
+		up(&read_data_mutex);
+	}
+
+	if(next_index)
+		*next_index = index + c_byte + (length ? 0 : (SQUASHFS_CHECK_DATA(msBlk->sBlk.flags) ? 3 : 2));
+
+	return bytes;
+
+block_release:
+	while(--b >= 0) brelse(bh[b]);
+
+read_failure:
+	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	return 0;
+}
+
+
+static int squashfs_get_cached_block(struct super_block *s, char *buffer,
+		unsigned int block, unsigned int offset, int length,
+		unsigned int *next_block, unsigned int *next_offset)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	int n, i, bytes, return_length = length;
+	unsigned int next_index;
+
+	TRACE("Entered squashfs_get_cached_block [%x:%x]\n", block, offset);
+
+	for(;;) {
+		for(i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+			if(msBlk->block_cache[i].block == block)
+				break;
+
+		down(&msBlk->block_cache_mutex);
+		if(i == SQUASHFS_CACHED_BLKS) {
+			/* read inode header block */
+			for(i = msBlk->next_cache, n = SQUASHFS_CACHED_BLKS; n ; n --, i = (i + 1) % SQUASHFS_CACHED_BLKS)
+				if(msBlk->block_cache[i].block != SQUASHFS_USED_BLK)
+					break;
+			if(n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msBlk->waitq, &wait);
+ 				up(&msBlk->block_cache_mutex);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msBlk->waitq, &wait);
+				continue;
+			}
+			msBlk->next_cache = (i + 1) % SQUASHFS_CACHED_BLKS;
+
+			if(msBlk->block_cache[i].block == SQUASHFS_INVALID_BLK) {
+				if(!(msBlk->block_cache[i].data = (unsigned char *)
+							kmalloc(SQUASHFS_METADATA_SIZE, GFP_KERNEL))) {
+					ERROR("Failed to allocate cache block\n");
+					up(&msBlk->block_cache_mutex);
+					return 0;
+				}
+			}
+
+			msBlk->block_cache[i].block = SQUASHFS_USED_BLK;
+			up(&msBlk->block_cache_mutex);
+			if(!(msBlk->block_cache[i].length = read_data(s, msBlk->block_cache[i].data, block, 0,
+							&next_index))) {
+				ERROR("Unable to read cache block [%x:%x]\n", block, offset);
+				return 0;
+			}
+			down(&msBlk->block_cache_mutex);
+			wake_up(&msBlk->waitq);
+			msBlk->block_cache[i].block = block;
+			msBlk->block_cache[i].next_index = next_index;
+			TRACE("Read cache block [%x:%x]\n", block, offset);
+		}
+
+		if(msBlk->block_cache[i].block != block) {
+			up(&msBlk->block_cache_mutex);
+			continue;
+		}
+
+		if((bytes = msBlk->block_cache[i].length - offset) >= length) {
+			if(buffer)
+				memcpy(buffer, msBlk->block_cache[i].data + offset, length);
+			if(msBlk->block_cache[i].length - offset == length) {
+				*next_block = msBlk->block_cache[i].next_index;
+				*next_offset = 0;
+			} else {
+				*next_block = block;
+				*next_offset = offset + length;
+			}
+
+			up(&msBlk->block_cache_mutex);
+			return return_length;
+		} else {
+			if(buffer) {
+				memcpy(buffer, msBlk->block_cache[i].data + offset, bytes);
+				buffer += bytes;
+			}
+			block = msBlk->block_cache[i].next_index;
+			up(&msBlk->block_cache_mutex);
+			length -= bytes;
+			offset = 0;
+		}
+	}
+}
+
+
+static int get_fragment_location(struct super_block *s, unsigned int fragment, unsigned int *fragment_start_block, unsigned int *fragment_size)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	unsigned int start_block = msBlk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
+	squashfs_fragment_entry fragment_entry;
+
+	if(msBlk->swap) {
+		squashfs_fragment_entry sfragment_entry;
+
+		if(!squashfs_get_cached_block(s, (char *) &sfragment_entry, start_block, offset,
+					sizeof(sfragment_entry), &start_block, &offset))
+			return 0;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
+	} else
+		if(!squashfs_get_cached_block(s, (char *) &fragment_entry, start_block, offset,
+					sizeof(fragment_entry), &start_block, &offset))
+			return 0;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+}
+
+
+void release_cached_fragment(squashfs_sb_info *msBlk, struct squashfs_fragment_cache *fragment)
+{
+	down(&msBlk->fragment_mutex);
+	fragment->locked --;
+	wake_up(&msBlk->fragment_wait_queue);
+	up(&msBlk->fragment_mutex);
+}
+
+
+struct squashfs_fragment_cache *get_cached_fragment(struct super_block *s, unsigned int start_block, int length)
+{
+	int i, n;
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+
+	for(;;) {
+		down(&msBlk->fragment_mutex);
+		for(i = 0; i < SQUASHFS_CACHED_FRAGMENTS && msBlk->fragment[i].block != start_block; i++);
+		if(i == SQUASHFS_CACHED_FRAGMENTS) {
+			for(i = msBlk->next_fragment, n = SQUASHFS_CACHED_FRAGMENTS;
+				n && msBlk->fragment[i].locked; n--, i = (i + 1) % SQUASHFS_CACHED_FRAGMENTS);
+
+			if(n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msBlk->fragment_wait_queue, &wait);
+				up(&msBlk->fragment_mutex);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msBlk->fragment_wait_queue, &wait);
+				continue;
+			}
+			msBlk->next_fragment = (msBlk->next_fragment + 1) % SQUASHFS_CACHED_FRAGMENTS;
+
+			if(msBlk->fragment[i].data == NULL)
+				if(!(msBlk->fragment[i].data = (unsigned char *)
+							kmalloc(SQUASHFS_FILE_MAX_SIZE, GFP_KERNEL))) {
+					ERROR("Failed to allocate fragment cache block\n");
+					up(&msBlk->fragment_mutex);
+					return NULL;
+				}
+
+			msBlk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msBlk->fragment[i].locked = 1;
+			up(&msBlk->fragment_mutex);
+			if(!(msBlk->fragment[i].length = read_data(s, msBlk->fragment[i].data, start_block, length,
+							NULL))) {
+				ERROR("Unable to read fragment cache block [%x]\n", start_block);
+				msBlk->fragment[i].locked = 0;
+				return NULL;
+			}
+			msBlk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %d, locked %d\n", i, msBlk->fragment[i].block, msBlk->fragment[i].locked);
+			return &msBlk->fragment[i];
+		}
+
+		msBlk->fragment[i].locked ++;
+		up(&msBlk->fragment_mutex);
+
+		TRACE("Got fragment %d, start block %d, locked %d\n", i, msBlk->fragment[i].block, msBlk->fragment[i].locked);
+		return &msBlk->fragment[i];
+	}
+}
+
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+static struct inode *squashfs_iget_1(struct super_block *s, squashfs_inode inode)
+{
+	struct inode *i = new_inode(s);
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) + sBlk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int next_block, next_offset;
+	squashfs_base_inode_header_1 inodeb;
+
+	TRACE("Entered squashfs_iget_1\n");
+
+	if(msBlk->swap) {
+		squashfs_base_inode_header_1 sinodeb;
+
+		if(!squashfs_get_cached_block(s, (char *) &sinodeb, block,  offset,
+					sizeof(sinodeb), &next_block, &next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_1(&inodeb, &sinodeb, sizeof(sinodeb));
+	} else
+		if(!squashfs_get_cached_block(s, (char *) &inodeb, block,  offset,
+					sizeof(inodeb), &next_block, &next_offset))
+			goto failed_read;
+
+	i->i_nlink = 1;
+
+	i->i_mtime.tv_sec = sBlk->mkfs_time;
+	i->i_atime.tv_sec = sBlk->mkfs_time;
+	i->i_ctime.tv_sec = sBlk->mkfs_time;
+
+	if(inodeb.inode_type != SQUASHFS_IPC_TYPE)
+		i->i_uid = msBlk->uid[((inodeb.inode_type - 1) / SQUASHFS_TYPES) * 16 + inodeb.uid];
+	i->i_ino = SQUASHFS_MK_VFS_INODE(block - sBlk->inode_table_start, offset);
+
+	i->i_mode = inodeb.mode;
+
+	switch(inodeb.inode_type == SQUASHFS_IPC_TYPE ? SQUASHFS_IPC_TYPE : (inodeb.inode_type - 1) % SQUASHFS_TYPES + 1) {
+		case SQUASHFS_FILE_TYPE: {
+			squashfs_reg_inode_header_1 inodep;
+
+			if(msBlk->swap) {
+				squashfs_reg_inode_header_1 sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_1(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = inodep.file_size;
+			i->i_fop = &generic_ro_fops;
+			if(sBlk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else if(sBlk->block_size == 4096)
+				i->i_data.a_ops = &squashfs_aops_4K;
+			else
+				i->i_data.a_ops = &squashfs_aops_lessthan4K;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep.mtime;
+			i->i_atime.tv_sec = inodep.mtime;
+			i->i_ctime.tv_sec = inodep.mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = SQUASHFS_INVALID_BLK;
+			SQUASHFS_I(i)->u.s1.fragment_offset = 0;
+			SQUASHFS_I(i)->start_block = inodep.start_block;
+			SQUASHFS_I(i)->block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			TRACE("File inode %x:%x, start_block %x, block_list_start %x, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset, inodep.start_block, next_block, next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			squashfs_dir_inode_header_1 inodep;
+
+			if(msBlk->swap) {
+				squashfs_dir_inode_header_1 sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_1(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = inodep.file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep.mtime;
+			i->i_atime.tv_sec = inodep.mtime;
+			i->i_ctime.tv_sec = inodep.mtime;
+			SQUASHFS_I(i)->start_block = inodep.start_block;
+			SQUASHFS_I(i)->offset = inodep.offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			TRACE("Directory inode %x:%x, start_block %x, offset %x\n", SQUASHFS_INODE_BLK(inode), offset,
+					inodep.start_block, inodep.offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			squashfs_symlink_inode_header_1 inodep;
+
+			if(msBlk->swap) {
+				squashfs_symlink_inode_header_1 sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = inodep.symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			TRACE("Symbolic link inode %x:%x, start_block %x, offset %x\n",
+				SQUASHFS_INODE_BLK(inode), offset, next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			squashfs_dev_inode_header_1 inodep;
+
+			if(msBlk->swap) {
+				squashfs_dev_inode_header_1 sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_1(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = 0;
+			i->i_mode |= (inodeb.inode_type == SQUASHFS_CHRDEV_TYPE) ? S_IFCHR : S_IFBLK;
+			init_special_inode(i, i->i_mode, old_decode_dev(inodep.rdev));
+			TRACE("Device inode %x:%x, rdev %x\n", SQUASHFS_INODE_BLK(inode), offset, inodep.rdev);
+			break;
+		 }
+		 case SQUASHFS_IPC_TYPE: {
+			squashfs_ipc_inode_header_1 inodep;
+
+			if(msBlk->swap) {
+				squashfs_ipc_inode_header_1 sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER_1(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = 0;
+			i->i_mode |= (inodep.type == SQUASHFS_FIFO_TYPE) ? S_IFIFO : S_IFSOCK;
+			i->i_uid = msBlk->uid[inodep.offset * 16 + inodeb.uid];
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n", inodeb.inode_type);
+				goto failed_read1;
+	}
+
+	if(inodeb.guid == 15)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msBlk->guid[inodeb.guid];
+
+	insert_inode_hash(i);
+	return i;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return NULL;
+}
+#endif
+
+
+static struct inode *squashfs_iget(struct super_block *s, squashfs_inode inode)
+{
+	struct inode *i = new_inode(s);
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) + sBlk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int next_block, next_offset;
+	squashfs_base_inode_header inodeb;
+
+	TRACE("Entered squashfs_iget\n");
+
+	if(msBlk->swap) {
+		squashfs_base_inode_header sinodeb;
+
+		if(!squashfs_get_cached_block(s, (char *) &sinodeb, block,  offset,
+					sizeof(sinodeb), &next_block, &next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER(&inodeb, &sinodeb, sizeof(sinodeb));
+	} else
+		if(!squashfs_get_cached_block(s, (char *) &inodeb, block,  offset,
+					sizeof(inodeb), &next_block, &next_offset))
+			goto failed_read;
+
+	i->i_nlink = 1;
+
+	i->i_mtime.tv_sec = sBlk->mkfs_time;
+	i->i_atime.tv_sec = sBlk->mkfs_time;
+	i->i_ctime.tv_sec = sBlk->mkfs_time;
+
+	i->i_uid = msBlk->uid[inodeb.uid];
+	i->i_ino = SQUASHFS_MK_VFS_INODE(block - sBlk->inode_table_start, offset);
+
+	i->i_mode = inodeb.mode;
+
+	switch(inodeb.inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			squashfs_reg_inode_header inodep;
+
+			if(msBlk->swap) {
+				squashfs_reg_inode_header sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			SQUASHFS_I(i)->u.s1.fragment_start_block = SQUASHFS_INVALID_BLK;
+			if(inodep.fragment != SQUASHFS_INVALID_BLK && !get_fragment_location(s, inodep.fragment,
+							&SQUASHFS_I(i)->u.s1.fragment_start_block, &SQUASHFS_I(i)->u.s1.fragment_size))
+				goto failed_read;
+
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep.offset;
+			i->i_size = inodep.file_size;
+			i->i_fop = &generic_ro_fops;
+			if(sBlk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep.mtime;
+			i->i_atime.tv_sec = inodep.mtime;
+			i->i_ctime.tv_sec = inodep.mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->start_block = inodep.start_block;
+			SQUASHFS_I(i)->block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			TRACE("File inode %x:%x, start_block %x, block_list_start %x, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset, inodep.start_block, next_block, next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			squashfs_dir_inode_header inodep;
+
+			if(msBlk->swap) {
+				squashfs_dir_inode_header sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = inodep.file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep.mtime;
+			i->i_atime.tv_sec = inodep.mtime;
+			i->i_ctime.tv_sec = inodep.mtime;
+			SQUASHFS_I(i)->start_block = inodep.start_block;
+			SQUASHFS_I(i)->offset = inodep.offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			TRACE("Directory inode %x:%x, start_block %x, offset %x\n", SQUASHFS_INODE_BLK(inode), offset,
+					inodep.start_block, inodep.offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			squashfs_ldir_inode_header inodep;
+
+			if(msBlk->swap) {
+				squashfs_ldir_inode_header sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = inodep.file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep.mtime;
+			i->i_atime.tv_sec = inodep.mtime;
+			i->i_ctime.tv_sec = inodep.mtime;
+			SQUASHFS_I(i)->start_block = inodep.start_block;
+			SQUASHFS_I(i)->offset = inodep.offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset = next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = inodep.i_count;
+			TRACE("Long directory inode %x:%x, start_block %x, offset %x\n", SQUASHFS_INODE_BLK(inode), offset,
+					inodep.start_block, inodep.offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			squashfs_symlink_inode_header inodep;
+
+			if(msBlk->swap) {
+				squashfs_symlink_inode_header sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = inodep.symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			TRACE("Symbolic link inode %x:%x, start_block %x, offset %x\n",
+				SQUASHFS_INODE_BLK(inode), offset, next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			squashfs_dev_inode_header inodep;
+
+			if(msBlk->swap) {
+				squashfs_dev_inode_header sinodep;
+
+				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
+							&next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER(&inodep, &sinodep);
+			} else
+				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
+							&next_block, &next_offset))
+					goto failed_read;
+
+			i->i_size = 0;
+			i->i_mode |= (inodeb.inode_type == SQUASHFS_CHRDEV_TYPE) ? S_IFCHR : S_IFBLK;
+			init_special_inode(i, i->i_mode, old_decode_dev(inodep.rdev));
+			TRACE("Device inode %x:%x, rdev %x\n", SQUASHFS_INODE_BLK(inode), offset, inodep.rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			i->i_size = 0;
+			i->i_mode |= (inodeb.inode_type == SQUASHFS_FIFO_TYPE) ? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n", inodeb.inode_type);
+				goto failed_read1;
+	}
+
+	if(inodeb.guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msBlk->guid[inodeb.guid];
+
+	insert_inode_hash(i);
+	return i;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return NULL;
+}
+
+
+static int squashfs_fill_super(struct super_block *s,
+		void *data, int silent)
+{
+	squashfs_sb_info *msBlk;
+	squashfs_super_block *sBlk;
+	int i;
+	char b[BDEVNAME_SIZE];
+
+	TRACE("Entered squashfs_read_superblock\n");
+
+	if(!(s->s_fs_info = (void *) kmalloc(sizeof(squashfs_sb_info), GFP_KERNEL))) {
+		ERROR("Failed to allocate superblock\n");
+		return -ENOMEM;
+	}
+	msBlk = (squashfs_sb_info *) s->s_fs_info;
+	sBlk = &msBlk->sBlk;
+
+	msBlk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msBlk->devblksize_log2 = ffz(~msBlk->devblksize);
+
+	init_MUTEX(&msBlk->read_page_mutex);
+	init_MUTEX(&msBlk->block_cache_mutex);
+	init_MUTEX(&msBlk->fragment_mutex);
+
+	init_waitqueue_head(&msBlk->waitq);
+	init_waitqueue_head(&msBlk->fragment_wait_queue);
+
+	if(!read_data(s, (char *) sBlk, SQUASHFS_START, sizeof(squashfs_super_block) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		SERROR("unable to read superblock\n");
+		goto failed_mount;
+	}
+
+	/* Check it is a SQUASHFS superblock */
+	msBlk->swap = 0;
+	if((s->s_magic = sBlk->s_magic) != SQUASHFS_MAGIC) {
+		if(sBlk->s_magic == SQUASHFS_MAGIC_SWAP) {
+			squashfs_super_block sblk;
+			WARNING("Mounting a different endian SQUASHFS filesystem on %s\n", bdevname(s->s_bdev, b));
+			SQUASHFS_SWAP_SUPER_BLOCK(&sblk, sBlk);
+			memcpy(sBlk, &sblk, sizeof(squashfs_super_block));
+			msBlk->swap = 1;
+		} else  {
+			SERROR("Can't find a SQUASHFS superblock on %s\n", bdevname(s->s_bdev, b));
+			goto failed_mount;
+		}
+	}
+
+	/* Check the MAJOR & MINOR versions */
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+	if((sBlk->s_major != 1) && (sBlk->s_major != 2 || sBlk->s_minor > SQUASHFS_MINOR)) {
+		SERROR("Major/Minor mismatch, filesystem is (%d:%d), I support (1 : x) or (2 : <= %d)\n",
+				sBlk->s_major, sBlk->s_minor, SQUASHFS_MINOR);
+		goto failed_mount;
+	}
+	if(sBlk->s_major == 1)
+		sBlk->block_size = sBlk->block_size_1;
+#else
+	if(sBlk->s_major != SQUASHFS_MAJOR || sBlk->s_minor > SQUASHFS_MINOR) {
+		SERROR("Major/Minor mismatch, filesystem is (%d:%d), I support (%d: <= %d)\n",
+				sBlk->s_major, sBlk->s_minor, SQUASHFS_MAJOR, SQUASHFS_MINOR);
+		goto failed_mount;
+	}
+#endif
+
+	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
+	TRACE("Inodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sBlk->flags) ? "un" : "");
+	TRACE("Data is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sBlk->flags) ? "un" : "");
+	TRACE("Check data is %s present in the filesystem\n", SQUASHFS_CHECK_DATA(sBlk->flags) ? "" : "not");
+	TRACE("Filesystem size %d bytes\n", sBlk->bytes_used);
+	TRACE("Block size %d\n", sBlk->block_size);
+	TRACE("Number of inodes %d\n", sBlk->inodes);
+	if(sBlk->s_major > 1)
+		TRACE("Number of fragments %d\n", sBlk->fragments);
+	TRACE("Number of uids %d\n", sBlk->no_uids);
+	TRACE("Number of gids %d\n", sBlk->no_guids);
+	TRACE("sBlk->inode_table_start %x\n", sBlk->inode_table_start);
+	TRACE("sBlk->directory_table_start %x\n", sBlk->directory_table_start);
+		if(sBlk->s_major > 1)
+	TRACE("sBlk->fragment_table_start %x\n", sBlk->fragment_table_start);
+	TRACE("sBlk->uid_start %x\n", sBlk->uid_start);
+
+	s->s_flags |= MS_RDONLY;
+	s->s_op = &squashfs_ops;
+
+	/* Init inode_table block pointer array */
+	if(!(msBlk->block_cache = (squashfs_cache *) kmalloc(sizeof(squashfs_cache) * SQUASHFS_CACHED_BLKS, GFP_KERNEL))) {
+		ERROR("Failed to allocate block cache\n");
+		goto failed_mount;
+	}
+
+	for(i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+		msBlk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msBlk->next_cache = 0;
+
+	/* Allocate read_data block */
+	msBlk->read_size = (sBlk->block_size < SQUASHFS_METADATA_SIZE) ? SQUASHFS_METADATA_SIZE : sBlk->block_size;
+	if(!(msBlk->read_data = (char *) kmalloc(msBlk->read_size, GFP_KERNEL))) {
+		ERROR("Failed to allocate read_data block\n");
+		goto failed_mount1;
+	}
+
+	/* Allocate read_page block */
+	if(sBlk->block_size > PAGE_CACHE_SIZE) {
+		if(!(msBlk->read_page = (char *) kmalloc(sBlk->block_size, GFP_KERNEL))) {
+			ERROR("Failed to allocate read_page block\n");
+			goto failed_mount2;
+		}
+	} else
+		msBlk->read_page = NULL;
+
+	/* Allocate uid and gid tables */
+	if(!(msBlk->uid = (squashfs_uid *) kmalloc((sBlk->no_uids +
+		sBlk->no_guids) * sizeof(squashfs_uid), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto failed_mount3;
+	}
+	msBlk->guid = msBlk->uid + sBlk->no_uids;
+
+	if(msBlk->swap) {
+		squashfs_uid suid[sBlk->no_uids + sBlk->no_guids];
+
+		if(!read_data(s, (char *) &suid, sBlk->uid_start, ((sBlk->no_uids + sBlk->no_guids) *
+				sizeof(squashfs_uid)) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			SERROR("unable to read uid/gid table\n");
+			goto failed_mount4;
+		}
+		SQUASHFS_SWAP_DATA(msBlk->uid, suid, (sBlk->no_uids + sBlk->no_guids), (sizeof(squashfs_uid) * 8));
+	} else
+		if(!read_data(s, (char *) msBlk->uid, sBlk->uid_start, ((sBlk->no_uids + sBlk->no_guids) *
+				sizeof(squashfs_uid)) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			SERROR("unable to read uid/gid table\n");
+			goto failed_mount4;
+		}
+
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+	if(sBlk->s_major == 1) {
+		msBlk->iget = squashfs_iget_1;
+		msBlk->read_blocklist = read_blocklist_1;
+		msBlk->fragment = NULL;
+		msBlk->fragment_index = NULL;
+		goto allocate_root;
+	}
+#endif
+	msBlk->iget = squashfs_iget;
+	msBlk->read_blocklist = read_blocklist;
+
+	if(!(msBlk->fragment = (struct squashfs_fragment_cache *) kmalloc(sizeof(struct squashfs_fragment_cache) * SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL))) {
+		ERROR("Failed to allocate fragment block cache\n");
+		goto failed_mount4;
+	}
+
+	for(i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msBlk->fragment[i].locked = 0;
+		msBlk->fragment[i].block = SQUASHFS_INVALID_BLK;
+		msBlk->fragment[i].data = NULL;
+	}
+
+	msBlk->next_fragment = 0;
+
+	/* Allocate fragment index table */
+	if(!(msBlk->fragment_index = (squashfs_fragment_index *) kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto failed_mount5;
+	}
+
+	if(SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments) &&
+	 	!read_data(s, (char *) msBlk->fragment_index, sBlk->fragment_table_start,
+		SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			SERROR("unable to read fragment index table\n");
+			goto failed_mount6;
+	}
+
+	if(msBlk->swap) {
+		int i;
+		squashfs_fragment_index fragment;
+
+		for(i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sBlk->fragments); i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment), &msBlk->fragment_index[i], 1);
+			msBlk->fragment_index[i] = fragment;
+		}
+	}
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+allocate_root:
+#endif
+	if(!(s->s_root = d_alloc_root((msBlk->iget)(s, sBlk->root_inode)))) {
+		ERROR("Root inode create failed\n");
+		goto failed_mount5;
+	}
+
+	TRACE("Leaving squashfs_read_super\n");
+	return 0;
+
+failed_mount6:
+	kfree(msBlk->fragment_index);
+failed_mount5:
+	kfree(msBlk->fragment);
+failed_mount4:
+	kfree(msBlk->uid);
+failed_mount3:
+	kfree(msBlk->read_page);
+failed_mount2:
+	kfree(msBlk->read_data);
+failed_mount1:
+	kfree(msBlk->block_cache);
+failed_mount:
+	kfree(s->s_fs_info);
+	s->s_fs_info = NULL;
+	return -EINVAL;
+}
+
+
+static int squashfs_statfs(struct super_block *s, struct kstatfs *buf)
+{
+	squashfs_super_block *sBlk = &((squashfs_sb_info *)s->s_fs_info)->sBlk;
+
+	TRACE("Entered squashfs_statfs\n");
+	buf->f_type = SQUASHFS_MAGIC;
+	buf->f_bsize = sBlk->block_size;
+	buf->f_blocks = ((sBlk->bytes_used - 1) >> sBlk->block_log) + 1;
+	buf->f_bfree = buf->f_bavail = 0;
+	buf->f_files = sBlk->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SQUASHFS_NAME_LEN;
+	return 0;
+}
+
+
+static int squashfs_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes;
+	unsigned int block = SQUASHFS_I(inode)->start_block;
+	int offset = SQUASHFS_I(inode)->offset;
+	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_symlink_readpage, page index %d, start block %x, offset %x\n",
+		page->index, SQUASHFS_I(inode)->start_block, SQUASHFS_I(inode)->offset);
+
+	for(length = 0; length < index; length += bytes) {
+		if(!(bytes = squashfs_get_cached_block(inode->i_sb, NULL, block, offset,
+					PAGE_CACHE_SIZE, &block, &offset))) {
+			ERROR("Unable to read symbolic link [%x:%x]\n", block, offset);
+			goto skip_read;
+		}
+	}
+
+	if(length != index) {
+		ERROR("(squashfs_symlink_readpage) length != index\n");
+		bytes = 0;
+		goto skip_read;
+	}
+
+	bytes = (inode->i_size - length) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE : inode->i_size - length;
+	if(!(bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block, offset, bytes, &block, &offset)))
+		ERROR("Unable to read symbolic link [%x:%x]\n", block, offset);
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+#define SIZE 256
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+static unsigned int read_blocklist_1(struct inode *inode, int index, int readahead_blks,
+		char *block_list, unsigned short **block_p, unsigned int *bsize)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
+	unsigned short *block_listp;
+	int i = 0;
+	int block_ptr = SQUASHFS_I(inode)->block_list_start;
+	int offset = SQUASHFS_I(inode)->offset;
+	unsigned int block = SQUASHFS_I(inode)->start_block;
+
+	for(;;) {
+		int blocks = (index + readahead_blks - i);
+		if(blocks > (SIZE >> 1)) {
+			if((index - i) <= (SIZE >> 1))
+				blocks = index - i;
+			else
+				blocks = SIZE >> 1;
+		}
+
+		if(msBlk->swap) {
+			unsigned char sblock_list[SIZE];
+			if(!squashfs_get_cached_block(inode->i_sb, (char *) sblock_list, block_ptr, offset, blocks << 1, &block_ptr, &offset)) {
+				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
+				return 0;
+			}
+			SQUASHFS_SWAP_SHORTS(((unsigned short *)block_list), ((unsigned short *)sblock_list), blocks);
+		} else
+			if(!squashfs_get_cached_block(inode->i_sb, (char *) block_list, block_ptr, offset, blocks << 1, &block_ptr, &offset)) {
+				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
+				return 0;
+			}
+		for(block_listp = (unsigned short *) block_list; i < index && blocks; i ++, block_listp ++, blocks --)
+			block += SQUASHFS_COMPRESSED_SIZE(*block_listp);
+		if(blocks >= readahead_blks)
+			break;
+	}
+
+	if(bsize)
+		*bsize = SQUASHFS_COMPRESSED_SIZE(*block_listp) | (!SQUASHFS_COMPRESSED(*block_listp) ? SQUASHFS_COMPRESSED_BIT_BLOCK : 0);
+	else
+		*block_p = block_listp;
+	return block;
+}
+#endif
+
+
+static unsigned int read_blocklist(struct inode *inode, int index, int readahead_blks,
+		char *block_list, unsigned short **block_p, unsigned int *bsize)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
+	unsigned int *block_listp;
+	int i = 0;
+	int block_ptr = SQUASHFS_I(inode)->block_list_start;
+	int offset = SQUASHFS_I(inode)->offset;
+	unsigned int block = SQUASHFS_I(inode)->start_block;
+
+	for(;;) {
+		int blocks = (index + readahead_blks - i);
+		if(blocks > (SIZE >> 2)) {
+			if((index - i) <= (SIZE >> 2))
+				blocks = index - i;
+			else
+				blocks = SIZE >> 2;
+		}
+
+		if(msBlk->swap) {
+			unsigned char sblock_list[SIZE];
+			if(!squashfs_get_cached_block(inode->i_sb, (char *) sblock_list, block_ptr, offset, blocks << 2, &block_ptr, &offset)) {
+				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
+				return 0;
+			}
+			SQUASHFS_SWAP_INTS(((unsigned int *)block_list), ((unsigned int *)sblock_list), blocks);
+		} else
+			if(!squashfs_get_cached_block(inode->i_sb, (char *) block_list, block_ptr, offset, blocks << 2, &block_ptr, &offset)) {
+				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
+				return 0;
+			}
+		for(block_listp = (unsigned int *) block_list; i < index && blocks; i ++, block_listp ++, blocks --)
+			block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
+		if(blocks >= readahead_blks)
+			break;
+	}
+
+	*bsize = *block_listp;
+	return block;
+}
+
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	unsigned char block_list[SIZE];
+	unsigned int bsize, block, i = 0, bytes = 0, byte_offset = 0;
+	int index = page->index >> (sBlk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr = kmap(page);
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msBlk->read_page;
+
+	int mask = (1 << (sBlk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+
+	TRACE("Entered squashfs_readpage, page index %x, start block %x\n", (unsigned int) page->index,
+		SQUASHFS_I(inode)->start_block);
+
+	if(page->index >= ((inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)) {
+		goto skip_read;
+	}
+
+	if(SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK || index < (inode->i_size >> sBlk->block_log)) {
+		if((block = (msBlk->read_blocklist)(inode, index, 1, block_list, NULL, &bsize)) == 0)
+			goto skip_read;
+
+		down(&msBlk->read_page_mutex);
+		if(!(bytes = read_data(inode->i_sb, msBlk->read_page, block, bsize, NULL))) {
+			ERROR("Unable to read page, block %x, size %x\n", block, bsize);
+			up(&msBlk->read_page_mutex);
+			goto skip_read;
+		}
+	} else {
+		if((fragment = get_cached_fragment(inode->i_sb, SQUASHFS_I(inode)->u.s1.fragment_start_block, SQUASHFS_I(inode)->u.s1.fragment_size)) == NULL) {
+			ERROR("Unable to read page, block %x, size %x\n", SQUASHFS_I(inode)->u.s1.fragment_start_block, (int) SQUASHFS_I(inode)->u.s1.fragment_size);
+			goto skip_read;
+		}
+		bytes = SQUASHFS_I(inode)->u.s1.fragment_offset + (inode->i_size & (sBlk->block_size - 1));
+		byte_offset = SQUASHFS_I(inode)->u.s1.fragment_offset;
+		data_ptr = fragment->data;
+	}
+
+	for(i = start_index; i <= end_index && byte_offset < bytes; i++, byte_offset += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int available_bytes = (bytes - byte_offset) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE : bytes - byte_offset;
+
+		TRACE("bytes %d, i %d, byte_offset %d, available_bytes %d\n", bytes, i, byte_offset, available_bytes);
+
+		if(i == page->index)  {
+			memcpy(pageaddr, data_ptr + byte_offset, available_bytes);
+			memset(pageaddr + available_bytes, 0, PAGE_CACHE_SIZE - available_bytes);
+			kunmap(page);
+			flush_dcache_page(page);
+			SetPageUptodate(page);
+			unlock_page(page);
+		} else if((push_page = grab_cache_page_nowait(page->mapping, i))) {
+ 			void *pageaddr = kmap(push_page);
+			memcpy(pageaddr, data_ptr + byte_offset, available_bytes);
+			memset(pageaddr + available_bytes, 0, PAGE_CACHE_SIZE - available_bytes);
+			kunmap(push_page);
+			flush_dcache_page(push_page);
+			SetPageUptodate(push_page);
+			unlock_page(push_page);
+			page_cache_release(push_page);
+		}
+	}
+
+	if(SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK || index < (inode->i_size >> sBlk->block_log))
+		up(&msBlk->read_page_mutex);
+	else
+		release_cached_fragment(msBlk, fragment);
+
+	return 0;
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+static int squashfs_readpage4K(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	unsigned char block_list[SIZE];
+	unsigned int bsize, block, bytes = 0;
+ 	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_readpage4K, page index %x, start block %x\n", (unsigned int) page->index,
+		SQUASHFS_I(inode)->start_block);
+
+	if(page->index >= ((inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)) {
+		goto skip_read;
+	}
+
+	if(SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK || page->index < (inode->i_size >> sBlk->block_log)) {
+		block = (msBlk->read_blocklist)(inode, page->index, 1, block_list, NULL, &bsize);
+
+		if(!(bytes = read_data(inode->i_sb, pageaddr, block, bsize, NULL)))
+			ERROR("Unable to read page, block %x, size %x\n", block, bsize);
+	} else {
+		struct squashfs_fragment_cache *fragment;
+
+		if((fragment = get_cached_fragment(inode->i_sb, SQUASHFS_I(inode)->u.s1.fragment_start_block, SQUASHFS_I(inode)->u.s1.fragment_size)) == NULL)
+			ERROR("Unable to read page, block %x, size %x\n", SQUASHFS_I(inode)->u.s1.fragment_start_block, (int) SQUASHFS_I(inode)->u.s1.fragment_size);
+		else {
+			bytes = inode->i_size & (sBlk->block_size - 1);
+			memcpy(pageaddr, fragment->data + SQUASHFS_I(inode)->u.s1.fragment_offset, bytes);
+			release_cached_fragment(msBlk, fragment);
+		}
+	}
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+static int squashfs_readpage_lessthan4K(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	unsigned char block_list[SIZE];
+	unsigned short *block_listp, block, bytes = 0;
+	int index = page->index << (PAGE_CACHE_SHIFT - sBlk->block_log);
+	int file_blocks = ((inode->i_size - 1) >> sBlk->block_log) + 1;
+	int readahead_blks = 1 << (PAGE_CACHE_SHIFT - sBlk->block_log);
+ 	void *pageaddr = kmap(page);
+
+	int i_end = index + (1 << (PAGE_CACHE_SHIFT - sBlk->block_log));
+	int byte;
+
+	TRACE("Entered squashfs_readpage_lessthan4K, page index %x, start block %x\n", (unsigned int) page->index,
+		SQUASHFS_I(inode)->start_block);
+
+	block = read_blocklist_1(inode, index, readahead_blks, block_list, &block_listp, NULL);
+
+	if(i_end > file_blocks)
+		i_end = file_blocks;
+
+	while(index < i_end) {
+		int c_byte = !SQUASHFS_COMPRESSED(*block_listp) ? SQUASHFS_COMPRESSED_SIZE(*block_listp) | SQUASHFS_COMPRESSED_BIT_BLOCK : *block_listp;
+		if(!(byte = read_data(inode->i_sb, pageaddr, block, c_byte, NULL))) {
+			ERROR("Unable to read page, block %x, size %x\n", block, *block_listp);
+			goto skip_read;
+		}
+		block += SQUASHFS_COMPRESSED_SIZE(*block_listp);
+		pageaddr += byte;
+		bytes += byte;
+		index ++;
+		block_listp ++;
+	}
+
+skip_read:
+	memset(pageaddr, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+#endif
+
+
+static int get_dir_index_using_offset(struct super_block *s, unsigned int *next_block,
+	unsigned int *next_offset, unsigned int index_start, unsigned int index_offset,
+	int i_count, long long f_pos)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	int i, length = 0;
+	squashfs_dir_index index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n", i_count, (unsigned int) f_pos);
+
+	if(f_pos == 0)
+		return 0;
+
+	for(i = 0; i < i_count; i++) {
+		if(msBlk->swap) {
+			squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex, index_start, index_offset,
+				sizeof(sindex), &index_start, &index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index, index_start, index_offset,
+				sizeof(index), &index_start, &index_offset);
+
+		if(index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+				index.size + 1, &index_start, &index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sBlk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, unsigned int *next_block,
+	unsigned int *next_offset, unsigned int index_start, unsigned int index_offset,
+	int i_count, const char *name, int size)
+{
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	int i, length = 0;
+	char buffer[sizeof(squashfs_dir_index) + SQUASHFS_NAME_LEN + 1];
+	squashfs_dir_index *index = (squashfs_dir_index *) buffer;
+	char str[SQUASHFS_NAME_LEN + 1];
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for(i = 0; i < i_count; i++) {
+		if(msBlk->swap) {
+			squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex, index_start, index_offset,
+				sizeof(sindex), &index_start, &index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index, index_start, index_offset,
+				sizeof(squashfs_dir_index), &index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start, index_offset,
+				index->size + 1, &index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if(strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sBlk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	return length;
+}
+
+
+static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)i->i_sb->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	int next_block = SQUASHFS_I(i)->start_block + sBlk->directory_table_start, next_offset =
+		SQUASHFS_I(i)->offset, length = 0, dirs_read = 0, dir_count;
+	squashfs_dir_header dirh;
+	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1];
+	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
+
+	TRACE("Entered squashfs_readdir [%x:%x]\n", next_block, next_offset);
+
+	lock_kernel();
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset, SQUASHFS_I(i)->u.s2.directory_index_start,
+		SQUASHFS_I(i)->u.s2.directory_index_offset, SQUASHFS_I(i)->u.s2.directory_index_count, file->f_pos);
+
+	while(length < i->i_size) {
+		/* read directory header */
+		if(msBlk->swap) {
+			squashfs_dir_header sdirh;
+			if(!squashfs_get_cached_block(i->i_sb, (char *) &sdirh, next_block,
+						next_offset, sizeof(sdirh), &next_block, &next_offset))
+				goto failed_read;
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if(!squashfs_get_cached_block(i->i_sb, (char *) &dirh, next_block,
+						next_offset, sizeof(dirh), &next_block, &next_offset))
+				goto failed_read;
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while(dir_count--) {
+			if(msBlk->swap) {
+				squashfs_dir_entry sdire;
+				if(!squashfs_get_cached_block(i->i_sb, (char *) &sdire, next_block,
+							next_offset, sizeof(sdire), &next_block, &next_offset))
+					goto failed_read;
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if(!squashfs_get_cached_block(i->i_sb, (char *) dire, next_block,
+							next_offset, sizeof(*dire), &next_block, &next_offset))
+					goto failed_read;
+				length += sizeof(*dire);
+			}
+
+			if(!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+						next_offset, dire->size + 1, &next_block, &next_offset))
+				goto failed_read;
+			length += dire->size + 1;
+
+			if(file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n", (unsigned int) dirent,
+			dire->name, dire->size + 1, (int) file->f_pos,
+			dirh.start_block, dire->offset, squashfs_filetype_table[dire->type]);
+
+			if(filldir(dirent, dire->name, dire->size + 1, file->f_pos, SQUASHFS_MK_VFS_INODE(dirh.start_block,
+							dire->offset), squashfs_filetype_table[dire->type]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+				unlock_kernel();
+				return dirs_read;
+			}
+
+			file->f_pos = length;
+			dirs_read ++;
+		}
+	}
+
+	unlock_kernel();
+	return dirs_read;
+
+failed_read:
+	unlock_kernel();
+	ERROR("Unable to read directory block [%x:%x]\n", next_block, next_offset);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry, struct nameidata *nd)
+{
+	const char *name =dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	squashfs_sb_info *msBlk = (squashfs_sb_info *)i->i_sb->s_fs_info;
+	squashfs_super_block *sBlk = &msBlk->sBlk;
+	int next_block = SQUASHFS_I(i)->start_block + sBlk->directory_table_start, next_offset =
+		SQUASHFS_I(i)->offset, length = 0, dir_count;
+	squashfs_dir_header dirh;
+	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN];
+	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
+	int squashfs_2_1 = sBlk->s_major == 2 && sBlk->s_minor == 1;
+
+	TRACE("Entered squashfs_lookup [%x:%x]\n", next_block, next_offset);
+
+	lock_kernel();
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset, SQUASHFS_I(i)->u.s2.directory_index_start,
+		SQUASHFS_I(i)->u.s2.directory_index_offset, SQUASHFS_I(i)->u.s2.directory_index_count, name, len);
+
+	while(length < i->i_size) {
+		/* read directory header */
+		if(msBlk->swap) {
+			squashfs_dir_header sdirh;
+			if(!squashfs_get_cached_block(i->i_sb, (char *) &sdirh, next_block, next_offset,
+						sizeof(sdirh), &next_block, &next_offset))
+				goto failed_read;
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if(!squashfs_get_cached_block(i->i_sb, (char *) &dirh, next_block, next_offset,
+						sizeof(dirh), &next_block, &next_offset))
+				goto failed_read;
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while(dir_count--) {
+			if(msBlk->swap) {
+				squashfs_dir_entry sdire;
+				if(!squashfs_get_cached_block(i->i_sb, (char *) &sdire,
+							next_block,next_offset, sizeof(sdire), &next_block, &next_offset))
+					goto failed_read;
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if(!squashfs_get_cached_block(i->i_sb, (char *) dire,
+							next_block,next_offset, sizeof(*dire), &next_block, &next_offset))
+					goto failed_read;
+				length += sizeof(*dire);
+			}
+
+			if(!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset, dire->size + 1, &next_block, &next_offset))
+				goto failed_read;
+			length += dire->size + 1;
+
+			if(squashfs_2_1 && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if((len == dire->size + 1) && !strncmp(name, dire->name, len)) {
+				squashfs_inode ino = SQUASHFS_MKINODE(dirh.start_block, dire->offset);
+
+				TRACE("calling squashfs_iget for directory entry %s, inode %x:%x\n",
+						name, dirh.start_block, dire->offset);
+
+				inode = (msBlk->iget)(i->i_sb, ino);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	d_add(dentry, inode);
+	unlock_kernel();
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%x:%x]\n", next_block, next_offset);
+	goto exit_loop;
+}
+
+
+static void squashfs_put_super(struct super_block *s)
+{
+	int i;
+
+	if(s->s_fs_info) {
+		squashfs_sb_info *sbi = (squashfs_sb_info *) s->s_fs_info;
+		if(sbi->block_cache) {
+			for(i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+				if(sbi->block_cache[i].block != SQUASHFS_INVALID_BLK)
+					kfree(sbi->block_cache[i].data);
+			kfree(sbi->block_cache);
+		}
+		if(sbi->read_data) kfree(sbi->read_data);
+		if(sbi->read_page) kfree(sbi->read_page);
+		if(sbi->uid) kfree(sbi->uid);
+		if(sbi->fragment) {
+			for(i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++)
+				if(sbi->fragment[i].data != NULL)
+					kfree(sbi->fragment[i].data);
+			kfree(sbi->fragment);
+		}
+		if(sbi->fragment_index) kfree(sbi->fragment_index);
+		kfree(s->s_fs_info);
+		s->s_fs_info = NULL;
+	}
+}
+
+
+static struct super_block *squashfs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super);
+}
+
+
+static int __init init_squashfs_fs(void)
+{
+	int err = init_inodecache();
+	if(err)
+		return err;
+
+	printk(KERN_INFO "Squashfs 2.1-r2 (released 2004/12/15) (C) 2002-2004 Phillip Lougher\n");
+
+	if(!(stream.workspace = (char *) vmalloc(zlib_inflate_workspacesize()))) {
+		ERROR("Failed to allocate zlib workspace\n");
+		destroy_inodecache();
+		return -ENOMEM;
+	}
+
+	if((err = register_filesystem(&squashfs_fs_type))) {
+		vfree(stream.workspace);
+		destroy_inodecache();
+	}
+
+	return err;
+}
+
+
+static void __exit exit_squashfs_fs(void)
+{
+	vfree(stream.workspace);
+	unregister_filesystem(&squashfs_fs_type);
+	destroy_inodecache();
+}
+
+
+static kmem_cache_t * squashfs_inode_cachep;
+
+
+static struct inode *squashfs_alloc_inode(struct super_block *sb)
+{
+	struct squashfs_inode_info *ei;
+	ei = (struct squashfs_inode_info *)kmem_cache_alloc(squashfs_inode_cachep, SLAB_KERNEL);
+	if (!ei)
+		return NULL;
+	return &ei->vfs_inode;
+}
+
+
+static void squashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));
+}
+
+
+static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct squashfs_inode_info *ei = (struct squashfs_inode_info *) foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&ei->vfs_inode);
+}
+
+
+static int init_inodecache(void)
+{
+	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
+					     sizeof(struct squashfs_inode_info),
+					     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT,
+					     init_once, NULL);
+	if (squashfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+
+static void destroy_inodecache(void)
+{
+	if (kmem_cache_destroy(squashfs_inode_cachep))
+		printk(KERN_INFO "squashfs_inode_cache: not all structures were freed\n");
+}
+
+
+module_init(init_squashfs_fs);
+module_exit(exit_squashfs_fs);
+MODULE_DESCRIPTION("squashfs, a compressed read-only filesystem");
+MODULE_AUTHOR("Phillip Lougher <plougher@users.sourceforge.net>");
+MODULE_LICENSE("GPL");
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/asm-ppc/ibm4xx.h linux-2.6.12/include/asm-ppc/ibm4xx.h
--- linux-2.6.12.orig/include/asm-ppc/ibm4xx.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/include/asm-ppc/ibm4xx.h	2005-06-27 22:11:26.000000000 +0200
@@ -43,7 +43,7 @@
 #include <platforms/4xx/redwood.h>
 #endif
 
-#if defined(CONFIG_REDWOOD_5)
+#if defined(CONFIG_IBM_PALLAS)
 #include <platforms/4xx/redwood5.h>
 #endif
 
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/asm-ppc/ppc4xx_dma.h linux-2.6.12/include/asm-ppc/ppc4xx_dma.h
--- linux-2.6.12.orig/include/asm-ppc/ppc4xx_dma.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/include/asm-ppc/ppc4xx_dma.h	2005-06-25 21:31:57.000000000 +0200
@@ -182,7 +182,7 @@
 
 typedef uint32_t sgl_handle_t;
 
-#ifdef CONFIG_PPC4xx_EDMA
+#if defined(CONFIG_PPC4xx_DMA) && !defined(CONFIG_STBXXX_DMA)
 
 #define SGL_LIST_SIZE 4096
 #define DMA_PPC4xx_SIZE SGL_LIST_SIZE
@@ -285,6 +285,12 @@
 
 #define GET_DMA_POLARITY(chan) (DMAReq_ActiveLow(chan) | DMAAck_ActiveLow(chan) | EOT_ActiveLow(chan))
 
+
+#define DMA_CH_ENABLE (1<<7)
+#define GET_DMA_CH(x) (((x)&DMA_CH_ENABLE)>>7)
+
+
+//--------------------------------------------------------------------------
 #elif defined(CONFIG_STBXXX_DMA)		/* stb03xxx */
 
 #define DMA_PPC4xx_SIZE	4096
@@ -484,7 +490,7 @@
 	unsigned int mode;	/* transfer mode                     */
 	phys_addr_t addr;
 	char ce;		/* channel enable */
-#ifdef CONFIG_STB03xxx
+#if defined(CONFIG_STB03xxx) || defined(CONFIG_STBXXX_DMA)
 	char ch_enable;
 	char tcd_disable;
 	char ece_enable;
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/asm-ppc/usb.h linux-2.6.12/include/asm-ppc/usb.h
--- linux-2.6.12.orig/include/asm-ppc/usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/include/asm-ppc/usb.h	2005-06-26 21:35:40.000000000 +0200
@@ -0,0 +1,15 @@
+/*
+ * ppc/usb.h:
+ *
+ */
+#ifndef _PPC_USB_H
+#define _PPC_USB_H
+
+struct usb_hcd_platform_data {
+	char *name;
+	int (*start) (struct platform_device *pdev);
+	void (*stop) (struct platform_device *pdev);
+};
+
+#endif /* !(_PPC_USB_H) */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/fb.h linux-2.6.12/include/linux/fb.h
--- linux-2.6.12.orig/include/linux/fb.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/include/linux/fb.h	2005-06-24 23:26:07.000000000 +0200
@@ -107,6 +107,7 @@
 #define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
 #define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
 #define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_IBM_STB04		89  /* IBM STB04 */
 #define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
 #define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
 #define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/fusion.h linux-2.6.12/include/linux/fusion.h
--- linux-2.6.12.orig/include/linux/fusion.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/include/linux/fusion.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,202 @@
+#ifndef __LINUX__FUSION_H__
+#define __LINUX__FUSION_H__
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+/*
+ * Sending
+ */
+typedef struct {
+     int         fusion_id;      /* recipient */
+
+     int         msg_id;         /* optional message identifier */
+     int         msg_size;       /* message size, must be greater than zero */
+     const void *msg_data;       /* message data, must not be NULL */
+} FusionSendMessage;
+
+/*
+ * Receiving
+ */
+typedef enum {
+     FMT_SEND,
+     FMT_CALL,                   /* msg_id is the call id */
+     FMT_REACTOR                 /* msg_id is the reactor id */
+} FusionMessageType;
+
+typedef struct {
+     FusionMessageType msg_type;
+
+     int               msg_id;
+     int               msg_size;
+
+     /* message data follows */
+} FusionReadMessage;
+
+/*
+ * Dispatching
+ */
+typedef struct {
+     int         reactor_id;
+     int         self;
+
+     int         msg_size;       /* message size, must be greater than zero */
+     const void *msg_data;       /* message data, must not be NULL */
+} FusionReactorDispatch;
+
+/*
+ * Calling (synchronous RPC)
+ */
+typedef struct {
+     int                call_id;   /* new call id returned */
+
+     void              *handler;   /* function pointer of handler to install */
+     void              *ctx;       /* optional handler context */
+} FusionCallNew;
+
+typedef struct {
+     int   ret_val;              /* return value of the call */
+
+     int   call_id;              /* id of the requested call,
+                                    each call has a fixed owner */
+
+     int   call_arg;             /* optional int argument */
+     void *call_ptr;             /* optional pointer argument (shared memory) */
+} FusionCallExecute;
+
+typedef struct {
+     int   call_id;              /* id of currently executing call */
+
+     int   val;                  /* value to return */
+} FusionCallReturn;
+
+typedef struct {
+     void              *handler;   /* function pointer of handler to call */
+     void              *ctx;       /* optional handler context */
+
+     int                caller;    /* fusion id of the caller
+                                      or zero if the call comes from Fusion */
+     int                call_arg;  /* optional call parameter */
+     void              *call_ptr;  /* optional call parameter */
+} FusionCallMessage;
+
+/*
+ * Watching a reference
+ *
+ * This information is needed to have a specific call being executed if the
+ * reference count reaches zero. Currently one watch per reference is allowed.
+ *
+ * The call is made by Fusion and therefor has a caller id of zero.
+ *
+ */
+typedef struct {
+     int                id;        /* id of the reference to watch */
+
+     int                call_id;   /* id of the call to execute */
+     int                call_arg;  /* optional call parameter, e.g. the id of a
+                                      user space resource associated with that
+                                      reference */
+} FusionRefWatch;
+
+/*
+ * Inheriting local count from other reference
+ */
+typedef struct {
+     int                id;        /* own reference id */
+     int                from;      /* id of the reference to inherit from */
+} FusionRefInherit;
+
+/*
+ * Killing other fusionees (experimental)
+ */
+typedef struct {
+     int fusion_id;    /* fusionee to kill, zero means all but ourself */
+     int signal;       /* signal to be delivered, e.g. SIGTERM */
+     int timeout_ms;   /* -1 means no timeout, 0 means infinite, otherwise the
+                          max. time to wait until the fusionee(s) terminated */
+} FusionKill;
+
+
+typedef enum {
+     FT_LOUNGE,
+     FT_MESSAGING,
+     FT_CALL,
+     FT_REF,
+     FT_SKIRMISH,
+     FT_PROPERTY,
+     FT_REACTOR
+} FusionType;
+
+
+/*
+ * Set attributes like 'name' for an entry of the specified type.
+ */
+#define FUSION_ENTRY_INFO_NAME_LENGTH   24
+
+typedef struct {
+     FusionType type;
+     int        id;
+
+     char       name[FUSION_ENTRY_INFO_NAME_LENGTH];
+} FusionEntryInfo;
+
+
+typedef struct {
+     struct {
+          int major;
+          int minor;
+     } api;
+
+     int fusion_id;
+} FusionEnter;
+
+#define FUSION_API_MAJOR   1  /* Increased if backward compatibility is dropped. */
+#define FUSION_API_MINOR   1  /* Increased if new features are added. */
+
+
+#define FUSION_ENTER               _IOR(FT_LOUNGE,    0x00, FusionEnter)
+#define FUSION_KILL                _IOW(FT_LOUNGE,    0x01, FusionKill)
+
+#define FUSION_ENTRY_SET_INFO      _IOW(FT_LOUNGE,    0x02, FusionEntryInfo)
+#define FUSION_ENTRY_GET_INFO      _IOW(FT_LOUNGE,    0x03, FusionEntryInfo)
+
+#define FUSION_SEND_MESSAGE        _IOW(FT_MESSAGING, 0x00, FusionSendMessage)
+
+#define FUSION_CALL_NEW            _IOW(FT_CALL,      0x00, FusionCallNew)
+#define FUSION_CALL_EXECUTE        _IOW(FT_CALL,      0x01, FusionCallExecute)
+#define FUSION_CALL_RETURN         _IOW(FT_CALL,      0x02, FusionCallReturn)
+#define FUSION_CALL_DESTROY        _IOW(FT_CALL,      0x03, int)
+
+#define FUSION_REF_NEW             _IOW(FT_REF,       0x00, int)
+#define FUSION_REF_UP              _IOW(FT_REF,       0x01, int)
+#define FUSION_REF_UP_GLOBAL       _IOW(FT_REF,       0x02, int)
+#define FUSION_REF_DOWN            _IOW(FT_REF,       0x03, int)
+#define FUSION_REF_DOWN_GLOBAL     _IOW(FT_REF,       0x04, int)
+#define FUSION_REF_ZERO_LOCK       _IOW(FT_REF,       0x05, int)
+#define FUSION_REF_ZERO_TRYLOCK    _IOW(FT_REF,       0x06, int)
+#define FUSION_REF_UNLOCK          _IOW(FT_REF,       0x07, int)
+#define FUSION_REF_STAT            _IOW(FT_REF,       0x08, int)
+#define FUSION_REF_WATCH           _IOW(FT_REF,       0x09, FusionRefWatch)
+#define FUSION_REF_INHERIT         _IOW(FT_REF,       0x0A, FusionRefInherit)
+#define FUSION_REF_DESTROY         _IOW(FT_REF,       0x0B, int)
+
+#define FUSION_SKIRMISH_NEW        _IOW(FT_SKIRMISH,  0x00, int)
+#define FUSION_SKIRMISH_PREVAIL    _IOW(FT_SKIRMISH,  0x01, int)
+#define FUSION_SKIRMISH_SWOOP      _IOW(FT_SKIRMISH,  0x02, int)
+#define FUSION_SKIRMISH_DISMISS    _IOW(FT_SKIRMISH,  0x03, int)
+#define FUSION_SKIRMISH_DESTROY    _IOW(FT_SKIRMISH,  0x04, int)
+
+#define FUSION_PROPERTY_NEW        _IOW(FT_PROPERTY,  0x00, int)
+#define FUSION_PROPERTY_LEASE      _IOW(FT_PROPERTY,  0x01, int)
+#define FUSION_PROPERTY_PURCHASE   _IOW(FT_PROPERTY,  0x02, int)
+#define FUSION_PROPERTY_CEDE       _IOW(FT_PROPERTY,  0x03, int)
+#define FUSION_PROPERTY_HOLDUP     _IOW(FT_PROPERTY,  0x04, int)
+#define FUSION_PROPERTY_DESTROY    _IOW(FT_PROPERTY,  0x05, int)
+
+#define FUSION_REACTOR_NEW         _IOW(FT_REACTOR,   0x00, int)
+#define FUSION_REACTOR_ATTACH      _IOW(FT_REACTOR,   0x01, int)
+#define FUSION_REACTOR_DETACH      _IOW(FT_REACTOR,   0x02, int)
+#define FUSION_REACTOR_DISPATCH    _IOW(FT_REACTOR,   0x03, FusionReactorDispatch)
+#define FUSION_REACTOR_DESTROY     _IOW(FT_REACTOR,   0x04, int)
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/i2c.h linux-2.6.12/include/linux/i2c.h
--- linux-2.6.12.orig/include/linux/i2c.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/include/linux/i2c.h	2005-06-26 22:12:35.000000000 +0200
@@ -142,6 +142,7 @@
  * function is mainly used for lookup & other admin. functions.
  */
 struct i2c_client {
+	int id;
 	unsigned int flags;		/* div., see below		*/
 	unsigned int addr;		/* chip address - NOTE: 7bit 	*/
 					/* addresses are stored in the	*/
@@ -387,6 +388,7 @@
  	__u16 flags;		
 #define I2C_M_TEN	0x10	/* we have a ten bit chip address	*/
 #define I2C_M_RD	0x01
+#define I2C_CLIENT_FAST	0x100
 #define I2C_M_NOSTART	0x4000
 #define I2C_M_REV_DIR_ADDR	0x2000
 #define I2C_M_IGNORE_NAK	0x1000
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/mtd/physmap.h linux-2.6.12/include/linux/mtd/physmap.h
--- linux-2.6.12.orig/include/linux/mtd/physmap.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/include/linux/mtd/physmap.h	2005-06-28 02:30:19.000000000 +0200
@@ -33,7 +32,7 @@
 /*
  * Board needs to specify the exact mapping during their setup time.
  */
-static inline void physmap_configure(unsigned long addr, unsigned long size, int bankwidth, void (*set_vpp)(struct map_info *, int) )
+static void inline physmap_configure(unsigned long addr, unsigned long size, int bankwidth, void (*set_vpp)(struct map_info *, int) )
 {
 	physmap_map.phys = addr;
 	physmap_map.size = size;
@@ -41,8 +40,9 @@
 	physmap_map.set_vpp = set_vpp;
 }
 
-#if defined(CONFIG_MTD_PARTITIONS)
 
+
+#if defined(CONFIG_MTD_PARTITIONS)
 /*
  * Machines that wish to do flash partition may want to call this function in 
  * their setup routine.  
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/soundcard.h linux-2.6.12/include/linux/soundcard.h
--- linux-2.6.12.orig/include/linux/soundcard.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/include/linux/soundcard.h	2005-06-25 15:45:08.000000000 +0200
@@ -574,6 +574,17 @@
 #	define AFMT_MPEG		0x00000200	/* MPEG (2) audio */
 #	define AFMT_AC3		0x00000400	/* Dolby Digital AC3 */
 
+/* because they *do* exist and we want to use them --Monty */
+#define AFMT_S24_LE		0x00000800
+#define AFMT_S24_BE		0x00001000
+#define AFMT_U24_LE		0x00002000
+#define AFMT_U24_BE		0x00004000
+#define AFMT_S32_LE		0x00008000
+#define AFMT_S32_BE		0x00010000
+#define AFMT_U32_LE		0x00020000
+#define AFMT_U32_BE		0x00040000
+
+
 /*
  * Buffer status queries.
  */
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/squashfs_fs.h linux-2.6.12/include/linux/squashfs_fs.h
--- linux-2.6.12.orig/include/linux/squashfs_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/include/linux/squashfs_fs.h	2005-06-24 23:00:05.000000000 +0200
@@ -0,0 +1,512 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#define SQUASHFS_MAJOR			2
+#define SQUASHFS_MINOR			1
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		65536
+#define SQUASHFS_FILE_LOG		16
+
+#define SQUASHFS_FILE_MAX_SIZE		65536
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) 0xffffffff)
+#define SQUASHFS_USED_BLK		((long long) 0xfffffffe)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOI)
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOD)
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOF)
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, SQUASHFS_NO_FRAG)
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, SQUASHFS_ALWAYS_FRAG)
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, SQUASHFS_DUPLICATE)
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, SQUASHFS_CHECK)
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, duplicate_checking)	(noi | (nod << 1) | (check_data << 2) | (nof << 3) | (no_frag << 4) | (always_frag << 5) | (duplicate_checking << 6))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+					(B) & ~SQUASHFS_COMPRESSED_BIT : SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT_BLOCK) ? \
+					(B) & ~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)		(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an uncompressed
+ * offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode)(((squashfs_inode) (A) << 16)\
+					+ (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + ((b) >> 2) + 1))
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+typedef unsigned int			squashfs_fragment_index;
+#define SQUASHFS_FRAGMENT_BYTES(A)	(A * sizeof(squashfs_fragment_entry))
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / SQUASHFS_METADATA_SIZE)
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % SQUASHFS_METADATA_SIZE)
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + SQUASHFS_METADATA_SIZE - 1) / SQUASHFS_METADATA_SIZE)
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) * sizeof(squashfs_fragment_index))
+#define SQUASHFS_CACHED_FRAGMENTS	3
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	32
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << (SQUASHFS_MAX_FILE_SIZE_LOG - 1))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef unsigned int		squashfs_block;
+typedef long long		squashfs_inode;
+
+typedef unsigned int		squashfs_uid;
+
+typedef struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used;
+	unsigned int		uid_start;
+	unsigned int		guid_start;
+	unsigned int		inode_table_start;
+	unsigned int		directory_table_start;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode		root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start;
+} __attribute__ ((packed)) squashfs_super_block;
+
+typedef struct {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed)) squashfs_dir_index;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed)) squashfs_base_inode_header;
+
+typedef squashfs_base_inode_header squashfs_ipc_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed)) squashfs_dev_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed)) squashfs_symlink_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	squashfs_block		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
+	unsigned short		block_list[0];
+} __attribute__ ((packed)) squashfs_reg_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed)) squashfs_dir_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	squashfs_dir_index	index[0];
+} __attribute__  ((packed)) squashfs_ldir_inode_header;
+
+typedef union {
+	squashfs_base_inode_header	base;
+	squashfs_dev_inode_header	dev;
+	squashfs_symlink_inode_header	symlink;
+	squashfs_reg_inode_header	reg;
+	squashfs_dir_inode_header	dir;
+	squashfs_ldir_inode_header	ldir;
+	squashfs_ipc_inode_header	ipc;
+} squashfs_inode_header;
+
+typedef struct {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed)) squashfs_dir_entry;
+
+typedef struct {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed)) squashfs_dir_header;
+
+typedef struct {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed)) squashfs_fragment_entry;
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem on a
+ * machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 472, 32);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_ipc_inode_header))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dev_inode_header));\
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, SQUASHFS_MAX_FILE_SIZE_LOG);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += 16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += 32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed)) squashfs_base_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed)) squashfs_ipc_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed)) squashfs_dev_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed)) squashfs_symlink_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	squashfs_block		start_block;
+	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
+	unsigned short		block_list[0];
+} __attribute__ ((packed)) squashfs_reg_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed)) squashfs_dir_inode_header_1;
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, sizeof(squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, sizeof(squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, SQUASHFS_MAX_FILE_SIZE_LOG);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+#endif
+
+#ifdef __KERNEL__
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing architectures
+ */
+#include <asm/byteorder.h>
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, b_pos)
+#else
+	/* convert from big endian to little endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	int bits;\
+	int b_pos = pos % 8;\
+	unsigned long long val = 0;\
+	unsigned char *s = (unsigned char *)p + (pos / 8);\
+	unsigned char *d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+#endif
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/squashfs_fs_i.h linux-2.6.12/include/linux/squashfs_fs_i.h
--- linux-2.6.12.orig/include/linux/squashfs_fs_i.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/include/linux/squashfs_fs_i.h	2005-06-24 23:00:28.000000000 +0200
@@ -0,0 +1,43 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+typedef struct squashfs_inode_info {
+	unsigned int	start_block;
+	unsigned int	block_list_start;
+	unsigned int	offset;
+	union {
+		struct {
+			unsigned int	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+		} s1;
+		struct {
+			unsigned int	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+		} s2;
+	} u;
+	struct inode	vfs_inode;
+	} squashfs_inode_info;
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/squashfs_fs_sb.h linux-2.6.12/include/linux/squashfs_fs_sb.h
--- linux-2.6.12.orig/include/linux/squashfs_fs_sb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/include/linux/squashfs_fs_sb.h	2005-06-24 22:59:13.000000000 +0200
@@ -0,0 +1,65 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+
+typedef struct {
+	unsigned int	block;
+	int		length;
+	unsigned int	next_index;
+	char		*data;
+	} squashfs_cache;
+
+struct squashfs_fragment_cache {
+	unsigned int	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+	};
+
+typedef struct squashfs_sb_info {
+	squashfs_super_block	sBlk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	squashfs_cache		*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	squashfs_uid		*uid;
+	squashfs_uid		*guid;
+	squashfs_fragment_index		*fragment_index;
+	unsigned int		read_size;
+	char			*read_data;
+	char			*read_page;
+	struct semaphore	read_page_mutex;
+	struct semaphore	block_cache_mutex;
+	struct semaphore	fragment_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct inode		*(*iget)(struct super_block *s, squashfs_inode inode);
+	unsigned int		(*read_blocklist)(struct inode *inode, int index, int readahead_blks,
+					char *block_list, unsigned short **block_p, unsigned int *bsize);
+	} squashfs_sb_info;
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/init/do_mounts_rd.c linux-2.6.12/init/do_mounts_rd.c
--- linux-2.6.12.orig/init/do_mounts_rd.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/init/do_mounts_rd.c	2005-06-24 22:50:16.000000000 +0200
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ *  squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,15 @@
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+		       "RAMDISK: squashfs filesystem found at block %d\n",
+		       start_block);
+		nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
